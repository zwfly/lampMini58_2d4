C51 COMPILER V9.52.0.0   APP_UART                                                          11/20/2017 00:30:11 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE APP_UART
OBJECT MODULE PLACED IN .\Out\Objects\app_uart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\App\src\app_uart.c LARGE OPTIMIZE(8,SIZE) BROWSE INCDIR(..\Common\inc
                    -;..\App\inc;..\Bsp\inc;..\Startup;..\Bsp) DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\Out\Listings\app_uart.lst) TABS
                    -(2) OBJECT(.\Out\Objects\app_uart.obj)

line level    source

   1          /*
   2           * app_uart.c
   3           *
   4           *  Created on: 2017年8月31日
   5           *      Author: fly
   6           */
   7          
   8          #include "app.h"
   9          #include <string.h>
  10          
  11          #define BT_MODE     0x01
  12          #define FM_MODE     0x02
  13          #define USB_MODE    0x03
  14          #define AUX_MODE    0x04
  15          #define DOME_MODE   0x05
  16          #define CALL_MODE   0x06
  17          
  18          static uint8_t index = 0;
  19          static uint8_t len = 0;
  20          static uint8_t i = 0, j = 0;
  21          static uint16_t tmp = 0;
  22          static uint8_t u8_tmp = 0;
  23          static uint8_t uart_sendBuf[16] = { 0 };
  24          
  25          void app_uart_Init(void) {
  26   1        index = 0;
  27   1        len = 0;
  28   1        i = 0;
  29   1      
  30   1        memset((uint8_t *) &rcv_T, 0, sizeof(RCV_T));
  31   1      }
  32          
  33          void app_uart_send(uint8_t cmd, uint8_t *ptr, uint8_t len) {
  34   1        index = 0;
  35   1      
  36   1        uart_sendBuf[index++] = 0x55;
  37   1        uart_sendBuf[index++] = 0xAA;
  38   1        uart_sendBuf[index++] = len + 1;
  39   1        uart_sendBuf[index++] = cmd;
  40   1        for (i = 0; i < len; i++) {
  41   2          uart_sendBuf[index++] = *(ptr + i);
  42   2        }
  43   1        uart_sendBuf[index++] = app_CalcCRC8(uart_sendBuf, len + 4);
  44   1      
  45   1        for (i = 0; i < (len + 5); i++) {
  46   2          Send_Data_To_UART0(uart_sendBuf[i]);
  47   2        }
  48   1      }
  49          
  50          void app_uart_pro(void) {
  51   1        while (riflag) {
  52   2          riflag--;
  53   2          if ((rcv_T.pWrite + RCV_BUFSIZE - rcv_T.pRead) % RCV_BUFSIZE >= 4) {
C51 COMPILER V9.52.0.0   APP_UART                                                          11/20/2017 00:30:11 PAGE 2   

  54   3            if (((rcv_T.rxBuf[rcv_T.pRead]) == 0x55)
  55   3                && ((rcv_T.rxBuf[(rcv_T.pRead + 1) % RCV_BUFSIZE]) == 0xAA)) {
  56   4              len = rcv_T.rxBuf[(rcv_T.pRead + 2) % RCV_BUFSIZE];
  57   4              if ((rcv_T.pWrite + RCV_BUFSIZE - rcv_T.pRead) % RCV_BUFSIZE
  58   4                  >= (len + 4)) {
  59   5                if (rcv_T.rxBuf[(rcv_T.pRead + len + 3) % RCV_BUFSIZE]
  60   5                    != app_CalcCRC8_cycle(rcv_T.rxBuf + rcv_T.pRead,
  61   5                        len + 3, rcv_T.pRead, RCV_BUFSIZE)) {
  62   6                  rcv_T.pRead++;
  63   6                } else {
  64   6                  index = 0;
  65   6                  memset(sendBuf, 0, PAYLOAD_WIDTH);
  66   6                  switch (rcv_T.rxBuf[(rcv_T.pRead + 3) % RCV_BUFSIZE]) {
  67   7                  case BLINK_METHOD_CMD:  //闪法
  68   7                  {
  69   8                    uint16_t index = 0;
  70   8                    index =
  71   8                        rcv_T.rxBuf[(rcv_T.pRead + 12) % RCV_BUFSIZE];
  72   8      
  73   8                    if (index >= (DEFAULT_DOME_NUM - 1)) {
  74   9                      break;
  75   9                    }
  76   8                    if (index == 0) {
  77   9                      u8_tmp = (0x4800 - DOME_START_ADDR) / 128;
  78   9                      for (i = 0; i < u8_tmp; i++) {
  79  10                        app_eeprom_erase(i * 128);
  80  10                      }
  81   9                    }
  82   8      #if 0
                            for (i = (index + 1); i < DEFAULT_DOME_NUM; i++) {
                              uint16_t addr = i * sizeof(DOME_DEFAULT_T)
                              + (&dome_blink.header.index
                                  - &dome_blink);
                              app_eeprom_write_byte(addr, 0);
                              nop
                            }
              #endif
  91   8      #if 1
  92   8                    tmp = rcv_T.rxBuf[(rcv_T.pRead + 13) % RCV_BUFSIZE]
  93   8                        & 0x0F;
  94   8                    for (i = 0;
  95   8                        i
  96   8                            < (tmp * sizeof(SUBDOME_T)
  97   8                                + sizeof(DOME_HEADER_T));
  98   8                        i++) {
  99   9                      uint16_t addr = index * sizeof(DOME_DEFAULT_T)
 100   9                          + i;
 101   9                      app_eeprom_write_byte(addr,
 102   9                          rcv_T.rxBuf[(rcv_T.pRead + 4 + i)
 103   9                              % RCV_BUFSIZE]);
 104   9                    }
 105   8      
 106   8      #endif
 107   8                    u8_tmp = index & 0xFF;
 108   8                    app_uart_send(BLINK_METHOD_CMD, &u8_tmp, 1);
 109   8                  }
 110   7                    break;
 111   7                  case RCV_VOL_CMD:
 112   7                    sendBuf[index++] = LAMP2LCD_HEADER;
 113   7                    sendBuf[index++] = len;
 114   7                    sendBuf[index++] = RCV_VOL_CMD;
 115   7                    for (i = 0; i < (len - 1); i++) {
C51 COMPILER V9.52.0.0   APP_UART                                                          11/20/2017 00:30:11 PAGE 3   

 116   8                      sendBuf[index++] = rcv_T.rxBuf[(rcv_T.pRead + 4
 117   8                          + i) % RCV_BUFSIZE];
 118   8                    }
 119   7                    for (i = 0; i < (sendBuf[1] + 1); i++) {
 120   8                      sendBuf[index] += sendBuf[i + 1];
 121   8                    }
 122   7                    index++;
 123   7                    app_2d4_send(sendBuf, index);
 124   7                    break;
 125   7                  case RCV_POWER_STATUS_CMD:
 126   7                    sendBuf[index++] = LAMP2LCD_HEADER;
 127   7                    sendBuf[index++] = len;
 128   7                    sendBuf[index++] = RCV_POWER_STATUS_CMD;
 129   7                    for (i = 0; i < (len - 1); i++) {
 130   8                      sendBuf[index++] = rcv_T.rxBuf[(rcv_T.pRead + 4
 131   8                          + i) % RCV_BUFSIZE];
 132   8                    }
 133   7                    for (i = 0; i < (sendBuf[1] + 1); i++) {
 134   8                      sendBuf[index] += sendBuf[i + 1];
 135   8                    }
 136   7                    index++;
 137   7                    app_2d4_send(sendBuf, index);
 138   7                    break;
 139   7      #if 0
                            case RCV_X_BOX_STATUS_CMD:
                            sendBuf[index++] = LAMP2LCD_HEADER;
                            sendBuf[index++] = len;
                            sendBuf[index++] = RCV_X_BOX_STATUS_CMD;
                            for (i = 0; i < (len - 1); i++) {
                              sendBuf[index++] = rcv_T.rxBuf[(rcv_T.pRead + 4
                                  + i) % RCV_BUFSIZE];
                            }
                            for (i = 0; i < (sendBuf[1] + 1); i++) {
                              sendBuf[index] += sendBuf[i + 1];
                            }
                            index++;
                            app_2d4_send(sendBuf, index);
                            break;
              #endif
 155   7                  case RCV_BT_STATUS_CMD:
 156   7                    sendBuf[index++] = LAMP2LCD_HEADER;
 157   7                    sendBuf[index++] = len;
 158   7                    sendBuf[index++] = RCV_BT_STATUS_CMD;
 159   7                    for (i = 0; i < (len - 1); i++) {
 160   8                      sendBuf[index++] = rcv_T.rxBuf[(rcv_T.pRead + 4
 161   8                          + i) % RCV_BUFSIZE];
 162   8                    }
 163   7                    for (i = 0; i < (sendBuf[1] + 1); i++) {
 164   8                      sendBuf[index] += sendBuf[i + 1];
 165   8                    }
 166   7                    index++;
 167   7                    if (g_tWork.status.bits.DOME == 0) {
 168   8                      app_2d4_send(sendBuf, index);
 169   8                    }
 170   7                    break;
 171   7                  case RCV_PREV_NEXT_CMD:
 172   7                    sendBuf[index++] = LAMP2LCD_HEADER;
 173   7                    sendBuf[index++] = len;
 174   7                    sendBuf[index++] = RCV_PREV_NEXT_CMD;
 175   7                    for (i = 0; i < (len - 1); i++) {
 176   8                      sendBuf[index++] = rcv_T.rxBuf[(rcv_T.pRead + 4
 177   8                          + i) % RCV_BUFSIZE];
C51 COMPILER V9.52.0.0   APP_UART                                                          11/20/2017 00:30:11 PAGE 4   

 178   8                    }
 179   7                    for (i = 0; i < (sendBuf[1] + 1); i++) {
 180   8                      sendBuf[index] += sendBuf[i + 1];
 181   8                    }
 182   7                    index++;
 183   7                    if (g_tWork.status.bits.DOME == 0) {
 184   8                      app_2d4_send(sendBuf, index);
 185   8                    }
 186   7                    break;
 187   7                  case RCV_USB_PLAY_TIME_CMD:
 188   7                    sendBuf[index++] = LAMP2LCD_HEADER;
 189   7                    sendBuf[index++] = len;
 190   7                    sendBuf[index++] = RCV_USB_PLAY_TIME_CMD;
 191   7                    for (i = 0; i < (len - 1); i++) {
 192   8                      sendBuf[index++] = rcv_T.rxBuf[(rcv_T.pRead + 4
 193   8                          + i) % RCV_BUFSIZE];
 194   8                    }
 195   7                    for (i = 0; i < (sendBuf[1] + 1); i++) {
 196   8                      sendBuf[index] += sendBuf[i + 1];
 197   8                    }
 198   7                    index++;
 199   7                    if (g_tWork.status.bits.DOME == 0) {
 200   8                      app_2d4_send(sendBuf, index);
 201   8                    }
 202   7                    break;
 203   7                  case RCV_FM_HZ_CMD:
 204   7                    sendBuf[index++] = LAMP2LCD_HEADER;
 205   7                    sendBuf[index++] = len;
 206   7                    sendBuf[index++] = RCV_FM_HZ_CMD;
 207   7                    for (i = 0; i < (len - 1); i++) {
 208   8                      sendBuf[index++] = rcv_T.rxBuf[(rcv_T.pRead + 4
 209   8                          + i) % RCV_BUFSIZE];
 210   8                    }
 211   7                    for (i = 0; i < (sendBuf[1] + 1); i++) {
 212   8                      sendBuf[index] += sendBuf[i + 1];
 213   8                    }
 214   7                    index++;
 215   7      
 216   7                    if (g_tWork.status.bits.DOME == 0) {
 217   8                      app_2d4_send(sendBuf, index);
 218   8                    }
 219   7                    break;
 220   7                  case MODE_CHANGE_CMD:   //MODE
 221   7                    sendBuf[index++] = LAMP2LCD_HEADER;
 222   7                    sendBuf[index++] = len;
 223   7                    sendBuf[index++] = MODE_CHANGE_CMD;
 224   7                    for (i = 0; i < (len - 1); i++) {
 225   8                      sendBuf[index++] = rcv_T.rxBuf[(rcv_T.pRead + 4
 226   8                          + i) % RCV_BUFSIZE];
 227   8                    }
 228   7                    for (i = 0; i < (sendBuf[1] + 1); i++) {
 229   8                      sendBuf[index] += sendBuf[i + 1];
 230   8                    }
 231   7                    index++;
 232   7                    app_2d4_send(sendBuf, index);
 233   7                    break;
 234   7                  case RCV_PLAY_PAUSE_STATUS_CMD:
 235   7                    sendBuf[index++] = LAMP2LCD_HEADER;
 236   7                    sendBuf[index++] = len;
 237   7                    sendBuf[index++] =
 238   7                    RCV_PLAY_PAUSE_STATUS_CMD;
 239   7                    for (i = 0; i < (len - 1); i++) {
C51 COMPILER V9.52.0.0   APP_UART                                                          11/20/2017 00:30:11 PAGE 5   

 240   8                      sendBuf[index++] = rcv_T.rxBuf[(rcv_T.pRead + 4
 241   8                          + i) % RCV_BUFSIZE];
 242   8                    }
 243   7                    for (i = 0; i < (sendBuf[1] + 1); i++) {
 244   8                      sendBuf[index] += sendBuf[i + 1];
 245   8                    }
 246   7                    index++;
 247   7                    if (g_tWork.status.bits.DOME == 0) {
 248   8                      app_2d4_send(sendBuf, index);
 249   8                    }
 250   7                    break;
 251   7                    /// app --start
 252   7                  case KEY_CARD_POWER_CMD:
 253   7                    if (g_tWork.status.bits.blinkEnable == 0) {
 254   8      //                g_tWork.status.bits.pause = 0;
 255   8                      g_tWork.status.bits.blinkEnable = 1;
 256   8                      g_tWork.status.bits.DEMO = 1;
 257   8                      app_dome_start_current();
 258   8                    } else {
 259   8      //                g_tWork.status.bits.pause = 1;
 260   8                      g_tWork.status.bits.blinkEnable = 0;
 261   8                      g_tWork.status.bits.DEMO = 0;
 262   8                      app_dome_stop_current();
 263   8                    }
 264   7                    sendBuf[index++] = LAMP2LCD_HEADER;
 265   7                    sendBuf[index++] = 10;
 266   7                    sendBuf[index++] = KEY_POWER_SHORT_CMD;
 267   7                    sendBuf[index++] = g_tWork.status.bits.blinkEnable;
 268   7                    app_dome_get_current_Name(sendBuf + index, 8);
 269   7                    index += 8;
 270   7                    for (i = 0; i < (sendBuf[1] + 1); i++) {
 271   8                      sendBuf[index] += sendBuf[i + 1];
 272   8                    }
 273   7                    index++;
 274   7                    app_2d4_send(sendBuf, index);
 275   7                    break;
 276   7                  case KEY_CARD_DEMO_CMD:
 277   7      //              if (g_tWork.status.bits.DEMO) {
 278   7      //                g_tWork.status.bits.DEMO = 0;
 279   7      //              } else {
 280   7                    g_tWork.status.bits.DEMO = 1;
 281   7      //              }
 282   7                    app_dome_start(0, 0);
 283   7      
 284   7                    break;
 285   7                  case APP_COLOR_ATLA_CMD:
 286   7      #if 1
 287   7                    app_dome_rgb(
 288   7                        rcv_T.rxBuf[(rcv_T.pRead + 4) % RCV_BUFSIZE],
 289   7                        rcv_T.rxBuf[(rcv_T.pRead + 5) % RCV_BUFSIZE],
 290   7                        rcv_T.rxBuf[(rcv_T.pRead + 6) % RCV_BUFSIZE]);
 291   7      #else
                            app_dome_rgb(0xFFFF, 0xFFFF, 0xFFFF);
              #endif
 294   7                    break;
 295   7                  case APP_BRIGHT_CMD:
 296   7                    dome_running_param.bright = rcv_T.rxBuf[(rcv_T.pRead
 297   7                        + 4) % RCV_BUFSIZE];
 298   7                    Light_bright_set(
 299   7                        rcv_T.rxBuf[(rcv_T.pRead + 4) % RCV_BUFSIZE]);
 300   7                    break;
 301   7                  case APP_SPEED_CMD:
C51 COMPILER V9.52.0.0   APP_UART                                                          11/20/2017 00:30:11 PAGE 6   

 302   7                    dome_running_param.speed = rcv_T.rxBuf[(rcv_T.pRead
 303   7                        + 4) % RCV_BUFSIZE];
 304   7                    break;
 305   7                  case APP_FLASH_INDEX_CMD:
 306   7                    g_tWork.status.bits.DEMO = 0;
 307   7                    app_dome_start_current();
 308   7                    app_dome_start(
 309   7                        rcv_T.rxBuf[(rcv_T.pRead + 4) % RCV_BUFSIZE],
 310   7                        0);
 311   7                    break;
 312   7                  case APP_SWITCH_INDEX_CMD: {
 313   8                    uint8_t switchData = rcv_T.rxBuf[(rcv_T.pRead + 4)
 314   8                        % RCV_BUFSIZE];
 315   8                    if (((switchData >> 4) & 0x0F) == 0) {
 316   9                      Relay_set(switchData & 0x0F);
 317   9                    }
 318   8                  }
 319   7                    break;
 320   7                    /// app --end
 321   7                  default:
 322   7                    break;
 323   7                  }
 324   6                  rcv_T.pRead += len + 4;
 325   6      #if 1
 326   6                  rcv_T.pRead = rcv_T.pRead % RCV_BUFSIZE;
 327   6      //            break;
 328   6                  return;
 329   6      #endif
 330   6                }
 331   5              }
 332   4            } else {
 333   4              rcv_T.pRead++;
 334   4            }
 335   3            rcv_T.pRead = rcv_T.pRead % RCV_BUFSIZE;
 336   3          }
 337   2        }
 338   1      
 339   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3306    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     23       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
