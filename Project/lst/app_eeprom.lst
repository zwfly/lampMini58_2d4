L 1 "..\App\src\app_eeprom.c"
N/*
N * app_eeprom.c
N *
N *  Created on: 2017年9月8日
N *      Author: fly
N */
N#include "app.h"
L 1 "..\App\inc\app.h" 1
N/*
N * app.h
N *
N *  Created on: 2017年7月6日
N *      Author: admin
N */
N
N#ifndef APP_INC_APP_H_
N#define APP_INC_APP_H_
N
N#define DEBUG   0
N
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060019
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 14 "..\App\inc\app.h" 2
N
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 16 "..\App\inc\app.h" 2
N
N#include "bsp.h"
L 1 "..\Bsp\bsp.h" 1
N#ifndef _BSP_H_
N#define _BSP_H
N
N#include <stdio.h>
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 6 "..\Bsp\bsp.h" 2
N#include "Mini58Series.h"
L 1 "..\Library\Device\Nuvoton\Mini58Series\Include\Mini58Series.h" 1
N/**************************************************************************//**
N * @file     Mini58Series.h
N * @version  V1.00
N * $Revision: 36 $
N * $Date: 16/06/08 1:31p $
N * @brief    Mini58 series peripheral access layer header file.
N *           This file contains all the peripheral register's definitions,
N *           bits definitions and memory mapping for NuMicro Mini58 series MCU.
N *
N * @note
N * Copyright (C) 2017 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N/**
N   \mainpage NuMicro Mini58 Driver Reference Guide
N   *
N   * <b>Introduction</b>
N   *
N   * This user manual describes the usage of Mini58 Series MCU device driver
N   *
N   * <b>Disclaimer</b>
N   *
N   * The Software is furnished "AS IS", without warranty as to performance or results, and
N   * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N   * warranties, express, implied or otherwise, with regard to the Software, its use, or
N   * operation, including without limitation any and all warranties of merchantability, fitness
N   * for a particular purpose, and non-infringement of intellectual property rights.
N   *
N   * <b>Important Notice</b>
N   *
N   * Nuvoton Products are neither intended nor warranted for usage in systems or equipment,
N   * any malfunction or failure of which may cause loss of human life, bodily injury or severe
N   * property damage. Such applications are deemed, "Insecure Usage".
N   *
N   * Insecure usage includes, but is not limited to: equipment for surgical implementation,
N   * atomic energy control instruments, airplane or spaceship instruments, the control or
N   * operation of dynamic, brake or safety systems designed for vehicular use, traffic signal
N   * instruments, all types of safety devices, and other applications intended to support or
N   * sustain life.
N   *
N   * All Insecure Usage shall be made at customer's risk, and in the event that third parties
N   * lay claims to Nuvoton as a result of customer's Insecure Usage, customer shall indemnify
N   * the damages and liabilities thus incurred by Nuvoton.
N   *
N   * Please note that all data and specifications are subject to change without notice. All the
N   * trademarks of products and companies mentioned in this datasheet belong to their respective
N   * owners.
N   *
N   * <b>Copyright Notice</b>
N   *
N   * Copyright (C) 2015-2017 Nuvoton Technology Corp. All rights reserved.
N   */
N
N#ifndef __MINI58SERIES_H__
N#define __MINI58SERIES_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @addtogroup Mini58_Definitions Mini58 Definitions
N  This file defines all structures and symbols for Mini58:
N    - interrupt numbers
N    - registers and bit fields
N    - peripheral base address
N    - peripheral ID
N    - Peripheral definitions
N  @{
N*/
N
N/******************************************************************************/
N/*                Processor and Core Peripherals                              */
N/******************************************************************************/
N/** @addtogroup Mini58_CMSIS Device CMSIS Definitions
N  Configuration of the Cortex-M0 Processor and Core Peripherals
N  @{
N*/
N
N/**
N * @details  Interrupt Number Definition. The maximum of 32 Specific Interrupts are possible.
N */
Ntypedef enum IRQn {
N    /******  Cortex-M0 Processor Exceptions Numbers *****************************************/
N
N    NonMaskableInt_IRQn   = -14,    /*!< 2 Non Maskable Interrupt                           */
N    HardFault_IRQn        = -13,    /*!< 3 Cortex-M0 Hard Fault Interrupt                   */
N    SVCall_IRQn           = -5,     /*!< 11 Cortex-M0 SV Call Interrupt                     */
N    PendSV_IRQn           = -2,     /*!< 14 Cortex-M0 Pend SV Interrupt                     */
N    SysTick_IRQn          = -1,     /*!< 15 Cortex-M0 System Tick Interrupt                 */
N
N    /******  Mini58 specific Interrupt Numbers ***********************************************/
N
N    BOD_IRQn              = 0,      /*!< Brownout low voltage detected interrupt            */
N    WDT_IRQn              = 1,      /*!< Watch Dog Timer interrupt                          */
N    EINT0_IRQn            = 2,      /*!< External signal interrupt from P3.2 pin            */
N    EINT1_IRQn            = 3,      /*!< External signal interrupt from P3.3 pin            */
N    GPIO01_IRQn           = 4,      /*!< External signal interrupt from P0/P1               */
N    GPIO234_IRQn          = 5,      /*!< External interrupt from P2/P3/P4                   */
N    PWM_IRQn              = 6,      /*!< PWM interrupt                                      */
N    FB_IRQn               = 7,      /*!< Fault brake interrupt                              */
N    TMR0_IRQn             = 8,      /*!< Timer 0 interrupt                                  */
N    TMR1_IRQn             = 9,      /*!< Timer 1 interrupt                                  */
N    UART0_IRQn            = 12,     /*!< UART0 interrupt                                    */
N    UART1_IRQn            = 13,     /*!< UART1 interrupt                                    */
N    SPI_IRQn              = 14,     /*!< SPI interrupt                                      */
N    GPIO5_IRQn            = 16,     /*!< External interrupt from P5                         */
N    HIRC_IRQn             = 17,     /*!< HIRC trim interrupt                                */
N    I2C0_IRQn             = 18,     /*!< I2C0 interrupt                                     */
N    I2C1_IRQn             = 19,     /*!< I2C1 interrupt                                     */
N    ACMP_IRQn             = 25,     /*!< ACMP interrupt                                     */
N    PDWU_IRQn             = 28,     /*!< Power Down Wake up interrupt                       */
N    ADC_IRQn              = 29      /*!< ADC interrupt                                      */
N
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N
N/* Configuration of the Cortex-M0 Processor and Core Peripherals */
N#define __CM0_REV                0x0201    /*!< Core Revision r2p1                               */
N#define __NVIC_PRIO_BITS         2         /*!< Number of Bits used for Priority Levels          */
N#define __Vendor_SysTickConfig   0         /*!< Set to 1 if different SysTick Config is used     */
N#define __MPU_PRESENT            0         /*!< MPU present or not                               */
N#define __FPU_PRESENT            0         /*!< FPU present or not                               */
N
N/*@}*/ /* end of group Mini58_CMSIS */
N
N
N#include "core_cm0.h"                       /* Cortex-M0 processor and core peripherals           */
L 1 "..\Library\CMSIS\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N#include <stdint.h>
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M0
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CMSIS HAL main version */
N#define __CM0_CMSIS_VERSION_SUB   (0x1EU)                                      /*!< [15:0]  CMSIS HAL sub version */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM0_CMSIS_VERSION_SUB           )        /*!< CMSIS HAL version number */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) |                                     __CM0_CMSIS_VERSION_SUB           )         
N
N#define __CORTEX_M                (0x00U)                                      /*!< Cortex-M Core */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler */
S  #define __INLINE         inline                                    /*!< inline keyword for COSMIC Compiler. Use -pc99 on compile line */
S  #define __STATIC_INLINE  static inline
S
S#else
S  #error Unknown compiler
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "core_cmInstr.h"                /* Core Instruction Access */
L 1 "..\Library\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "..\Library\CMSIS\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS Cortex-M Core Function/Instruction Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060422 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x00U) >= 0x03U) || (__CORTEX_SC >= 300U)
S
S/**
S  \brief   Enable FIQ
S  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/**
S  \brief   Disable FIQ
S  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/**
S  \brief   Get Base Priority
S  \details Returns the current value of the Base Priority register.
S  \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/**
S  \brief   Set Base Priority
S  \details Assigns the given value to the Base Priority register.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Set Base Priority with condition
S  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S           or the new value increases the BASEPRI priority level.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
S{
S  register uint32_t __regBasePriMax      __ASM("basepri_max");
S  __regBasePriMax = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Get Fault Mask
S  \details Returns the current value of the Fault Mask register.
S  \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/**
S  \brief   Set Fault Mask
S  \details Assigns the given value to the Fault Mask register.
S  \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N
N#if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
X#if       ((0x00U) == 0x04U) || ((0x00U) == 0x07U)
S
S/**
S  \brief   Get FPSCR
S  \details Returns the current value of the Floating Point Status/Control register.
S  \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0U);
S#endif
S}
S
S
S/**
S  \brief   Set FPSCR
S  \details Assigns the given value to the Floating Point Status/Control register.
S  \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    value  Value to rotate
N  \param [in]    value  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x00U) >= 0x03U) || (__CORTEX_SC >= 300U)
S  #define __RBIT                          __rbit
N#else
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
X__attribute__((always_inline)) static __inline uint32_t __RBIT(uint32_t value)
N{
N  uint32_t result;
N  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; /* extra shift needed at end */
N
N  result = value;                      /* r will be reversed bits of v; first get LSB of v */
N  for (value >>= 1U; value; value >>= 1U)
N  {
N    result <<= 1U;
N    result |= value & 1U;
N    s--;
N  }
N  result <<= s;                        /* shift when v's highest bits are zero */
N  return(result);
N}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
X#if       ((0x00U) >= 0x03U) || (__CORTEX_SC >= 300U)
S
S/**
S  \brief   LDR Exclusive (8 bit)
S  \details Executes a exclusive LDR instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
S#else
S  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (16 bit)
S  \details Executes a exclusive LDR instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
S#else
S  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (32 bit)
S  \details Executes a exclusive LDR instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
S#else
S  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (8 bit)
S  \details Executes a exclusive STR instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (16 bit)
S  \details Executes a exclusive STR instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (32 bit)
S  \details Executes a exclusive STR instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   Remove the exclusive lock
S  \details Removes the exclusive lock which is created by LDREX.
S */
S#define __CLREX                           __clrex
S
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/**
S  \brief   Rotate Right with Extend (32 bit)
S  \details Moves each bit of a bitstring right by one bit.
S           The carry input is shifted in at the left end of the bitstring.
S  \param [in]    value  Value to rotate
S  \return               Rotated value
S */
S#ifndef __NO_EMBEDDED_ASM
S__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
S{
S  rrx r0, r0
S  bx lr
S}
S#endif
S
S
S/**
S  \brief   LDRT Unprivileged (8 bit)
S  \details Executes a Unprivileged LDRT instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (16 bit)
S  \details Executes a Unprivileged LDRT instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (32 bit)
S  \details Executes a Unprivileged LDRT instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
S
S
S/**
S  \brief   STRT Unprivileged (8 bit)
S  \details Executes a Unprivileged STRT instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRBT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (16 bit)
S  \details Executes a Unprivileged STRT instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRHT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (32 bit)
S  \details Executes a Unprivileged STRT instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRT(value, ptr)                __strt(value, ptr)
S
N#endif /* (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U) */
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if (__CORTEX_M >= 0x04U)  /* only for Cortex-M4 and above */
X#if ((0x00U) >= 0x04U)   
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* (__CORTEX_M >= 0x04) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 54 "..\Library\CMSIS\Include\core_cmInstr.h" 2
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 164 "..\Library\CMSIS\Include\core_cm0.h" 2
N#include "core_cmFunc.h"                 /* Core Function Access */
L 1 "..\Library\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.30
N * @date     20. October 2015
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060422 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N*/
N
N/*------------------ RealView Compiler -----------------*/
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
N
N/*------------------ ARM Compiler V6 -------------------*/
N#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armcc_V6.h"
S
S/*------------------ GNU Compiler ----------------------*/
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S/*------------------ ICC Compiler ----------------------*/
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iar.h>
S
S/*------------------ TI CCS Compiler -------------------*/
S#elif defined ( __TMS470__ )
S  #include <cmsis_ccs.h>
S
S/*------------------ TASKING Compiler ------------------*/
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S/*------------------ COSMIC Compiler -------------------*/
S#elif defined ( __CSMC__ )
S  #include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 165 "..\Library\CMSIS\Include\core_cm0.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000U
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[1U];                
N        uint32_t RESERVED0[31U];
N  __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[1U];                
N        uint32_t RSERVED1[31U];
N  __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[1U];                
N        uint32_t RESERVED2[31U];
N  __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[1U];                
N        uint32_t RESERVED3[31U];
N        uint32_t RESERVED4[64U];
N  __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
X  volatile uint32_t IP[8U];                  
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N        uint32_t RESERVED0;
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N        uint32_t RESERVED1;
N  __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
X  volatile uint32_t SHP[2U];                 
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
N            Therefore they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
N#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
N#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
N
N
N/**
N  \brief   Enable External Interrupt
N  \details Enables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Disable External Interrupt
N  \details Disables a device-specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the pending register in the NVIC and returns the pending bit for the specified interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of an external interrupt.
N  \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of an external interrupt.
N  \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of an interrupt.
N  \note    The priority cannot be set for every core interrupt.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) < 0)
N  {
N    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] = ((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N  else
N  {
N    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  = ((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of an interrupt.
N           The interrupt number can be positive to specify an external (device specific) interrupt,
N           or negative to specify an internal (core) interrupt.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) < 0)
N  {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N  else
N  {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FAUL << 16U) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2U));
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0U)
X#if (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1UL << 2) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 134 "..\Library\Device\Nuvoton\Mini58Series\Include\Mini58Series.h" 2
N#include "system_Mini58Series.h"            /* Mini58 Series System include file                  */
L 1 "..\Library\Device\Nuvoton\Mini58Series\Include\system_Mini58Series.h" 1
N/**************************************************************************//**
N * @file     system_Mini58Series.h
N * @version  V1.00
N * $Revision: 5 $
N * $Date: 15/05/26 10:19a $
N * @brief    Mini58 series system clock definition file
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N
N
N#ifndef __SYSTEM_MINI58SERIES_H__
N#define __SYSTEM_MINI58SERIES_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro Definition                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/*----------------------------------------------------------------------------
N  Define SYSCLK
N *----------------------------------------------------------------------------*/
N#define __XTAL12M        (12000000UL)
N#define __XTAL32K        (32768UL)
N#define __IRC10K         (10000UL)
N#define __XTAL            __XTAL12M
N#define __HXT             __XTAL
N#define __HIRC           (22118400UL)    /* Clock output of Internal high speed RC 22.1184M */
N
Nextern uint32_t __HSI;
Nextern uint32_t SystemCoreClock;        /*!< System Clock Frequency (Core Clock) */
Nextern uint32_t CyclesPerUs;            /*!< Cycles per micro second */
Nextern uint32_t PllClock;               /*!< PLL Output Clock Frequency          */
N/**
N * Update SystemCoreClock variable
N *
N * @param  None
N * @return None
N *
N * @brief  Updates the SystemCoreClock with current core Clock
N *         retrieved from CPU registers.
N */
N
Nextern void SystemCoreClockUpdate (void);
Nextern void SystemInit (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  //__SYSTEM_MINI58SERIES_H__
N
N
N/*** (C) COPYRIGHT 2015 Nuvoton Technology Corp. ***/
L 135 "..\Library\Device\Nuvoton\Mini58Series\Include\Mini58Series.h" 2
N#include <stdint.h>
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N/** @addtogroup Mini58_Peripherals Mini58 Peripherals
N  Mini58 Device Specific Peripheral registers structures
N  @{
N*/
N
N#if defined ( __CC_ARM  )
X#if 1L
N#pragma anon_unions
N#endif
N
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N
N
N/*---------------------- Analog Comparator Controller -------------------------*/
N/**
N    @addtogroup ACMP Analog Comparator Controller(ACMP)
N    Memory Mapped Structure for ACMP Controller
N@{ */
N
Ntypedef struct {
N
N
N    /**
N     * CTL0, 1
N     * ===================================================================================================
N     * Offset: 0x00, 0x04  Analog Comparator 0, 1 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ACMPEN    |Analog Comparator x Enable Bit
N     * |        |          |0 = Analog Comparator x Disabled.
N     * |        |          |1 = Analog Comparator x Enabled.
N     * |        |          |Note: Analog comparator output needs to wait 2 us stable time after this bit is set.
N     * |[1]     |ACMPIE    |Analog Comparator x Interrupt Enable Bit
N     * |        |          |0 = Interrupt function Disabled.
N     * |        |          |1 = Interrupt function Enabled.
N     * |[2]     |HYSSEL    |Analog Comparator x Hysteresis Select Bit
N     * |        |          |0 = Hysteresis function Disabled.
N     * |        |          |1 = Hysteresis function Enabled.
N     * |[4]     |NEGSEL    |Analog Comparator x Negative Input Select Bit
N     * |        |          |0 = The source of the negative comparator input is from CPNx pin.
N     * |        |          |1 = The source of the negative comparator input is from internal band-gap voltage or comparator reference voltage.
N     * |[8]     |RTRGEN    |Analog Comparator x Rising Edge Trigger Enable Bit
N     * |        |          |0 = Analog comparator rising edge trigger PWM or Timer enabled.
N     * |        |          |1 = Analog comparator rising edge trigger disabled.
N     * |        |          |Note: The bit is only effective while analog comparator x triggers PWM or Timer.
N     * |[9]     |FTRGEN    |Analog Comparator x Falling Edge Trigger Enable
N     * |        |          |0 = Analog comparator falling edge trigger PWM or Timer enabled.
N     * |        |          |1 = Analog comparator falling edge trigger disabled.
N     * |        |          |Note: The bit is only effective while analog comparator x triggers PWM or Timer.
N     * |[23:20] |FILTSEL   |Comparator Output Filter Count Selection
N     * |        |          |0000 = Filter function is Disabled.
N     * |        |          |0001 = ACMP0 output is sampled 1 consecutive PCLK.
N     * |        |          |0010 = ACMP0 output is sampled 2 consecutive PCLKs.
N     * |        |          |0011 = ACMP0 output is sampled 4 consecutive PCLKs.
N     * |        |          |0100 = ACMP0 output is sampled 8 consecutive PCLKs.
N     * |        |          |0101 = ACMP0 output is sampled 16 consecutive PCLKs.
N     * |        |          |0110 = ACMP0 output is sampled 32 consecutive PCLKs.
N     * |        |          |0111 = ACMP0 output is sampled 64 consecutive PCLKs.
N     * |        |          |1000 = ACMP0 output is sampled 128 consecutive PCLKs.
N     * |        |          |1001 = ACMP0 output is sampled 256 consecutive PCLKs.
N     * |        |          |1010 = ACMP0 output is sampled 512 consecutive PCLKs.
N     * |        |          |Others = Reserved.
N     * |[30:29] |POSSEL    |Analog Comparator Positive Input Selection
N     * |        |          |00 = ACMP0_Px is from ACMPx_P0 pin.
N     * |        |          |01 = ACMP0_Px is from ACMPx_P1 pin.
N     * |        |          |10 = ACMP0_Px is from ACMPx_P2 pin.
N     * |        |          |11 = ACMP0_Px is from ACMPx_P3 pin.
N    */
N    __IO uint32_t CTL[2];
X    volatile uint32_t CTL[2];
N
N    /**
N     * STATUS
N     * ===================================================================================================
N     * Offset: 0x08  Analog Comparator 0/1 Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ACMPIF0   |Analog Comparator 0 Flag
N     * |        |          |This bit is set by hardware whenever the comparator 0 output changes state.
N     * |        |          |This will generate an interrupt if ACMPIE (ACMP_CTL0[1]) = 1.
N     * |        |          |0 = Analog comparator 0 output does not change.
N     * |        |          |1 = Analog comparator 0 output changed.
N     * |        |          |Note: This bit can be cleared to 0 by software writing 1.
N     * |[1]     |ACMPIF1   |Analog Comparator 1 Flag
N     * |        |          |This bit is set by hardware whenever the comparator 1 output changes state.
N     * |        |          |This will generate an interrupt if ACMPIE (ACMP_CTL1[1]) = 1.
N     * |        |          |0 = Analog comparator 1 output does not change.
N     * |        |          |1 = Analog comparator 1 output changed.
N     * |        |          |Note: This bit can be cleared to 0 by software writing 1.
N     * |[2]     |ACMPO0    |Analog Comparator 0 Output
N     * |        |          |Synchronized to the APB clock to allow reading by software.
N     * |        |          |Cleared when the comparator 0 is disabled ACMPEN (ACMP_CTL0[0]) = 0.
N     * |        |          |0 = Analog comparator 0 outputs 0.
N     * |        |          |1 = Analog comparator 0 outputs 1.
N     * |[3]     |ACMPO1    |Analog Comparator 1 Output
N     * |        |          |Synchronized to the APB clock to allow reading by software.
N     * |        |          |Cleared when the comparator 1 is disabled ACMPEN (ACMP_CTL1[0]) = 0.
N     * |        |          |0 = Analog comparator 1 outputs 0.
N     * |        |          |1 = Analog comparator 1 outputs 1.
N    */
N    __IO uint32_t STATUS;
X    volatile uint32_t STATUS;
N
N    /**
N     * VREF
N     * ===================================================================================================
N     * Offset: 0x0C  Analog Comparator Reference Voltage Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |CRVCTL    |Comparator Reference Voltage Control
N     * |        |          |Comparator reference voltage = AVDD * (1 / 6 + CRVCTL(ACMP_VREF[3:0]) / 24).
N     * |[7]     |IREFSEL   |CRV Internal Reference Selection
N     * |        |          |0 = Band-gap voltage.
N     * |        |          |1 = Internal comparator reference voltage.
N    */
N    __IO uint32_t VREF;
X    volatile uint32_t VREF;
N
N} ACMP_T;
N
N/**
N    @addtogroup ACMP_CONST ACMP Bit Field Definition
N    Constant Definitions for ACMP Controller
N@{ */
N
N#define ACMP_CTL_ACMPEN_Pos             (0)                                                /*!< ACMP_T::CTL: ACMPEN Position              */
N#define ACMP_CTL_ACMPEN_Msk             (0x1ul << ACMP_CTL_ACMPEN_Pos)                     /*!< ACMP_T::CTL: ACMPEN Mask                  */
N
N#define ACMP_CTL_ACMPIE_Pos             (1)                                                /*!< ACMP_T::CTL: ACMPIE Position              */
N#define ACMP_CTL_ACMPIE_Msk             (0x1ul << ACMP_CTL_ACMPIE_Pos)                     /*!< ACMP_T::CTL: ACMPIE Mask                  */
N
N#define ACMP_CTL_HYSSEL_Pos             (2)                                                /*!< ACMP_T::CTL: HYSSEL Position              */
N#define ACMP_CTL_HYSSEL_Msk             (0x1ul << ACMP_CTL_HYSSEL_Pos)                     /*!< ACMP_T::CTL: HYSSEL Mask                  */
N
N#define ACMP_CTL_NEGSEL_Pos             (4)                                                /*!< ACMP_T::CTL: NEGSEL Position              */
N#define ACMP_CTL_NEGSEL_Msk             (0x1ul << ACMP_CTL_NEGSEL_Pos)                     /*!< ACMP_T::CTL: NEGSEL Mask                  */
N
N#define ACMP_CTL_RTRGEN_Pos             (8)                                                /*!< ACMP_T::CTL: RTRGEN Position              */
N#define ACMP_CTL_RTRGEN_Msk             (0x1ul << ACMP_CTL_RTRGEN_Pos)                     /*!< ACMP_T::CTL: RTRGEN Mask                  */
N
N#define ACMP_CTL_FTRGEN_Pos             (9)                                                /*!< ACMP_T::CTL: FTRGEN Position              */
N#define ACMP_CTL_FTRGEN_Msk             (0x1ul << ACMP_CTL_FTRGEN_Pos)                     /*!< ACMP_T::CTL: FTRGEN Mask                  */
N
N#define ACMP_CTL_FILTSEL_Pos            (20)                                               /*!< ACMP_T::CTL: FILTSEL Position             */
N#define ACMP_CTL_FILTSEL_Msk            (0xful << ACMP_CTL_FILTSEL_Pos)                    /*!< ACMP_T::CTL: FILTSEL Mask                 */
N
N#define ACMP_CTL_POSSEL_Pos             (29)                                               /*!< ACMP_T::CTL: POSSEL Position              */
N#define ACMP_CTL_POSSEL_Msk             (0x3ul << ACMP_CTL_POSSEL_Pos)                     /*!< ACMP_T::CTL: POSSEL Mask                  */
N
N#define ACMP_STATUS_ACMPIF0_Pos          (0)                                               /*!< ACMP_T::STATUS: ACMPIF0 Position          */
N#define ACMP_STATUS_ACMPIF0_Msk          (0x1ul << ACMP_STATUS_ACMPIF0_Pos)                /*!< ACMP_T::STATUS: ACMPIF0 Mask              */
N
N#define ACMP_STATUS_ACMPIF1_Pos          (1)                                               /*!< ACMP_T::STATUS: ACMPIF1 Position          */
N#define ACMP_STATUS_ACMPIF1_Msk          (0x1ul << ACMP_STATUS_ACMPIF1_Pos)                /*!< ACMP_T::STATUS: ACMPIF1 Mask              */
N
N#define ACMP_STATUS_ACMPO0_Pos           (2)                                               /*!< ACMP_T::STATUS: ACMPO0 Position           */
N#define ACMP_STATUS_ACMPO0_Msk           (0x1ul << ACMP_STATUS_ACMPO0_Pos)                 /*!< ACMP_T::STATUS: ACMPO0 Mask               */
N
N#define ACMP_STATUS_ACMPO1_Pos           (3)                                               /*!< ACMP_T::STATUS: ACMPO1 Position           */
N#define ACMP_STATUS_ACMPO1_Msk           (0x1ul << ACMP_STATUS_ACMPO1_Pos)                 /*!< ACMP_T::STATUS: ACMPO1 Mask               */
N
N#define ACMP_VREF_CRVCTL_Pos             (0)                                               /*!< ACMP_T::VREF: CRVCTL Position             */
N#define ACMP_VREF_CRVCTL_Msk             (0xful << ACMP_VREF_CRVCTL_Pos)                   /*!< ACMP_T::VREF: CRVCTL Mask                 */
N
N#define ACMP_VREF_IREFSEL_Pos            (7)                                               /*!< ACMP_T::VREF: IREFSEL Position            */
N#define ACMP_VREF_IREFSEL_Msk            (0x1ul << ACMP_VREF_IREFSEL_Pos)                  /*!< ACMP_T::VREF: IREFSEL Mask                */
N
N/**@}*/ /* ACMP_CONST */
N/**@}*/ /* end of ACMP register group */
N
N
N/*---------------------- Analog to Digital Converter -------------------------*/
N/**
N    @addtogroup ADC Analog to Digital Converter(ADC)
N    Memory Mapped Structure for ADC Controller
N@{ */
N
Ntypedef struct {
N
N
N    /**
N     * DAT
N     * ===================================================================================================
N     * Offset: 0x00  A/D Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[9:0]   |RESULT    |A/D Conversion Result
N     * |        |          |This field contains conversion result of ADC.
N     * |[16]    |OV        |Over Run Flag
N     * |        |          |If converted data in RESULT[9:0] has not been read before the new conversion result is loaded to this register, OV is set to 1.
N     * |        |          |It is cleared by hardware after the ADC_DAT register is rea.
N     * |        |          |0 = Data in RESULT[9:0] is recent conversion result.
N     * |        |          |1 = Data in RESULT[9:0] overwrote.
N     * |[17]    |VALID     |Valid Flag
N     * |        |          |This bit is set to 1 when ADC conversion is completed and cleared by hardware after the ADC_DAT register is read.
N     * |        |          |0 = Data in RESULT[9:0] bits not valid.
N     * |        |          |1 = Data in RESULT[9:0] bits valid.
N    */
N    __I  uint32_t DAT;
X    volatile const  uint32_t DAT;
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVED0[7];
X    volatile const  uint32_t RESERVED0[7];
N    /// @endcond //HIDDEN_SYMBOLS
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x20  A/D Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ADCEN     |A/D Converter Enable Bit
N     * |        |          |0 = A/D Converter Disabled.
N     * |        |          |1 = A/D Converter Enabled.
N     * |        |          |Note: Before starting A/D conversion function, this bit should be set to 1.
N     * |        |          |Clear it to 0 to disable A/D converter analog circuit to save power consumption.
N     * |[1]     |ADCIEN    |A/D Interrupt Enable Bit
N     * |        |          |A/D conversion end interrupt request is generated if ADCIEN bit is set to 1.
N     * |        |          |0 = A/D interrupt function Disabled.
N     * |        |          |1 = A/D interrupt function Enabled.
N     * |[5:4]   |HWTRGSEL  |Hardware Trigger Source Select Bit
N     * |        |          |00 = A/D conversion is started by external STADC pin.
N     * |        |          |11 = A/D conversion is started by PWM trigger.
N     * |        |          |Others = Reserved.
N     * |        |          |Note: Software should disable TRGEN and SWTRG before change TRGS.
N     * |[6]     |HWTRGCOND |Hardware External Trigger Condition
N     * |        |          |This bit decides whether the external pin STADC trigger event is falling or raising edge.
N     * |        |          |The signal must be kept at stable state at least 4 PCLKs at high and low state for edge trigge.
N     * |        |          |0 = Falling edge.
N     * |        |          |1 = Raising edge.
N     * |[8]     |HWTRGEN   |Hardware External Trigger Enable Bit
N     * |        |          |Enable or disable triggering of A/D conversion by external STADC pin.
N     * |        |          |If external trigger is enabled, the SWTRG bit can be set to 1 by the selected hardware trigger sourc.
N     * |        |          |0= External trigger Disabled.
N     * |        |          |1= External trigger Enabled.
N     * |[11]    |SWTRG     |Software Trigger A/D Conversion Start
N     * |        |          |SWTRG bit can be set to 1 from two sources: software and external pin STADC.
N     * |        |          |SWTRG will be cleared to 0 by hardware automatically after conversion complet.
N     * |        |          |0 = Conversion stopped and A/D converter entered idle state.
N     * |        |          |1 = Conversion start.
N    */
N    __IO uint32_t CTL;
X    volatile uint32_t CTL;
N
N    /**
N     * CHEN
N     * ===================================================================================================
N     * Offset: 0x24  A/D Channel Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CHEN0     |Analog Input Channel 0 Enable Bit
N     * |        |          |0 = Channel 0 Disabled.
N     * |        |          |1 = Channel 0 Enabled.
N     * |        |          |Note: If software enables more than one channel, the channel with the smallest number will be selected and the other enabled channels will be ignored.
N     * |[1]     |CHEN1     |Analog Input Channel 1 Enable Bit
N     * |        |          |0 = Channel 1 Disabled.
N     * |        |          |1 = Channel 1 Enabled.
N     * |[2]     |CHEN2     |Analog Input Channel 2 Enable Bit
N     * |        |          |0 = Channel 2 Disabled.
N     * |        |          |1 = Channel 2 Enabled.
N     * |[3]     |CHEN3     |Analog Input Channel 3 Enable Bit
N     * |        |          |0 = Channel 3 Disabled.
N     * |        |          |1 = Channel 3 Enabled.
N     * |[4]     |CHEN4     |Analog Input Channel 4 Enable Bit
N     * |        |          |0 = Channel 4 Disabled.
N     * |        |          |1 = Channel 4 Enabled.
N     * |[5]     |CHEN5     |Analog Input Channel 5 Enable Bit
N     * |        |          |0 = Channel 5 Disabled.
N     * |        |          |1 = Channel 5 Enabled.
N     * |[6]     |CHEN6     |Analog Input Channel 6 Enable Bit
N     * |        |          |0 = Channel 6 Disabled.
N     * |        |          |1 = Channel 6 Enabled.
N     * |[7]     |CHEN7     |Analog Input Channel 7 Enable Bit
N     * |        |          |0 = Channel 7 Disabled.
N     * |        |          |1 = Channel 7 Enabled.
N     * |[8]     |CH7SEL    |Analog Input Channel 7 Selection
N     * |        |          |0 = External analog input.
N     * |        |          |1 = Internal band-gap voltage (VBG).
N     * |        |          |Note: When software selects the band-gap voltage as the analog input source of ADC channel 7, the ADC clock rate needs to be limited to lower than 300 kHz.
N    */
N    __IO uint32_t CHEN;
X    volatile uint32_t CHEN;
N
N    /**
N     * CMP0
N     * ===================================================================================================
N     * Offset: 0x28  A/D Compare Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ADCMPEN   |A/D Compare Enable Bit
N     * |        |          |Set 1 to this bit to enable comparing CMPDAT (ADC_CMPx[25:16]) with specified channel conversion results when converted data is loaded into the ADC_DAT register.
N     * |        |          |0 = Compare function Disabled.
N     * |        |          |1 = Compare function Enabled.
N     * |[1]     |ADCMPIE   |A/D Compare Interrupt Enable Bit
N     * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMCNT, ADCMPIE bit will be asserted, in the meanwhile, if ADCMPIE is set to 1, a compare interrupt request is generated.
N     * |        |          |0 = Compare function interrupt Disabled.
N     * |        |          |1 = Compare function interrupt Enabled.
N     * |[2]     |CMPCOND   |Compare Condition
N     * |        |          |0 = Set the compare condition as that when a 10-bit A/D conversion result is less than the 10-bit CMPDAT (ADC_CMPx[25:16]), the internal match counter will increase one.
N     * |        |          |1 = Set the compare condition as that when a 10-bit A/D conversion result is greater or equal to the 10-bit CMPDAT (ADC_CMPx[25:16]), the internal match counter will increase one.
N     * |        |          |Note: When the internal counter reaches the value to (CMPMCNT+1), the ADCMPFx bit will be set.
N     * |[5:3]   |CMPCH     |Compare Channel Selection
N     * |        |          |Set this field to select which channel's result to be compared.
N     * |        |          |Note: Valid setting of this field is channel 0~7.
N     * |[11:8]  |CMPMCNT   |Compare Match Count
N     * |        |          |When the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND[2], the internal match counter will increase 1.
N     * |        |          |When the internal counter reaches the value to (CMPMCNT+1), the ADCMPFx bit will be set.
N     * |[25:16] |CMPDAT    |Comparison Data
N     * |        |          |The 10-bit data is used to compare with conversion result of specified channel.
N    */
N    __IO uint32_t CMP0;
X    volatile uint32_t CMP0;
N
N    /**
N     * CMP1
N     * ===================================================================================================
N     * Offset: 0x2C  A/D Compare Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ADCMPEN   |A/D Compare Enable Bit
N     * |        |          |Set 1 to this bit to enable comparing CMPDAT (ADC_CMPx[25:16]) with specified channel conversion results when converted data is loaded into the ADC_DAT register.
N     * |        |          |0 = Compare function Disabled.
N     * |        |          |1 = Compare function Enabled.
N     * |[1]     |ADCMPIE   |A/D Compare Interrupt Enable Bit
N     * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMCNT, ADCMPIE bit will be asserted, in the meanwhile, if ADCMPIE is set to 1, a compare interrupt request is generated.
N     * |        |          |0 = Compare function interrupt Disabled.
N     * |        |          |1 = Compare function interrupt Enabled.
N     * |[2]     |CMPCOND   |Compare Condition
N     * |        |          |0 = Set the compare condition as that when a 10-bit A/D conversion result is less than the 10-bit CMPDAT (ADC_CMPx[25:16]), the internal match counter will increase one.
N     * |        |          |1 = Set the compare condition as that when a 10-bit A/D conversion result is greater or equal to the 10-bit CMPDAT (ADC_CMPx[25:16]), the internal match counter will increase one.
N     * |        |          |Note: When the internal counter reaches the value to (CMPMCNT+1), the ADCMPFx bit will be set.
N     * |[5:3]   |CMPCH     |Compare Channel Selection
N     * |        |          |Set this field to select which channel's result to be compared.
N     * |        |          |Note: Valid setting of this field is channel 0~7.
N     * |[11:8]  |CMPMCNT   |Compare Match Count
N     * |        |          |When the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND[2], the internal match counter will increase 1.
N     * |        |          |When the internal counter reaches the value to (CMPMCNT+1), the ADCMPFx bit will be set.
N     * |[25:16] |CMPDAT    |Comparison Data
N     * |        |          |The 10-bit data is used to compare with conversion result of specified channel.
N    */
N    __IO uint32_t CMP1;
X    volatile uint32_t CMP1;
N
N    /**
N     * STATUS
N     * ===================================================================================================
N     * Offset: 0x30  A/D Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ADIF      |A/D Conversion End Flag
N     * |        |          |A status flag that indicates the end of A/D conversion. ADIF is set to 1 When A/D conversion ends.
N     * |        |          |Note: This bit can be cleared to 0 by software writing 1.
N     * |[1]     |ADCMPF0   |A/D Compare Flag 0
N     * |        |          |When the selected channel A/D conversion result meets the setting condition in ADC_CMP0, this bit is set to 1.
N     * |        |          |0 = Conversion result in ADC_DAT does not meet the ADC_CMP0 setting.
N     * |        |          |1 = Conversion result in ADC_DAT meets the ADC_CMP0 setting.
N     * |        |          |Note: This bit can be cleared to 0 by software writing 1.
N     * |[2]     |ADCMPF1   |A/D Compare Flag 1
N     * |        |          |When the selected channel A/D conversion result meets the setting condition in ADC_CMP1, this bit is set to 1.
N     * |        |          |0 = Conversion result in ADC_DAT does not meet the ADC_CMP1 setting.
N     * |        |          |1 = Conversion result in ADC_DAT meets the ADC_CMP1 setting.
N     * |        |          |Note: This bit can be cleared to 0 by software writing 1.
N     * |[3]     |BUSY      |BUSY/IDLE (Read Only)
N     * |        |          |This bit is mirror of as SWTRG bit in ADC_CTL
N     * |        |          |0 = A/D converter is in idle state.
N     * |        |          |1 = A/D converter is busy at conversion.
N     * |[6:4]   |CHANNEL   |Current Conversion Channel (Read Only)
N     * |        |          |This filed reflects the current conversion channel when BUSY=1.
N     * |        |          |When BUSY=0, it shows the number of the next converted channel.
N     * |[8]     |VALID     |Data Valid Flag (Read Only)
N     * |        |          |It is a mirror of VALID bit in ADC_DAT register.
N     * |[16]    |OV        |Overrun Flag (Read Only)
N     * |        |          |It is a mirror to OV bit in ADC_DAT register.
N    */
N    __IO uint32_t STATUS;
X    volatile uint32_t STATUS;
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVED1[4];
X    volatile const  uint32_t RESERVED1[4];
N    /// @endcond //HIDDEN_SYMBOLS
N
N
N    /**
N     * TRGDLY
N     * ===================================================================================================
N     * Offset: 0x44  A/D Trigger Delay Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |DELAY     |PWM Trigger Delay Timer
N     * |        |          |Set this field will delay ADC start conversion time after PWM trigger.
N     * |        |          |PWM trigger delay time is (4 * DELAY) * system clock.
N    */
N    __IO uint32_t TRGDLY;
X    volatile uint32_t TRGDLY;
N
N    /**
N     * EXTSMPT
N     * ===================================================================================================
N     * Offset: 0x48  A/D Sampling Time Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |EXTSMPT   |Additional ADC Sample Clock
N     * |        |          |If the ADC input is unstable, user can set this register to increase the sampling time to get a stable ADC input signal.
N     * |        |          |The default sampling time is 1 ADC clocks.
N     * |        |          |The additional clock number will be inserted to lengthen the sampling clock.
N     * |        |          |0 = Number of additional clock cycles is 0.
N     * |        |          |1 = Number of additional clock cycles is 1.
N     * |        |          |2 = Number of additional clock cycles is 2.
N     * |        |          |3 = Number of additional clock cycles is 4.
N     * |        |          |4 = Number of additional clock cycles is 8.
N     * |        |          |5 = Number of additional clock cycles is 16.
N     * |        |          |6 = Number of additional clock cycles is 32.
N     * |        |          |7 = Number of additional clock cycles is 64.
N     * |        |          |8 = Number of additional clock cycles is 128.
N     * |        |          |9 = Number of additional clock cycles is 256.
N     * |        |          |10 = Number of additional clock cycles is 512.
N     * |        |          |11 = Number of additional clock cycles is 1024.
N     * |        |          |12 = Number of additional clock cycles is 1024.
N     * |        |          |13 = Number of additional clock cycles is 1024.
N     * |        |          |14 = Number of additional clock cycles is 1024.
N     * |        |          |15 = Number of additional clock cycles is 1024.
N    */
N    __IO uint32_t EXTSMPT;
X    volatile uint32_t EXTSMPT;
N
N    /**
N     * SEQCTL
N     * ===================================================================================================
N     * Offset: 0x4C  A/D PWM Sequential Mode Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SEQEN     |ADC Sequential Mode Enable Bit
N     * |        |          |When ADC sequential mode is enabled, two of three ADC channels from 0 to 2 will automatically convert analog data in the sequence of channel [0, 1] or channel[1, 2] or channel[0, 2] defined by MODESEL (ADC_SEQCTL[3:2]).
N     * |        |          |0 = ADC sequential mode Disabled.
N     * |        |          |1 = ADC sequential mode Enabled.
N     * |[1]     |SEQTYPE   |ADC Sequential Mode Type
N     * |        |          |0 = ADC delay time is only inserted before the first conversion.
N     * |        |          |The second conversion starts immediately after the first conversion is completed.
N     * |        |          |(for 2/3-shunt type).
N     * |        |          |1 = ADC delay time is inserted before each conversion. (for 1-shunt type)
N     * |[3:2]   |MODESEL   |ADC Sequential Mode Selection
N     * |        |          |00 = Issue ADC_INT after Channel 0 then Channel 1 conversion finishes when SEQEN =1.
N     * |        |          |01 = Issue ADC_INT after Channel 1 then Channel 2 conversion finishes when SEQEN =1.
N     * |        |          |10 = Issue ADC_INT after Channel 0 then Channel 2 conversion finishes when SEQEN =1.
N     * |        |          |11 = Reserved.
N     * |[11:8]  |TRG1CTL   |PWM Trigger Source Selection For TRG1CTL[3:2]
N     * |        |          |00 = PWM Trigger source is PWM0.
N     * |        |          |01 = PWM Trigger source is PWM2.
N     * |        |          |10 = PWM Trigger source is PWM4.
N     * |        |          |11 = PWM Trigger source is reserved.
N     * |        |          |PWM Trigger Type Selection for TRG1CTL[1:0]
N     * |        |          |00 = Rising of the selected PWM.
N     * |        |          |01 = Center of the selected PWM.
N     * |        |          |10 = Falling of the selected PWM.
N     * |        |          |11 = Period of the selected PWM.
N     * |        |          |Note: PWM trigger source is valid for 1-shunt and 2/3-shunt type.
N     * |[19:16] |TRG2CTL   |PWM Trigger Source Selection For TRG2CTL[3:2]
N     * |        |          |00 = PWM Trigger source is PWM0.
N     * |        |          |01 = PWM Trigger source is PWM2.
N     * |        |          |10 = PWM Trigger source is PWM4.
N     * |        |          |11 = PWM Trigger source is reserved.
N     * |        |          |PWM Trigger Type Selection for TRG2CTL[1:0]
N     * |        |          |00 = Rising of the selected PWM.
N     * |        |          |01 = Center of the selected PWM.
N     * |        |          |10 = Falling of the selected PWM.
N     * |        |          |11 = Period of the selected PWM.
N     * |        |          |Note: PWM trigger source is valid for 1-shunt type.
N    */
N    __IO uint32_t SEQCTL;
X    volatile uint32_t SEQCTL;
N
N    /**
N     * SEQDAT1
N     * ===================================================================================================
N     * Offset: 0x50  A/D PWM Sequential Mode First Result Register1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[9:0]   |RESULT    |A/D PWM Sequential Mode Conversion Result
N     * |        |          |This field contains conversion result of ADC.
N     * |[16]    |OV        |Over Run Flag
N     * |        |          |If converted data in RESULT[9:0] has not been read before the new conversion result is loaded to this register, OV is set to 1.
N     * |        |          |It is cleared by hardware after the ADC_DAT register is read.
N     * |        |          |0 = Data in RESULT[9:0] is recent conversion result.
N     * |        |          |1 = Data in RESULT[9:0] overwritten.
N     * |[17]    |VALID     |Valid Flag
N     * |        |          |This bit is set to 1 when ADC conversion is completed and cleared by hardware after the ADC_DAT register is read.
N     * |        |          |0 = Data in RESULT[9:0] bits not valid.
N     * |        |          |1 = Data in RESULT[9:0] bits valid.
N    */
N    __I  uint32_t SEQDAT1;
X    volatile const  uint32_t SEQDAT1;
N
N    /**
N     * SEQDAT2
N     * ===================================================================================================
N     * Offset: 0x54  A/D PWM Sequential Mode Second Result Register1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[9:0]   |RESULT    |A/D PWM Sequential Mode Conversion Result
N     * |        |          |This field contains conversion result of ADC.
N     * |[16]    |OV        |Over Run Flag
N     * |        |          |If converted data in RESULT[9:0] has not been read before the new conversion result is loaded to this register, OV is set to 1.
N     * |        |          |It is cleared by hardware after the ADC_DAT register is read.
N     * |        |          |0 = Data in RESULT[9:0] is recent conversion result.
N     * |        |          |1 = Data in RESULT[9:0] overwritten.
N     * |[17]    |VALID     |Valid Flag
N     * |        |          |This bit is set to 1 when ADC conversion is completed and cleared by hardware after the ADC_DAT register is read.
N     * |        |          |0 = Data in RESULT[9:0] bits not valid.
N     * |        |          |1 = Data in RESULT[9:0] bits valid.
N    */
N    __I  uint32_t SEQDAT2;
X    volatile const  uint32_t SEQDAT2;
N
N} ADC_T;
N
N/**
N    @addtogroup ADC_CONST ADC Bit Field Definition
N    Constant Definitions for ADC Controller
N@{ */
N
N#define ADC_DAT_RESULT_Pos               (0)                                               /*!< ADC_T::DAT: RESULT Position               */
N#define ADC_DAT_RESULT_Msk               (0x3fful << ADC_DAT_RESULT_Pos)                   /*!< ADC_T::DAT: RESULT Mask                   */
N
N#define ADC_DAT_OV_Pos                   (16)                                              /*!< ADC_T::DAT: OV Position                   */
N#define ADC_DAT_OV_Msk                   (0x1ul << ADC_DAT_OV_Pos)                         /*!< ADC_T::DAT: OV Mask                       */
N
N#define ADC_DAT_VALID_Pos                (17)                                              /*!< ADC_T::DAT: VALID Position                */
N#define ADC_DAT_VALID_Msk                (0x1ul << ADC_DAT_VALID_Pos)                      /*!< ADC_T::DAT: VALID Mask                    */
N
N#define ADC_CTL_ADCEN_Pos                (0)                                               /*!< ADC_T::CTL: ADCEN Position                */
N#define ADC_CTL_ADCEN_Msk                (0x1ul << ADC_CTL_ADCEN_Pos)                      /*!< ADC_T::CTL: ADCEN Mask                    */
N
N#define ADC_CTL_ADCIEN_Pos               (1)                                               /*!< ADC_T::CTL: ADCIEN Position               */
N#define ADC_CTL_ADCIEN_Msk               (0x1ul << ADC_CTL_ADCIEN_Pos)                     /*!< ADC_T::CTL: ADCIEN Mask                   */
N
N#define ADC_CTL_HWTRGSEL_Pos             (4)                                               /*!< ADC_T::CTL: HWTRGSEL Position             */
N#define ADC_CTL_HWTRGSEL_Msk             (0x3ul << ADC_CTL_HWTRGSEL_Pos)                   /*!< ADC_T::CTL: HWTRGSEL Mask                 */
N
N#define ADC_CTL_HWTRGCOND_Pos            (6)                                               /*!< ADC_T::CTL: HWTRGCOND Position            */
N#define ADC_CTL_HWTRGCOND_Msk            (0x1ul << ADC_CTL_HWTRGCOND_Pos)                  /*!< ADC_T::CTL: HWTRGCOND Mask                */
N
N#define ADC_CTL_HWTRGEN_Pos              (8)                                               /*!< ADC_T::CTL: HWTRGEN Position              */
N#define ADC_CTL_HWTRGEN_Msk              (0x1ul << ADC_CTL_HWTRGEN_Pos)                    /*!< ADC_T::CTL: HWTRGEN Mask                  */
N
N#define ADC_CTL_SWTRG_Pos                (11)                                              /*!< ADC_T::CTL: SWTRG Position                */
N#define ADC_CTL_SWTRG_Msk                (0x1ul << ADC_CTL_SWTRG_Pos)                      /*!< ADC_T::CTL: SWTRG Mask                    */
N
N#define ADC_CHEN_CHEN0_Pos               (0)                                               /*!< ADC_T::CHEN: CHEN0 Position               */
N#define ADC_CHEN_CHEN0_Msk               (0x1ul << ADC_CHEN_CHEN0_Pos)                     /*!< ADC_T::CHEN: CHEN0 Mask                   */
N
N#define ADC_CHEN_CHEN1_Pos               (1)                                               /*!< ADC_T::CHEN: CHEN1 Position               */
N#define ADC_CHEN_CHEN1_Msk               (0x1ul << ADC_CHEN_CHEN1_Pos)                     /*!< ADC_T::CHEN: CHEN1 Mask                   */
N
N#define ADC_CHEN_CHEN2_Pos               (2)                                               /*!< ADC_T::CHEN: CHEN2 Position               */
N#define ADC_CHEN_CHEN2_Msk               (0x1ul << ADC_CHEN_CHEN2_Pos)                     /*!< ADC_T::CHEN: CHEN2 Mask                   */
N
N#define ADC_CHEN_CHEN3_Pos               (3)                                               /*!< ADC_T::CHEN: CHEN3 Position               */
N#define ADC_CHEN_CHEN3_Msk               (0x1ul << ADC_CHEN_CHEN3_Pos)                     /*!< ADC_T::CHEN: CHEN3 Mask                   */
N
N#define ADC_CHEN_CHEN4_Pos               (4)                                               /*!< ADC_T::CHEN: CHEN4 Position               */
N#define ADC_CHEN_CHEN4_Msk               (0x1ul << ADC_CHEN_CHEN4_Pos)                     /*!< ADC_T::CHEN: CHEN4 Mask                   */
N
N#define ADC_CHEN_CHEN5_Pos               (5)                                               /*!< ADC_T::CHEN: CHEN5 Position               */
N#define ADC_CHEN_CHEN5_Msk               (0x1ul << ADC_CHEN_CHEN5_Pos)                     /*!< ADC_T::CHEN: CHEN5 Mask                   */
N
N#define ADC_CHEN_CHEN6_Pos               (6)                                               /*!< ADC_T::CHEN: CHEN6 Position               */
N#define ADC_CHEN_CHEN6_Msk               (0x1ul << ADC_CHEN_CHEN6_Pos)                     /*!< ADC_T::CHEN: CHEN6 Mask                   */
N
N#define ADC_CHEN_CHEN7_Pos               (7)                                               /*!< ADC_T::CHEN: CHEN7 Position               */
N#define ADC_CHEN_CHEN7_Msk               (0x1ul << ADC_CHEN_CHEN7_Pos)                     /*!< ADC_T::CHEN: CHEN7 Mask                   */
N
N#define ADC_CHEN_CH7SEL_Pos              (8)                                               /*!< ADC_T::CHEN: CH7SEL Position              */
N#define ADC_CHEN_CH7SEL_Msk              (0x1ul << ADC_CHEN_CH7SEL_Pos)                    /*!< ADC_T::CHEN: CH7SEL Mask                  */
N
N#define ADC_CMP0_ADCMPEN_Pos             (0)                                               /*!< ADC_T::CMP0: ADCMPEN Position             */
N#define ADC_CMP0_ADCMPEN_Msk             (0x1ul << ADC_CMP0_ADCMPEN_Pos)                   /*!< ADC_T::CMP0: ADCMPEN Mask                 */
N
N#define ADC_CMP0_ADCMPIE_Pos             (1)                                               /*!< ADC_T::CMP0: ADCMPIE Position             */
N#define ADC_CMP0_ADCMPIE_Msk             (0x1ul << ADC_CMP0_ADCMPIE_Pos)                   /*!< ADC_T::CMP0: ADCMPIE Mask                 */
N
N#define ADC_CMP0_CMPCOND_Pos             (2)                                               /*!< ADC_T::CMP0: CMPCOND Position             */
N#define ADC_CMP0_CMPCOND_Msk             (0x1ul << ADC_CMP0_CMPCOND_Pos)                   /*!< ADC_T::CMP0: CMPCOND Mask                 */
N
N#define ADC_CMP0_CMPCH_Pos               (3)                                               /*!< ADC_T::CMP0: CMPCH Position               */
N#define ADC_CMP0_CMPCH_Msk               (0x7ul << ADC_CMP0_CMPCH_Pos)                     /*!< ADC_T::CMP0: CMPCH Mask                   */
N
N#define ADC_CMP0_CMPMCNT_Pos             (8)                                               /*!< ADC_T::CMP0: CMPMCNT Position             */
N#define ADC_CMP0_CMPMCNT_Msk             (0xful << ADC_CMP0_CMPMCNT_Pos)                   /*!< ADC_T::CMP0: CMPMCNT Mask                 */
N
N#define ADC_CMP0_CMPDAT_Pos              (16)                                              /*!< ADC_T::CMP0: CMPDAT Position              */
N#define ADC_CMP0_CMPDAT_Msk              (0x3fful << ADC_CMP0_CMPDAT_Pos)                  /*!< ADC_T::CMP0: CMPDAT Mask                  */
N
N#define ADC_CMP1_ADCMPEN_Pos             (0)                                               /*!< ADC_T::CMP1: ADCMPEN Position             */
N#define ADC_CMP1_ADCMPEN_Msk             (0x1ul << ADC_CMP1_ADCMPEN_Pos)                   /*!< ADC_T::CMP1: ADCMPEN Mask                 */
N
N#define ADC_CMP1_ADCMPIE_Pos             (1)                                               /*!< ADC_T::CMP1: ADCMPIE Position             */
N#define ADC_CMP1_ADCMPIE_Msk             (0x1ul << ADC_CMP1_ADCMPIE_Pos)                   /*!< ADC_T::CMP1: ADCMPIE Mask                 */
N
N#define ADC_CMP1_CMPCOND_Pos             (2)                                               /*!< ADC_T::CMP1: CMPCOND Position             */
N#define ADC_CMP1_CMPCOND_Msk             (0x1ul << ADC_CMP1_CMPCOND_Pos)                   /*!< ADC_T::CMP1: CMPCOND Mask                 */
N
N#define ADC_CMP1_CMPCH_Pos               (3)                                               /*!< ADC_T::CMP1: CMPCH Position               */
N#define ADC_CMP1_CMPCH_Msk               (0x7ul << ADC_CMP1_CMPCH_Pos)                     /*!< ADC_T::CMP1: CMPCH Mask                   */
N
N#define ADC_CMP1_CMPMCNT_Pos             (8)                                               /*!< ADC_T::CMP1: CMPMCNT Position             */
N#define ADC_CMP1_CMPMCNT_Msk             (0xful << ADC_CMP1_CMPMCNT_Pos)                   /*!< ADC_T::CMP1: CMPMCNT Mask                 */
N
N#define ADC_CMP1_CMPDAT_Pos              (16)                                              /*!< ADC_T::CMP1: CMPDAT Position              */
N#define ADC_CMP1_CMPDAT_Msk              (0x3fful << ADC_CMP1_CMPDAT_Pos)                  /*!< ADC_T::CMP1: CMPDAT Mask                  */
N
N#define ADC_STATUS_ADIF_Pos              (0)                                               /*!< ADC_T::STATUS: ADIF Position              */
N#define ADC_STATUS_ADIF_Msk              (0x1ul << ADC_STATUS_ADIF_Pos)                    /*!< ADC_T::STATUS: ADIF Mask                  */
N
N#define ADC_STATUS_ADCMPF0_Pos           (1)                                               /*!< ADC_T::STATUS: ADCMPF0 Position           */
N#define ADC_STATUS_ADCMPF0_Msk           (0x1ul << ADC_STATUS_ADCMPF0_Pos)                 /*!< ADC_T::STATUS: ADCMPF0 Mask               */
N
N#define ADC_STATUS_ADCMPF1_Pos           (2)                                               /*!< ADC_T::STATUS: ADCMPF1 Position           */
N#define ADC_STATUS_ADCMPF1_Msk           (0x1ul << ADC_STATUS_ADCMPF1_Pos)                 /*!< ADC_T::STATUS: ADCMPF1 Mask               */
N
N#define ADC_STATUS_BUSY_Pos              (3)                                               /*!< ADC_T::STATUS: BUSY Position              */
N#define ADC_STATUS_BUSY_Msk              (0x1ul << ADC_STATUS_BUSY_Pos)                    /*!< ADC_T::STATUS: BUSY Mask                  */
N
N#define ADC_STATUS_CHANNEL_Pos           (4)                                               /*!< ADC_T::STATUS: CHANNEL Position           */
N#define ADC_STATUS_CHANNEL_Msk           (0x7ul << ADC_STATUS_CHANNEL_Pos)                 /*!< ADC_T::STATUS: CHANNEL Mask               */
N
N#define ADC_STATUS_VALID_Pos             (8)                                               /*!< ADC_T::STATUS: VALID Position             */
N#define ADC_STATUS_VALID_Msk             (0x1ul << ADC_STATUS_VALID_Pos)                   /*!< ADC_T::STATUS: VALID Mask                 */
N
N#define ADC_STATUS_OV_Pos                (16)                                              /*!< ADC_T::STATUS: OV Position                */
N#define ADC_STATUS_OV_Msk                (0x1ul << ADC_STATUS_OV_Pos)                      /*!< ADC_T::STATUS: OV Mask                    */
N
N#define ADC_TRGDLY_DELAY_Pos             (0)                                               /*!< ADC_T::TRGDLY: DELAY Position             */
N#define ADC_TRGDLY_DELAY_Msk             (0xfful << ADC_TRGDLY_DELAY_Pos)                  /*!< ADC_T::TRGDLY: DELAY Mask                 */
N
N#define ADC_EXTSMPT_EXTSMPT_Pos          (0)                                               /*!< ADC_T::EXTSMPT: EXTSMPT Position          */
N#define ADC_EXTSMPT_EXTSMPT_Msk          (0xful << ADC_EXTSMPT_EXTSMPT_Pos)                /*!< ADC_T::EXTSMPT: EXTSMPT Mask              */
N
N#define ADC_SEQCTL_SEQEN_Pos             (0)                                               /*!< ADC_T::SEQCTL: SEQEN Position             */
N#define ADC_SEQCTL_SEQEN_Msk             (0x1ul << ADC_SEQCTL_SEQEN_Pos)                   /*!< ADC_T::SEQCTL: SEQEN Mask                 */
N
N#define ADC_SEQCTL_SEQTYPE_Pos           (1)                                               /*!< ADC_T::SEQCTL: SEQTYPE Position           */
N#define ADC_SEQCTL_SEQTYPE_Msk           (0x1ul << ADC_SEQCTL_SEQTYPE_Pos)                 /*!< ADC_T::SEQCTL: SEQTYPE Mask               */
N
N#define ADC_SEQCTL_MODESEL_Pos           (2)                                               /*!< ADC_T::SEQCTL: MODESEL Position           */
N#define ADC_SEQCTL_MODESEL_Msk           (0x3ul << ADC_SEQCTL_MODESEL_Pos)                 /*!< ADC_T::SEQCTL: MODESEL Mask               */
N
N#define ADC_SEQCTL_TRG1CTL_Pos           (8)                                               /*!< ADC_T::SEQCTL: TRG1CTL Position           */
N#define ADC_SEQCTL_TRG1CTL_Msk           (0xful << ADC_SEQCTL_TRG1CTL_Pos)                 /*!< ADC_T::SEQCTL: TRG1CTL Mask               */
N
N#define ADC_SEQCTL_TRG2CTL_Pos           (16)                                              /*!< ADC_T::SEQCTL: TRG2CTL Position           */
N#define ADC_SEQCTL_TRG2CTL_Msk           (0xful << ADC_SEQCTL_TRG2CTL_Pos)                 /*!< ADC_T::SEQCTL: TRG2CTL Mask               */
N
N#define ADC_SEQDAT1_RESULT_Pos           (0)                                               /*!< ADC_T::SEQDAT1: RESULT Position           */
N#define ADC_SEQDAT1_RESULT_Msk           (0x3fful << ADC_SEQDAT1_RESULT_Pos)               /*!< ADC_T::SEQDAT1: RESULT Mask               */
N
N#define ADC_SEQDAT1_OV_Pos               (16)                                              /*!< ADC_T::SEQDAT1: OV Position               */
N#define ADC_SEQDAT1_OV_Msk               (0x1ul << ADC_SEQDAT1_OV_Pos)                     /*!< ADC_T::SEQDAT1: OV Mask                   */
N
N#define ADC_SEQDAT1_VALID_Pos            (17)                                              /*!< ADC_T::SEQDAT1: VALID Position            */
N#define ADC_SEQDAT1_VALID_Msk            (0x1ul << ADC_SEQDAT1_VALID_Pos)                  /*!< ADC_T::SEQDAT1: VALID Mask                */
N
N#define ADC_SEQDAT2_RESULT_Pos           (0)                                               /*!< ADC_T::SEQDAT2: RESULT Position           */
N#define ADC_SEQDAT2_RESULT_Msk           (0x3fful << ADC_SEQDAT2_RESULT_Pos)               /*!< ADC_T::SEQDAT2: RESULT Mask               */
N
N#define ADC_SEQDAT2_OV_Pos               (16)                                              /*!< ADC_T::SEQDAT2: OV Position               */
N#define ADC_SEQDAT2_OV_Msk               (0x1ul << ADC_SEQDAT2_OV_Pos)                     /*!< ADC_T::SEQDAT2: OV Mask                   */
N
N#define ADC_SEQDAT2_VALID_Pos            (17)                                              /*!< ADC_T::SEQDAT2: VALID Position            */
N#define ADC_SEQDAT2_VALID_Msk            (0x1ul << ADC_SEQDAT2_VALID_Pos)                  /*!< ADC_T::SEQDAT2: VALID Mask                */
N
N/**@}*/ /* ADC_CONST */
N/**@}*/ /* end of ADC register group */
N
N
N/*---------------------- System Clock Controller -------------------------*/
N/**
N    @addtogroup CLK System Clock Controller(CLK)
N    Memory Mapped Structure for CLK Controller
N@{ */
N
Ntypedef struct {
N
N
N    /**
N     * PWRCTL
N     * ===================================================================================================
N     * Offset: 0x00  System Power-down Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |XTLEN     |External HXT Or LXT Crystal Oscillator Enable Bit (Write Protect)
N     * |        |          |The default clock source is from HIRC.
N     * |        |          |These two bits are default set to "00" and the XT1_IN and XT1_OUT pins are GPI.
N     * |        |          |00 = XT1_IN and XT1_OUT are GPIO, disable both LXT & HXT (default).
N     * |        |          |01 = HXT Enabled.
N     * |        |          |10 = LXT Enabled.
N     * |        |          |11 = XT1_IN is external clock input pin, XT1_OUT is GPIO.
N     * |        |          |Note: To enable external XTAL function, ALT[1:0] and MFP[1:0] bits must also be set in SYS_P5_MFP.
N     * |[2]     |HIRCEN    |HIRC Enable Bit (Write Protect)
N     * |        |          |0 = 22.1184 MHz internal high speed RC oscillator (HIRC) Disabled.
N     * |        |          |1 = 22.1184 MHz internal high speed RC oscillator (HIRC) Enabled.
N     * |        |          |Note: The default of HIRCEN bit is 1.
N     * |[3]     |LIRCEN    |LIRC Enable Bit (Write Protect)
N     * |        |          |0 = 10 kHz internal low speed RC oscillator (LIRC) Disabled.
N     * |        |          |1 = 10 kHz internal low speed RC oscillator (LIRC) Enabled.
N     * |[4]     |PDWKDLY   |Wake-up Delay Counter Enable Bit (Write Protect)
N     * |        |          |When the chip wakes up from Power-down mode, the clock control will delay certain clock cycles to wait system clock stable.
N     * |        |          |The delayed clock cycle is 4096 clock cycles when chip work at 4~24 MHz external high speed crystal (HXT), 4096 clock cycles for 32.768 kHz external low speed crystal (LXT), and 16 clock cycles when chip works at 22.1184 MHz internal high speed RC oscillator (HIRC).
N     * |        |          |0 = Clock cycles delay Disabled.
N     * |        |          |1 = Clock cycles delay Enabled.
N     * |[5]     |PDWKIEN   |Power-down Mode Wake-up Interrupt Enable Bit (Write Protect)
N     * |        |          |0 = Power-down mode wake-up interrupt Disabled.
N     * |        |          |1 = Power-down mode wake-up interrupt Enabled.
N     * |        |          |Note: The interrupt will occur when both PDWKIF and PDWKIEN are high.
N     * |[6]     |PDWKIF    |Power-down Mode Wake-up Interrupt Status
N     * |        |          |Set by "Power-down wake-up event", which indicates that resume from Power-down mode
N     * |        |          |The flag is set if the GPIO, UART, WDT, ACMP, Timer or BOD wake-up occurred.
N     * |        |          |Note: This bit works only if PDWKIEN (CLK_PWRCTL[5]) set to 1. Write 1 to clear the bit to 0.
N     * |[7]     |PDEN      |System Power-down Enable Bit (Write Protect)
N     * |        |          |When chip wakes up from Power-down mode, this bit is cleared by hardware.
N     * |        |          |User needs to set this bit again for next Power-down.
N     * |        |          |In Power-down mode, 4~24 MHz external high speed crystal oscillator (HXT), 32.768 kHz external low speed crystal oscillator (LXT), and the 22.1184 MHz internal high speed oscillator (HIRC) will be disabled in this mode, and 10 kHz internal low speed RC oscillator (LIRC) are not controlled by Power-down mode.
N     * |        |          |In Power-down mode, the PLL and system clock are disabled, and ignored the clock source selection.
N     * |        |          |The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock source is from 10 kHz internal low speed oscillator.
N     * |        |          |0 = Chip operating normally or chip in Idle mode because of WFI command.
N     * |        |          |1 = Chip enters Power-down mode instantly or waits CPU sleep command WFI.
N     * |[9]     |PDLXT     |Enable LXT In Power-down Mode
N     * |        |          |This bit controls the crystal oscillator active or not in Power-down mode.
N     * |        |          |0 = No effect to Power-down mode.
N     * |        |          |1 = If XTLEN[1:0] = 10, LXT is still active in Power-down mode.
N    */
N    __IO uint32_t PWRCTL;
X    volatile uint32_t PWRCTL;
N
N    /**
N     * AHBCLK
N     * ===================================================================================================
N     * Offset: 0x04  AHB Devices Clock Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2]     |ISPCKEN   |Flash ISP Controller Clock Enable Bit
N     * |        |          |0 = Flash ISP peripheral clock Disabled.
N     * |        |          |1 = Flash ISP peripheral clock Enabled.
N    */
N    __IO uint32_t AHBCLK;
X    volatile uint32_t AHBCLK;
N
N    /**
N     * APBCLK
N     * ===================================================================================================
N     * Offset: 0x08  APB Devices Clock Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WDTCKEN   |Watchdog Timer Clock Enable Bit (Write Protect)
N     * |        |          |0 = Watchdog Timer clock Disabled.
N     * |        |          |1 = Watchdog Timer clock Enabled.
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write 0x59, 0x16, and 0x88 to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register SYS_REGLCTL at address SYS_BA + 0x10.
N     * |[2]     |TMR0CKEN  |Timer0 Clock Enable Bit
N     * |        |          |0 = Timer0 clock Disabled.
N     * |        |          |1 = Timer0 clock Enabled.
N     * |[3]     |TMR1CKEN  |Timer1 Clock Enable Bit
N     * |        |          |0 = Timer1 clock Disabled.
N     * |        |          |1 = Timer1 clock Enabled.
N     * |[6]     |CLKOCKEN  |Frequency Divider Output Clock Enable Bit
N     * |        |          |0 = CLKO clock Disabled.
N     * |        |          |1 = CLKO clock Enabled.
N     * |[8]     |I2C0CKEN  |I2C0 Clock Enable Bit
N     * |        |          |0 = I2C0 clock Disabled.
N     * |        |          |1 = I2C0 clock Enabled.
N     * |[9]     |I2C1CKEN  |I2C1 Clock Enable Bit
N     * |        |          |0 = I2C1 clock Disabled.
N     * |        |          |1 = I2C1 clock Enabled.
N     * |[12]    |SPICKEN   |SPI Clock Enable Bit
N     * |        |          |0 = SPI peripheral clock Disabled.
N     * |        |          |1 = SPI peripheral clock Enabled.
N     * |[16]    |UART0CKEN |UART0 Clock Enable Bit
N     * |        |          |0 = UART0 clock Disabled.
N     * |        |          |1 = UART0 clock Enabled.
N     * |[17]    |UART1CKEN |UART1 Clock Enable Bit
N     * |        |          |0 = UART1 clock Disabled.
N     * |        |          |1 = UART1 clock Enabled.
N     * |[20]    |PWMCH01CKEN|PWM_01 Clock Enable Bit
N     * |        |          |0 = PWM01 clock Disabled.
N     * |        |          |1 = PWM01 clock Enabled.
N     * |[21]    |PWMCH23CKEN|PWM_23 Clock Enable Bit
N     * |        |          |0 = PWM23 clock Disabled.
N     * |        |          |1 = PWM23 clock Enabled.
N     * |[22]    |PWMCH45CKEN|PWM_45 Clock Enable Bit
N     * |        |          |0 = PWM45 clock Disabled.
N     * |        |          |1 = PWM45 clock Enabled.
N     * |[28]    |ADCCKEN   |Analog-digital-converter (ADC) Clock Enable Bit
N     * |        |          |0 = ADC peripheral clock Disabled.
N     * |        |          |1 = ADC peripheral clock Enabled.
N     * |[30]    |ACMPCKEN  |Analog Comparator Clock Enable Bit
N     * |        |          |0 = Analog Comparator clock Disabled.
N     * |        |          |1 = Analog Comparator clock Enabled.
N    */
N    __IO uint32_t APBCLK;
X    volatile uint32_t APBCLK;
N
N    /**
N     * STATUS
N     * ===================================================================================================
N     * Offset: 0x0C  Clock Status Monitor Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |XTLSTB    |HXT Or LXT Clock Source Stable Flag
N     * |        |          |0 = HXT or LXT clock is not stable or disabled.
N     * |        |          |1 = HXT or LXT clock is stable and enabled.
N     * |[2]     |PLLSTB    |Internal PLL Clock Source Stable Flag (Read Only)
N     * |        |          |0 = Internal PLL clock is not stable or disabled.
N     * |        |          |1 = Internal PLL clock is stable and enabled.
N     * |[3]     |LIRCSTB   |LIRC Clock Source Stable Flag (Read Only)
N     * |        |          |0 = LIRC clock is not stable or disabled.
N     * |        |          |1 = LIRC clock is stable and enabled.
N     * |[4]     |HIRCSTB   |HIRC Clock Source Stable Flag (Read Only)
N     * |        |          |0 = HIRC clock is not stable or disabled.
N     * |        |          |1 = HIRC clock is stable and enabled.
N     * |[7]     |CLKSFAIL  |Clock Switch Fail Flag (Read Only)
N     * |        |          |This bit is updated when software switches system clock source.
N     * |        |          |If switch target clock is stable, this bit will be set to 0.
N     * |        |          |If switch target clock is not stable, this bit will be set to .
N     * |        |          |0 = Clock switching success.
N     * |        |          |1 = Clock switching failure.
N     * |        |          |Note: This bit is read only.
N     * |        |          |After selected clock source is stable, hardware will switch system clock to selected clock automatically, and CLKSFAIL will be cleared automatically by hardware.
N    */
N    __IO uint32_t STATUS;
X    volatile uint32_t STATUS;
N
N    /**
N     * CLKSEL0
N     * ===================================================================================================
N     * Offset: 0x10  Clock Source Select Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |HCLKSEL   |HCLK Clock Source Selection (Write Protect)
N     * |        |          |000 = Clock source is from HXT or LXT.
N     * |        |          |001 = Reserved.
N     * |        |          |010 = Clock source is from PLL.
N     * |        |          |011 = Clock source is from LIRC.
N     * |        |          |111 = Clock source is from HIRC.
N     * |        |          |Others = Reserved.
N     * |        |          |Note1: Before clock switching, the related clock sources (both pre-select and new-select) must be turn-on and stable.
N     * |        |          |Note2: These bits are protected bit, and programming them needs to write 0x59, 0x16, and 0x88 to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register SYS_REGLCTL at address SYS_BA + 0x10.
N     * |        |          |Note3: To set CLK_PWRCTL[1:0] to select HXT or LXT crystal clock.
N     * |[5:3]   |STCLKSEL  |Cortex-M0 SysTick Clock Source Selection (Write Protect)
N     * |        |          |If CLKSRC (SYST_CSR[2]) = 1, SysTick clock source is from HCLK.
N     * |        |          |If CLKSRC (SYST_CSR[2]) = 0, SysTick clock source is defined by below settings.
N     * |        |          |000 = Clock source is from HXT or LXT.
N     * |        |          |001 = Reserved.
N     * |        |          |010 = Clock source is from HXT/2 or LXT/2.
N     * |        |          |011 = Clock source is from HCLK/2.
N     * |        |          |111 = Clock source is from HIRC/2.
N     * |        |          |Others = Reserved.
N     * |        |          |Note1: These bits are protected bit, and programming them needs to write 0x59, 0x16, and 0x88 to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register SYS_REGLCTL at address SYS_BA + 0x10.
N     * |        |          |Note2: If the SysTick clock source is not from HCLK (i.e.
N     * |        |          |CLKSRC(SYST_CSR[2]) = 0), SysTick clock source must less than or equal to HCLK/.
N     * |        |          |Note3: To set CLK_PWRCTL[1:0], select HXT or LXT crystal clock.
N    */
N    __IO uint32_t CLKSEL0;
X    volatile uint32_t CLKSEL0;
N
N    /**
N     * CLKSEL1
N     * ===================================================================================================
N     * Offset: 0x14  Clock Source Select Control Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |WDTSEL    |WDT CLK Clock Source Selection (Write Protect)
N     * |        |          |00 = Clock source is from HXT or LXT.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = Clock source is from HCLK/2048 clock.
N     * |        |          |11 = Clock source is from LIRC.
N     * |        |          |Note1: These bits are the protected bit, and programming them needs to write 0x59, 0x16, and 0x88 to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register SYS_REGLCTL at address SYS_BA + 0x10.
N     * |        |          |Note2: To set CLK_PWRCTL[1:0], select HXT or LXT crystal clock.
N     * |[3:2]   |ADCSEL    |ADC Peripheral Clock Source Selection
N     * |        |          |00 = Clock source is from HXT or LXT.
N     * |        |          |01 = Clock source is from PLL.
N     * |        |          |10 = Clock source is from HCLK.
N     * |        |          |11 = Clock source is from HIRC.
N     * |        |          |Note: To set CLK_PWRCTL[1:0], select HXT or LXT crystal clock.
N     * |[5:4]   |SPISEL    |SPI Clock Source Selection
N     * |        |          |00 = Clock source is from HXT or LXT.
N     * |        |          |01 = Clock source is from HCLK.
N     * |        |          |10 = Clock source is from PLL.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: To set CLK_PWRCTL[1:0], select HXT or LXT crystal clock.
N     * |[10:8]  |TMR0SEL   |TIMER0 Clock Source Selection
N     * |        |          |000 = Clock source is from HXT or LXT.
N     * |        |          |001 = Clock source is from LIRC.
N     * |        |          |010 = Clock source is from HCLK.
N     * |        |          |011 = Clock source is from external trigger.
N     * |        |          |111 = Clock source is from HIRC.
N     * |        |          |Others = Reserved.
N     * |        |          |Note: To set CLK_PWRCTL[1:0], select HXT or LXT crystal clock.
N     * |[14:12] |TMR1SEL   |TIMER1 Clock Source Selection
N     * |        |          |000 = Clock source is from HXT or LXT.
N     * |        |          |001 = Clock source is from LIRC.
N     * |        |          |010 = Clock source is from HCLK.
N     * |        |          |011 = Clock source is from external trigger.
N     * |        |          |111 = Clock source is from HIRC.
N     * |        |          |Others = Reserved.
N     * |        |          |Note: To set CLK_PWRCTL[1:0], select HXT or LXT crystal clock.
N     * |[25:24] |UARTSEL   |UART Clock Source Selection
N     * |        |          |00 = Clock source is from HXT or LXT.
N     * |        |          |01 = Clock source is from PLL.
N     * |        |          |10 = Clock source is from HIRC.
N     * |        |          |11 = Clock source is from HIRC.
N     * |        |          |Note: To set CLK_PWRCTL[1:0], select HXT or LXT crystal clock.
N     * |[29:28] |PWMCH01SEL|PWM0 And PWM1 Clock Source Selection
N     * |        |          |PWM0 and PWM1 use the same peripheral clock source. Both of them use the same prescaler.
N     * |        |          |00 = Reserved.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = Clock source is from HCLK.
N     * |        |          |11 = Reserved.
N     * |[31:30] |PWMCH23SEL|PWM2 And PWM3 Clock Source Selection
N     * |        |          |PWM2 and PWM3 use the same peripheral clock source; Both of them use the same prescaler.
N     * |        |          |00 = Reserved.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = Clock source is from HCLK.
N     * |        |          |11 = Reserved.
N    */
N    __IO uint32_t CLKSEL1;
X    volatile uint32_t CLKSEL1;
N
N    /**
N     * CLKDIV
N     * ===================================================================================================
N     * Offset: 0x18  Clock Divider Number Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |HCLKDIV   |HCLK Clock Divide Number From HCLK Clock Source
N     * |        |          |HCLK clock frequency = (HCLK clock source frequency) / (HCLKDIV + 1).
N     * |[11:8]  |UARTDIV   |UART Clock Divide Number From UART Clock Source
N     * |        |          |UART clock frequency = (UART clock source frequency) / (UARTDIV + 1).
N     * |[23:16] |ADCDIV    |ADC Peripheral Clock Divide Number From ADC Peripheral Clock Source
N     * |        |          |ADC peripheral clock frequency = (ADC peripheral clock source frequency) / (ADCDIV + 1).
N    */
N    __IO uint32_t CLKDIV;
X    volatile uint32_t CLKDIV;
N
N    /**
N     * CLKSEL2
N     * ===================================================================================================
N     * Offset: 0x1C  Clock Source Select Control Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:2]   |CLKOSEL   |Clock Divider Clock Source Selection
N     * |        |          |00 = Clock source is from HXT or LXT.
N     * |        |          |01 = Clock source is from LIRC.
N     * |        |          |10 = Clock source is from HCLK.
N     * |        |          |11 = Clock source is from HIRC.
N     * |        |          |Note: To set CLK_PWRCTL[1:0], select HXT or LXT crystal clock.
N     * |[5:4]   |PWMCH45SEL|PWM4 And PWM5 Clock Source Selection
N     * |        |          |PWM4 and PWM5 use the same peripheral clock source; Both of them use the same prescaler.
N     * |        |          |00 = Reserved.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = Clock source is from HCLK.
N     * |        |          |11 = Reserved.
N     * |[17:16] |WWDTSEL   |Window Watchdog Timer Clock Source Selection
N     * |        |          |00 = Reserved.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = Clock source from HCLK/2048 clock.
N     * |        |          |11 = Clock source from 10 kHz internal low speed RC oscillator (LIRC).
N    */
N    __IO uint32_t CLKSEL2;
X    volatile uint32_t CLKSEL2;
N
N    /**
N     * PLLCTL
N     * ===================================================================================================
N     * Offset: 0x20  PLL Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8:0]   |FBDIV     |PLL Feedback Divider Control
N     * |        |          |Refer to the formulas below the table.
N     * |[13:9]  |INDIV     |PLL Input Divider Control
N     * |        |          |Refer to the formulas below the table.
N     * |[15:14] |OUTDIV    |PLL Output Divider Control
N     * |        |          |Refer to the formulas below the table.
N     * |[16]    |PD        |Power-down Mode
N     * |        |          |If the PDEN bit is set to 1 in CLK_PWRCTL register, the PLL will enter Power-down mode too.
N     * |        |          |0 = PLL is in Normal mode.
N     * |        |          |1 = PLL is in Power-down mode (default).
N     * |[17]    |BP        |PLL Bypass Control
N     * |        |          |0 = PLL is in Normal mode (default).
N     * |        |          |1 = PLL clock output is same as PLL source clock input.
N     * |[18]    |OE        |PLL OE (FOUT Enable) Pin Control
N     * |        |          |0 = PLL FOUT Enabled.
N     * |        |          |1 = PLL FOUT is fixed low.
N     * |[19]    |PLLSRC    |PLL Source Clock Selection
N     * |        |          |0 = PLL source clock from HXT.
N     * |        |          |1 = PLL source clock from HIRC.
N    */
N    __IO uint32_t PLLCTL;
X    volatile uint32_t PLLCTL;
N
N    /**
N     * CLKOCTL
N     * ===================================================================================================
N     * Offset: 0x24  Frequency Divider Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |FREQSEL   |Divider Output Frequency Selection
N     * |        |          |The formula of output frequency is
N     * |        |          |Fout = Fin/2(N+1).
N     * |        |          |Fin is the input clock frequency.
N     * |        |          |Fout is the frequency of divider output clock.
N     * |        |          |N is the 4-bit value of FREQSEL(CLK_CLKOCTL[3:0]).
N     * |[4]     |CLKOEN    |Frequency Divider Enable Bit
N     * |        |          |0 = Frequency Divider Disabled.
N     * |        |          |1 = Frequency Divider Enabled.
N     * |[5]     |DIV1EN    |Frequency Divider One Enable Bit
N     * |        |          |0 = Divider output frequency is depended on FREQSEL value.
N     * |        |          |1 = Divider output frequency is the same as input clock frequency.
N    */
N    __IO uint32_t CLKOCTL;
X    volatile uint32_t CLKOCTL;
N
N} CLK_T;
N
N/**
N    @addtogroup CLK_CONST CLK Bit Field Definition
N    Constant Definitions for CLK Controller
N@{ */
N
N#define CLK_PWRCTL_XTLEN_Pos             (0)                                               /*!< CLK_T::PWRCTL: XTLEN Position             */
N#define CLK_PWRCTL_XTLEN_Msk             (0x3ul << CLK_PWRCTL_XTLEN_Pos)                   /*!< CLK_T::PWRCTL: XTLEN Mask                 */
N
N#define CLK_PWRCTL_HIRCEN_Pos            (2)                                               /*!< CLK_T::PWRCTL: HIRCEN Position            */
N#define CLK_PWRCTL_HIRCEN_Msk            (0x1ul << CLK_PWRCTL_HIRCEN_Pos)                  /*!< CLK_T::PWRCTL: HIRCEN Mask                */
N
N#define CLK_PWRCTL_LIRCEN_Pos            (3)                                               /*!< CLK_T::PWRCTL: LIRCEN Position            */
N#define CLK_PWRCTL_LIRCEN_Msk            (0x1ul << CLK_PWRCTL_LIRCEN_Pos)                  /*!< CLK_T::PWRCTL: LIRCEN Mask                */
N
N#define CLK_PWRCTL_PDWKDLY_Pos           (4)                                               /*!< CLK_T::PWRCTL: PDWKDLY Position           */
N#define CLK_PWRCTL_PDWKDLY_Msk           (0x1ul << CLK_PWRCTL_PDWKDLY_Pos)                 /*!< CLK_T::PWRCTL: PDWKDLY Mask               */
N
N#define CLK_PWRCTL_PDWKIEN_Pos           (5)                                               /*!< CLK_T::PWRCTL: PDWKIEN Position           */
N#define CLK_PWRCTL_PDWKIEN_Msk           (0x1ul << CLK_PWRCTL_PDWKIEN_Pos)                 /*!< CLK_T::PWRCTL: PDWKIEN Mask               */
N
N#define CLK_PWRCTL_PDWKIF_Pos            (6)                                               /*!< CLK_T::PWRCTL: PDWKIF Position            */
N#define CLK_PWRCTL_PDWKIF_Msk            (0x1ul << CLK_PWRCTL_PDWKIF_Pos)                  /*!< CLK_T::PWRCTL: PDWKIF Mask                */
N
N#define CLK_PWRCTL_PDEN_Pos              (7)                                               /*!< CLK_T::PWRCTL: PDEN Position              */
N#define CLK_PWRCTL_PDEN_Msk              (0x1ul << CLK_PWRCTL_PDEN_Pos)                    /*!< CLK_T::PWRCTL: PDEN Mask                  */
N
N#define CLK_PWRCTL_PDLXT_Pos             (9)                                               /*!< CLK_T::PWRCTL: PDLXT Position             */
N#define CLK_PWRCTL_PDLXT_Msk             (0x1ul << CLK_PWRCTL_PDLXT_Pos)                   /*!< CLK_T::PWRCTL: PDLXT Mask                 */
N
N#define CLK_AHBCLK_ISPCKEN_Pos           (2)                                               /*!< CLK_T::AHBCLK: ISPCKEN Position           */
N#define CLK_AHBCLK_ISPCKEN_Msk           (0x1ul << CLK_AHBCLK_ISPCKEN_Pos)                 /*!< CLK_T::AHBCLK: ISPCKEN Mask               */
N
N#define CLK_APBCLK_WDTCKEN_Pos           (0)                                               /*!< CLK_T::APBCLK: WDTCKEN Position           */
N#define CLK_APBCLK_WDTCKEN_Msk           (0x1ul << CLK_APBCLK_WDTCKEN_Pos)                 /*!< CLK_T::APBCLK: WDTCKEN Mask               */
N
N#define CLK_APBCLK_TMR0CKEN_Pos          (2)                                               /*!< CLK_T::APBCLK: TMR0CKEN Position          */
N#define CLK_APBCLK_TMR0CKEN_Msk          (0x1ul << CLK_APBCLK_TMR0CKEN_Pos)                /*!< CLK_T::APBCLK: TMR0CKEN Mask              */
N
N#define CLK_APBCLK_TMR1CKEN_Pos          (3)                                               /*!< CLK_T::APBCLK: TMR1CKEN Position          */
N#define CLK_APBCLK_TMR1CKEN_Msk          (0x1ul << CLK_APBCLK_TMR1CKEN_Pos)                /*!< CLK_T::APBCLK: TMR1CKEN Mask              */
N
N#define CLK_APBCLK_CLKOCKEN_Pos          (6)                                               /*!< CLK_T::APBCLK: CLKOCKEN Position          */
N#define CLK_APBCLK_CLKOCKEN_Msk          (0x1ul << CLK_APBCLK_CLKOCKEN_Pos)                /*!< CLK_T::APBCLK: CLKOCKEN Mask              */
N
N#define CLK_APBCLK_I2C0CKEN_Pos          (8)                                               /*!< CLK_T::APBCLK: I2C0CKEN Position          */
N#define CLK_APBCLK_I2C0CKEN_Msk          (0x1ul << CLK_APBCLK_I2C0CKEN_Pos)                /*!< CLK_T::APBCLK: I2C0CKEN Mask              */
N
N#define CLK_APBCLK_I2C1CKEN_Pos          (9)                                               /*!< CLK_T::APBCLK: I2C1CKEN Position          */
N#define CLK_APBCLK_I2C1CKEN_Msk          (0x1ul << CLK_APBCLK_I2C1CKEN_Pos)                /*!< CLK_T::APBCLK: I2C1CKEN Mask              */
N
N#define CLK_APBCLK_SPICKEN_Pos           (12)                                              /*!< CLK_T::APBCLK: SPICKEN Position           */
N#define CLK_APBCLK_SPICKEN_Msk           (0x1ul << CLK_APBCLK_SPICKEN_Pos)                 /*!< CLK_T::APBCLK: SPICKEN Mask               */
N
N#define CLK_APBCLK_UART0CKEN_Pos         (16)                                              /*!< CLK_T::APBCLK: UART0CKEN Position         */
N#define CLK_APBCLK_UART0CKEN_Msk         (0x1ul << CLK_APBCLK_UART0CKEN_Pos)               /*!< CLK_T::APBCLK: UART0CKEN Mask             */
N
N#define CLK_APBCLK_UART1CKEN_Pos         (17)                                              /*!< CLK_T::APBCLK: UART1CKEN Position         */
N#define CLK_APBCLK_UART1CKEN_Msk         (0x1ul << CLK_APBCLK_UART1CKEN_Pos)               /*!< CLK_T::APBCLK: UART1CKEN Mask             */
N
N#define CLK_APBCLK_PWMCH01CKEN_Pos       (20)                                              /*!< CLK_T::APBCLK: PWMCH01CKEN Position       */
N#define CLK_APBCLK_PWMCH01CKEN_Msk       (0x1ul << CLK_APBCLK_PWMCH01CKEN_Pos)             /*!< CLK_T::APBCLK: PWMCH01CKEN Mask           */
N
N#define CLK_APBCLK_PWMCH23CKEN_Pos       (21)                                              /*!< CLK_T::APBCLK: PWMCH23CKEN Position       */
N#define CLK_APBCLK_PWMCH23CKEN_Msk       (0x1ul << CLK_APBCLK_PWMCH23CKEN_Pos)             /*!< CLK_T::APBCLK: PWMCH23CKEN Mask           */
N
N#define CLK_APBCLK_PWMCH45CKEN_Pos       (22)                                              /*!< CLK_T::APBCLK: PWMCH45CKEN Position       */
N#define CLK_APBCLK_PWMCH45CKEN_Msk       (0x1ul << CLK_APBCLK_PWMCH45CKEN_Pos)             /*!< CLK_T::APBCLK: PWMCH45CKEN Mask           */
N
N#define CLK_APBCLK_ADCCKEN_Pos           (28)                                              /*!< CLK_T::APBCLK: ADCCKEN Position           */
N#define CLK_APBCLK_ADCCKEN_Msk           (0x1ul << CLK_APBCLK_ADCCKEN_Pos)                 /*!< CLK_T::APBCLK: ADCCKEN Mask               */
N
N#define CLK_APBCLK_ACMPCKEN_Pos          (30)                                              /*!< CLK_T::APBCLK: ACMPCKEN Position          */
N#define CLK_APBCLK_ACMPCKEN_Msk          (0x1ul << CLK_APBCLK_ACMPCKEN_Pos)                /*!< CLK_T::APBCLK: ACMPCKEN Mask              */
N
N#define CLK_STATUS_XTLSTB_Pos            (0)                                               /*!< CLK_T::STATUS: XTLSTB Position            */
N#define CLK_STATUS_XTLSTB_Msk            (0x1ul << CLK_STATUS_XTLSTB_Pos)                  /*!< CLK_T::STATUS: XTLSTB Mask                */
N
N#define CLK_STATUS_PLLSTB_Pos            (2)                                               /*!< CLK_T::STATUS: PLLSTB Position            */
N#define CLK_STATUS_PLLSTB_Msk            (0x1ul << CLK_STATUS_PLLSTB_Pos)                  /*!< CLK_T::STATUS: PLLSTB Mask                */
N
N#define CLK_STATUS_LIRCSTB_Pos           (3)                                               /*!< CLK_T::STATUS: LIRCSTB Position           */
N#define CLK_STATUS_LIRCSTB_Msk           (0x1ul << CLK_STATUS_LIRCSTB_Pos)                 /*!< CLK_T::STATUS: LIRCSTB Mask               */
N
N#define CLK_STATUS_HIRCSTB_Pos           (4)                                               /*!< CLK_T::STATUS: HIRCSTB Position           */
N#define CLK_STATUS_HIRCSTB_Msk           (0x1ul << CLK_STATUS_HIRCSTB_Pos)                 /*!< CLK_T::STATUS: HIRCSTB Mask               */
N
N#define CLK_STATUS_CLKSFAIL_Pos          (7)                                               /*!< CLK_T::STATUS: CLKSFAIL Position          */
N#define CLK_STATUS_CLKSFAIL_Msk          (0x1ul << CLK_STATUS_CLKSFAIL_Pos)                /*!< CLK_T::STATUS: CLKSFAIL Mask              */
N
N#define CLK_CLKSEL0_HCLKSEL_Pos          (0)                                               /*!< CLK_T::CLKSEL0: HCLKSEL Position          */
N#define CLK_CLKSEL0_HCLKSEL_Msk          (0x7ul << CLK_CLKSEL0_HCLKSEL_Pos)                /*!< CLK_T::CLKSEL0: HCLKSEL Mask              */
N
N#define CLK_CLKSEL0_STCLKSEL_Pos         (3)                                               /*!< CLK_T::CLKSEL0: STCLKSEL Position         */
N#define CLK_CLKSEL0_STCLKSEL_Msk         (0x7ul << CLK_CLKSEL0_STCLKSEL_Pos)               /*!< CLK_T::CLKSEL0: STCLKSEL Mask             */
N
N#define CLK_CLKSEL1_WDTSEL_Pos           (0)                                               /*!< CLK_T::CLKSEL1: WDTSEL Position           */
N#define CLK_CLKSEL1_WDTSEL_Msk           (0x3ul << CLK_CLKSEL1_WDTSEL_Pos)                 /*!< CLK_T::CLKSEL1: WDTSEL Mask               */
N
N#define CLK_CLKSEL1_ADCSEL_Pos           (2)                                               /*!< CLK_T::CLKSEL1: ADCSEL Position           */
N#define CLK_CLKSEL1_ADCSEL_Msk           (0x3ul << CLK_CLKSEL1_ADCSEL_Pos)                 /*!< CLK_T::CLKSEL1: ADCSEL Mask               */
N
N#define CLK_CLKSEL1_SPISEL_Pos           (4)                                               /*!< CLK_T::CLKSEL1: SPISEL Position           */
N#define CLK_CLKSEL1_SPISEL_Msk           (0x3ul << CLK_CLKSEL1_SPISEL_Pos)                 /*!< CLK_T::CLKSEL1: SPISEL Mask               */
N
N#define CLK_CLKSEL1_TMR0SEL_Pos          (8)                                               /*!< CLK_T::CLKSEL1: TMR0SEL Position          */
N#define CLK_CLKSEL1_TMR0SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR0SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR0SEL Mask              */
N
N#define CLK_CLKSEL1_TMR1SEL_Pos          (12)                                              /*!< CLK_T::CLKSEL1: TMR1SEL Position          */
N#define CLK_CLKSEL1_TMR1SEL_Msk          (0x7ul << CLK_CLKSEL1_TMR1SEL_Pos)                /*!< CLK_T::CLKSEL1: TMR1SEL Mask              */
N
N#define CLK_CLKSEL1_UARTSEL_Pos          (24)                                              /*!< CLK_T::CLKSEL1: UARTSEL Position          */
N#define CLK_CLKSEL1_UARTSEL_Msk          (0x3ul << CLK_CLKSEL1_UARTSEL_Pos)                /*!< CLK_T::CLKSEL1: UARTSEL Mask              */
N
N#define CLK_CLKSEL1_PWMCH01SEL_Pos       (28)                                              /*!< CLK_T::CLKSEL1: PWMCH01SEL Position       */
N#define CLK_CLKSEL1_PWMCH01SEL_Msk       (0x3ul << CLK_CLKSEL1_PWMCH01SEL_Pos)             /*!< CLK_T::CLKSEL1: PWMCH01SEL Mask           */
N
N#define CLK_CLKSEL1_PWMCH23SEL_Pos       (30)                                              /*!< CLK_T::CLKSEL1: PWMCH23SEL Position       */
N#define CLK_CLKSEL1_PWMCH23SEL_Msk       (0x3ul << CLK_CLKSEL1_PWMCH23SEL_Pos)             /*!< CLK_T::CLKSEL1: PWMCH23SEL Mask           */
N
N#define CLK_CLKDIV_HCLKDIV_Pos           (0)                                               /*!< CLK_T::CLKDIV: HCLKDIV Position           */
N#define CLK_CLKDIV_HCLKDIV_Msk           (0xful << CLK_CLKDIV_HCLKDIV_Pos)                 /*!< CLK_T::CLKDIV: HCLKDIV Mask               */
N
N#define CLK_CLKDIV_UARTDIV_Pos           (8)                                               /*!< CLK_T::CLKDIV: UARTDIV Position           */
N#define CLK_CLKDIV_UARTDIV_Msk           (0xful << CLK_CLKDIV_UARTDIV_Pos)                 /*!< CLK_T::CLKDIV: UARTDIV Mask               */
N
N#define CLK_CLKDIV_ADCDIV_Pos            (16)                                              /*!< CLK_T::CLKDIV: ADCDIV Position            */
N#define CLK_CLKDIV_ADCDIV_Msk            (0xfful << CLK_CLKDIV_ADCDIV_Pos)                 /*!< CLK_T::CLKDIV: ADCDIV Mask                */
N
N#define CLK_CLKSEL2_CLKOSEL_Pos          (2)                                               /*!< CLK_T::CLKSEL2: CLKOSEL Position          */
N#define CLK_CLKSEL2_CLKOSEL_Msk          (0x3ul << CLK_CLKSEL2_CLKOSEL_Pos)                /*!< CLK_T::CLKSEL2: CLKOSEL Mask              */
N
N#define CLK_CLKSEL2_PWMCH45SEL_Pos       (4)                                               /*!< CLK_T::CLKSEL2: PWMCH45SEL Position       */
N#define CLK_CLKSEL2_PWMCH45SEL_Msk       (0x3ul << CLK_CLKSEL2_PWMCH45SEL_Pos)             /*!< CLK_T::CLKSEL2: PWMCH45SEL Mask           */
N
N#define CLK_CLKSEL2_WWDTSEL_Pos          (16)                                              /*!< CLK_T::CLKSEL2: WWDTSEL Position          */
N#define CLK_CLKSEL2_WWDTSEL_Msk          (0x3ul << CLK_CLKSEL2_WWDTSEL_Pos)                /*!< CLK_T::CLKSEL2: WWDTSEL Mask              */
N
N#define CLK_PLLCTL_FBDIV_Pos             (0)                                               /*!< CLK_T::PLLCTL: FBDIV Position             */
N#define CLK_PLLCTL_FBDIV_Msk             (0x1fful << CLK_PLLCTL_FBDIV_Pos)                 /*!< CLK_T::PLLCTL: FBDIV Mask                 */
N
N#define CLK_PLLCTL_INDIV_Pos             (9)                                               /*!< CLK_T::PLLCTL: INDIV Position             */
N#define CLK_PLLCTL_INDIV_Msk             (0x1ful << CLK_PLLCTL_INDIV_Pos)                  /*!< CLK_T::PLLCTL: INDIV Mask                 */
N
N#define CLK_PLLCTL_OUTDIV_Pos            (14)                                              /*!< CLK_T::PLLCTL: OUTDIV Position            */
N#define CLK_PLLCTL_OUTDIV_Msk            (0x3ul << CLK_PLLCTL_OUTDIV_Pos)                  /*!< CLK_T::PLLCTL: OUTDIV Mask                */
N
N#define CLK_PLLCTL_PD_Pos                (16)                                              /*!< CLK_T::PLLCTL: PD Position                */
N#define CLK_PLLCTL_PD_Msk                (0x1ul << CLK_PLLCTL_PD_Pos)                      /*!< CLK_T::PLLCTL: PD Mask                    */
N
N#define CLK_PLLCTL_BP_Pos                (17)                                              /*!< CLK_T::PLLCTL: BP Position                */
N#define CLK_PLLCTL_BP_Msk                (0x1ul << CLK_PLLCTL_BP_Pos)                      /*!< CLK_T::PLLCTL: BP Mask                    */
N
N#define CLK_PLLCTL_OE_Pos                (18)                                              /*!< CLK_T::PLLCTL: OE Position                */
N#define CLK_PLLCTL_OE_Msk                (0x1ul << CLK_PLLCTL_OE_Pos)                      /*!< CLK_T::PLLCTL: OE Mask                    */
N
N#define CLK_PLLCTL_PLLSRC_Pos            (19)                                              /*!< CLK_T::PLLCTL: PLLSRC Position            */
N#define CLK_PLLCTL_PLLSRC_Msk            (0x1ul << CLK_PLLCTL_PLLSRC_Pos)                  /*!< CLK_T::PLLCTL: PLLSRC Mask                */
N
N#define CLK_CLKOCTL_FREQSEL_Pos          (0)                                               /*!< CLK_T::CLKOCTL: FREQSEL Position          */
N#define CLK_CLKOCTL_FREQSEL_Msk          (0xful << CLK_CLKOCTL_FREQSEL_Pos)                /*!< CLK_T::CLKOCTL: FREQSEL Mask              */
N
N#define CLK_CLKOCTL_CLKOEN_Pos           (4)                                               /*!< CLK_T::CLKOCTL: CLKOEN Position           */
N#define CLK_CLKOCTL_CLKOEN_Msk           (0x1ul << CLK_CLKOCTL_CLKOEN_Pos)                 /*!< CLK_T::CLKOCTL: CLKOEN Mask               */
N
N#define CLK_CLKOCTL_DIV1EN_Pos           (5)                                               /*!< CLK_T::CLKOCTL: DIV1EN Position           */
N#define CLK_CLKOCTL_DIV1EN_Msk           (0x1ul << CLK_CLKOCTL_DIV1EN_Pos)                 /*!< CLK_T::CLKOCTL: DIV1EN Mask               */
N
N/**@}*/ /* CLK_CONST */
N/**@}*/ /* end of CLK register group */
N
N
N/*---------------------- Flash Memory Controller -------------------------*/
N/**
N    @addtogroup FMC Flash Memory Controller(FMC)
N    Memory Mapped Structure for FMC Controller
N@{ */
N
Ntypedef struct {
N
N
N    /**
N     * ISPCTL
N     * ===================================================================================================
N     * Offset: 0x00  ISP Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPEN     |ISP Enable Bit (Write Protect)
N     * |        |          |Set this bit to enable the ISP function.
N     * |        |          |0 = ISP function Disabled.
N     * |        |          |1 = ISP function Enabled.
N     * |[1]     |BS        |Boot Select (Write Protect)
N     * |        |          |Set/clear this bit to select next booting from LDROM/APROM, respectively.
N     * |        |          |This bit also functions as chip booting status flag, which can be used to check where chip booted from.
N     * |        |          |This bit is initiated with the inversed value of CBS[1] (CONFIG0[7]) after any reset is happened except CPU reset (RSTS_CPU is 1) or system reset (RSTS_SYS) is happened.
N     * |        |          |0 = Booting from APROM.
N     * |        |          |1 = Booting from LDROM.
N     * |[2]     |SPUEN     |SPROM Update Enable Bit (Write Protect)
N     * |        |          |0 = SPROM cannot be updated.
N     * |        |          |1 = SPROM can be updated.
N     * |[3]     |APUEN     |APROM Update Enable Bit (Write Protect)
N     * |        |          |0 = APROM cannot be updated when the chip runs in APROM.
N     * |        |          |1 = APROM can be updated when the chip runs in APROM.
N     * |[4]     |CFGUEN    |CONFIG Update Enable Bit (Write Protect)
N     * |        |          |0 = CONFIG cannot be updated.
N     * |        |          |1 = CONFIG can be updated.
N     * |[5]     |LDUEN     |LDROM Update Enable (Write Protect)
N     * |        |          |LDROM update enable bit.
N     * |        |          |0 = LDROM cannot be updated.
N     * |        |          |1 = LDROM can be updated.
N     * |[6]     |ISPFF     |ISP Fail Flag (Write Protect)
N     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N     * |        |          |This bit needs to be cleared by writing 1 to it.
N     * |        |          |(1) APROM writes to itself if APUEN is set to 0.
N     * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
N     * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
N     * |        |          |(4) SPROM is erased/programmed if SPUEN is set to 0.
N     * |        |          |(5) SPROM is programmed at SPROM secured mode.
N     * |        |          |(6) Page Erase command at LOCK mode with ICE connection.
N     * |        |          |(7) Erase or Program command at brown-out detected.
N     * |        |          |(8) Destination address is illegal, such as over an available range.
N     * |        |          |(9) Invalid ISP commands.
N    */
N    __IO uint32_t ISPCTL;
X    volatile uint32_t ISPCTL;
N
N    /**
N     * ISPADDR
N     * ===================================================================================================
N     * Offset: 0x04  ISP Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPADDR   |ISP Address
N     * |        |          |The Mini58 series is equipped with embedded flash.
N     * |        |          |ISPADDR[1:0] must be kept 00 for ISP 32-bit operation.
N     * |        |          |and ISPADR[8:0] must be kept all 0 for Vector Page Re-map Command.
N     * |        |          |For CRC32 Checksum Calculation command, this field is the flash starting address for checksum calculation, 512 bytes alignment is necessary for checksum calculation.
N    */
N    __IO uint32_t ISPADDR;
X    volatile uint32_t ISPADDR;
N
N    /**
N     * ISPDAT
N     * ===================================================================================================
N     * Offset: 0x08  ISP Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPDAT    |ISP Data
N     * |        |          |Write data to this register before ISP program operation.
N     * |        |          |Read data from this register after ISP read operation.
N     * |        |          |For Run CRC32 Checksum Calculation command, ISPDAT is the memory size (byte) and 512 bytes alignment.
N     * |        |          |For ISP Read Checksum command, ISPDAT is the checksum result.
N     * |        |          |If ISPDAT = 0x0000_0000, it means that (1) the checksum calculation is in progress, or (2) the memory range for checksum calculation is incorrect.
N    */
N    __IO uint32_t ISPDAT;
X    volatile uint32_t ISPDAT;
N
N    /**
N     * ISPCMD
N     * ===================================================================================================
N     * Offset: 0x0C  ISP Command Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[6:0]   |CMD       |ISP CMD
N     * |        |          |ISP command table is shown below:
N     * |        |          |0x00= FLASH Read.
N     * |        |          |0x04= Read Unique ID.
N     * |        |          |0x0B= Read Company ID.
N     * |        |          |0x0C= Read Device ID.
N     * |        |          |0x0D= Read CRC32 Checksum.
N     * |        |          |0x21= FLASH 32-bit Program.
N     * |        |          |0x22= FLASH Page Erase.
N     * |        |          |0x2D= Run CRC32 Checksum Calculation.
N     * |        |          |0x2E= Vector Remap.
N     * |        |          |The other commands are invalid.
N    */
N    __IO uint32_t ISPCMD;
X    volatile uint32_t ISPCMD;
N
N    /**
N     * ISPTRG
N     * ===================================================================================================
N     * Offset: 0x10  ISP Trigger Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPGO     |ISP Start Trigger (Write Protect)
N     * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.
N     * |        |          |0 = ISP operation is finished.
N     * |        |          |1 = ISP is progressed.
N    */
N    __IO uint32_t ISPTRG;
X    volatile uint32_t ISPTRG;
N
N    /**
N     * DFBA
N     * ===================================================================================================
N     * Offset: 0x14  Data Flash Base Address
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |DFBA      |Data Flash Base Address
N     * |        |          |This register indicates Data Flash start address. It is a read only register.
N     * |        |          |The Data Flash is shared with APROM. the content of this register is loaded from CONFIG1
N     * |        |          |This register is valid when DFEN (CONFIG0[0]) =0 .
N    */
N    __I  uint32_t DFBA;
X    volatile const  uint32_t DFBA;
N
N    /**
N     * FATCTL
N     * ===================================================================================================
N     * Offset: 0x18  Flash Access Time Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[6:4]   |FOM       |Frequency Optimization Mode (Write Protect)
N     * |        |          |The Mini58 series supports adjustable flash access timing to optimize the flash access cycles in different working frequency.
N     * |        |          |0x1 = Frequency <= 24MHz.
N     * |        |          |Others = Frequency <= 50MHz.
N    */
N    __IO uint32_t FATCTL;
X    volatile uint32_t FATCTL;
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVED0[9];
X    volatile const  uint32_t RESERVED0[9];
N    /// @endcond //HIDDEN_SYMBOLS
N
N
N    /**
N     * ISPSTS
N     * ===================================================================================================
N     * Offset: 0x40  ISP Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPBUSY   |ISP BUSY (Read Only)
N     * |        |          |0 = ISP operation is finished.
N     * |        |          |1 = ISP operation is busy.
N     * |[2:1]   |CBS       |Boot Selection Of CONFIG (Read Only)
N     * |        |          |This bit is initiated with the CBS (CONFIG0[7:6]) after any reset is happened except CPU reset (RSTS_CPU is 1) or system reset (RSTS_SYS) is happened.
N     * |        |          |00 = LDROM with IAP mode.
N     * |        |          |01 = LDROM without IAP mode.
N     * |        |          |10 = APROM with IAP mode.
N     * |        |          |11 = APROM without IAP mode.
N     * |[6]     |ISPFF     |ISP Fail Flag (Write Protect)
N     * |        |          |This bit is the mirror of ISPFF (FMC_ISPCTL[6]), it needs to be cleared by writing 1 to FMC_ISPCTL[6] or FMC_ISPSTS[6].
N     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N     * |        |          |(1) APROM writes to itself if APUEN is set to 0.
N     * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
N     * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
N     * |        |          |(4) SPROM is erased/programmed if SPUEN is set to 0.
N     * |        |          |(5) SPROM is programmed at SPROM secured mode.
N     * |        |          |(6) Page Erase command at LOCK mode with ICE connection.
N     * |        |          |(7) Erase or Program command at brown-out detected.
N     * |        |          |(8) Destination address is illegal, such as over an available range.
N     * |        |          |(9) Invalid ISP commands.
N     * |[20:9]  |VECMAP    |Vector Page Mapping Address (Read Only)
N     * |        |          |All access to 0x0000_0000~0x0000_01FF is remapped to the flash memory address {VECMAP[11:0], 9'h000} ~ {VECMAP[11:0], 9'h1FF}
N     * |[31]    |SCODE     |Security Code Active Flag
N     * |        |          |This bit is set to 1 by hardware when detecting SPROM secured code is active at flash initialization, or software writes 1 to this bit to make secured code active; this bit is only cleared by SPROM page erase operation.
N     * |        |          |0 = SPROM secured code is inactive.
N     * |        |          |1 = SPROM secured code is active.
N    */
N    __I  uint32_t ISPSTS;
X    volatile const  uint32_t ISPSTS;
N
N} FMC_T;
N
N/**
N    @addtogroup FMC_CONST FMC Bit Field Definition
N    Constant Definitions for FMC Controller
N@{ */
N
N#define FMC_ISPCTL_ISPEN_Pos             (0)                                               /*!< FMC_T::ISPCTL: ISPEN Position             */
N#define FMC_ISPCTL_ISPEN_Msk             (0x1ul << FMC_ISPCTL_ISPEN_Pos)                   /*!< FMC_T::ISPCTL: ISPEN Mask                 */
N
N#define FMC_ISPCTL_BS_Pos                (1)                                               /*!< FMC_T::ISPCTL: BS Position                */
N#define FMC_ISPCTL_BS_Msk                (0x1ul << FMC_ISPCTL_BS_Pos)                      /*!< FMC_T::ISPCTL: BS Mask                    */
N
N#define FMC_ISPCTL_SPUEN_Pos             (2)                                               /*!< FMC_T::ISPCTL: SPUEN Position             */
N#define FMC_ISPCTL_SPUEN_Msk             (0x1ul << FMC_ISPCTL_SPUEN_Pos)                   /*!< FMC_T::ISPCTL: SPUEN Mask                 */
N
N#define FMC_ISPCTL_APUEN_Pos             (3)                                               /*!< FMC_T::ISPCTL: APUEN Position             */
N#define FMC_ISPCTL_APUEN_Msk             (0x1ul << FMC_ISPCTL_APUEN_Pos)                   /*!< FMC_T::ISPCTL: APUEN Mask                 */
N
N#define FMC_ISPCTL_CFGUEN_Pos            (4)                                               /*!< FMC_T::ISPCTL: CFGUEN Position            */
N#define FMC_ISPCTL_CFGUEN_Msk            (0x1ul << FMC_ISPCTL_CFGUEN_Pos)                  /*!< FMC_T::ISPCTL: CFGUEN Mask                */
N
N#define FMC_ISPCTL_LDUEN_Pos             (5)                                               /*!< FMC_T::ISPCTL: LDUEN Position             */
N#define FMC_ISPCTL_LDUEN_Msk             (0x1ul << FMC_ISPCTL_LDUEN_Pos)                   /*!< FMC_T::ISPCTL: LDUEN Mask                 */
N
N#define FMC_ISPCTL_ISPFF_Pos             (6)                                               /*!< FMC_T::ISPCTL: ISPFF Position             */
N#define FMC_ISPCTL_ISPFF_Msk             (0x1ul << FMC_ISPCTL_ISPFF_Pos)                   /*!< FMC_T::ISPCTL: ISPFF Mask                 */
N
N#define FMC_ISPADDR_ISPADDR_Pos          (0)                                               /*!< FMC_T::ISPADDR: ISPADDR Position          */
N#define FMC_ISPADDR_ISPADDR_Msk          (0xfffffffful << FMC_ISPADDR_ISPADDR_Pos)         /*!< FMC_T::ISPADDR: ISPADDR Mask              */
N
N#define FMC_ISPDAT_ISPDAT_Pos            (0)                                               /*!< FMC_T::ISPDAT: ISPDAT Position            */
N#define FMC_ISPDAT_ISPDAT_Msk            (0xfffffffful << FMC_ISPDAT_ISPDAT_Pos)           /*!< FMC_T::ISPDAT: ISPDAT Mask                */
N
N#define FMC_ISPCMD_CMD_Pos               (0)                                               /*!< FMC_T::ISPCMD: CMD Position               */
N#define FMC_ISPCMD_CMD_Msk               (0x7ful << FMC_ISPCMD_CMD_Pos)                    /*!< FMC_T::ISPCMD: CMD Mask                   */
N
N#define FMC_ISPTRG_ISPGO_Pos             (0)                                               /*!< FMC_T::ISPTRG: ISPGO Position             */
N#define FMC_ISPTRG_ISPGO_Msk             (0x1ul << FMC_ISPTRG_ISPGO_Pos)                   /*!< FMC_T::ISPTRG: ISPGO Mask                 */
N
N#define FMC_DFBA_DFBA_Pos                (0)                                               /*!< FMC_T::DFBA: DFBA Position                */
N#define FMC_DFBA_DFBA_Msk                (0xfffffffful << FMC_DFBA_DFBA_Pos)               /*!< FMC_T::DFBA: DFBA Mask                    */
N
N#define FMC_FATCTL_FOM_Pos               (4)                                               /*!< FMC_T::FATCTL: FOM Position               */
N#define FMC_FATCTL_FOM_Msk               (0x7ul << FMC_FATCTL_FOM_Pos)                     /*!< FMC_T::FATCTL: FOM Mask                   */
N
N#define FMC_ISPSTS_ISPBUSY_Pos           (0)                                               /*!< FMC_T::ISPSTS: ISPBUSY Position           */
N#define FMC_ISPSTS_ISPBUSY_Msk           (0x1ul << FMC_ISPSTS_ISPBUSY_Pos)                 /*!< FMC_T::ISPSTS: ISPBUSY Mask               */
N
N#define FMC_ISPSTS_CBS_Pos               (1)                                               /*!< FMC_T::ISPSTS: CBS Position               */
N#define FMC_ISPSTS_CBS_Msk               (0x3ul << FMC_ISPSTS_CBS_Pos)                     /*!< FMC_T::ISPSTS: CBS Mask                   */
N
N#define FMC_ISPSTS_ISPFF_Pos             (6)                                               /*!< FMC_T::ISPSTS: ISPFF Position             */
N#define FMC_ISPSTS_ISPFF_Msk             (0x1ul << FMC_ISPSTS_ISPFF_Pos)                   /*!< FMC_T::ISPSTS: ISPFF Mask                 */
N
N#define FMC_ISPSTS_VECMAP_Pos            (9)                                               /*!< FMC_T::ISPSTS: VECMAP Position            */
N#define FMC_ISPSTS_VECMAP_Msk            (0xffful << FMC_ISPSTS_VECMAP_Pos)                /*!< FMC_T::ISPSTS: VECMAP Mask                */
N
N#define FMC_ISPSTS_SCODE_Pos             (31)                                              /*!< FMC_T::ISPSTS: SCODE Position             */
N#define FMC_ISPSTS_SCODE_Msk             (0x1ul << FMC_ISPSTS_SCODE_Pos)                   /*!< FMC_T::ISPSTS: SCODE Mask                 */
N
N/**@}*/ /* FMC_CONST */
N/**@}*/ /* end of FMC register group */
N
N
N/*---------------------- General Purpose Input/Output Controller -------------------------*/
N/**
N    @addtogroup GP General Purpose Input/Output Controller(GP)
N    Memory Mapped Structure for GP Controller
N@{ */
N
Ntypedef struct {
N
N
N    /**
N     * MODE
N     * ===================================================================================================
N     * Offset: 0x00  P0 I/O Mode Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |MODE0     |Port 0-5 I/O Pin[N] Mode Control
N     * |        |          |Determine each I/O mode of Px.n pins.
N     * |        |          |00 = Px.n is in Input mode.
N     * |        |          |01 = Px.n is in Push-pull Output mode.
N     * |        |          |10 = Px.n is in Open-drain Output mode.
N     * |        |          |11 = Px.n is in Quasi-bidirectional mode.
N     * |        |          |Note1: The initial value of this field is defined by CIOINI (Config0[10]).
N     * |        |          |If CIOINI is set to 0, the default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip powered on.
N     * |        |          |If CIOINI is set to 1, the default value is 0x0000_0000 and all pins will be
N     * |        |          |input mode after chip powered on.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[3:2]   |MODE1     |Port 0-5 I/O Pin[N] Mode Control
N     * |        |          |Determine each I/O mode of Px.n pins.
N     * |        |          |00 = Px.n is in Input mode.
N     * |        |          |01 = Px.n is in Push-pull Output mode.
N     * |        |          |10 = Px.n is in Open-drain Output mode.
N     * |        |          |11 = Px.n is in Quasi-bidirectional mode.
N     * |        |          |Note1: The initial value of this field is defined by CIOINI (Config0[10]).
N     * |        |          |If CIOINI is set to 0, the default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip powered on.
N     * |        |          |If CIOINI is set to 1, the default value is 0x0000_0000 and all pins will be
N     * |        |          |input mode after chip powered on.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[5:4]   |MODE2     |Port 0-5 I/O Pin[N] Mode Control
N     * |        |          |Determine each I/O mode of Px.n pins.
N     * |        |          |00 = Px.n is in Input mode.
N     * |        |          |01 = Px.n is in Push-pull Output mode.
N     * |        |          |10 = Px.n is in Open-drain Output mode.
N     * |        |          |11 = Px.n is in Quasi-bidirectional mode.
N     * |        |          |Note1: The initial value of this field is defined by CIOINI (Config0[10]).
N     * |        |          |If CIOINI is set to 0, the default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip powered on.
N     * |        |          |If CIOINI is set to 1, the default value is 0x0000_0000 and all pins will be
N     * |        |          |input mode after chip powered on.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[7:6]   |MODE3     |Port 0-5 I/O Pin[N] Mode Control
N     * |        |          |Determine each I/O mode of Px.n pins.
N     * |        |          |00 = Px.n is in Input mode.
N     * |        |          |01 = Px.n is in Push-pull Output mode.
N     * |        |          |10 = Px.n is in Open-drain Output mode.
N     * |        |          |11 = Px.n is in Quasi-bidirectional mode.
N     * |        |          |Note1: The initial value of this field is defined by CIOINI (Config0[10]).
N     * |        |          |If CIOINI is set to 0, the default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip powered on.
N     * |        |          |If CIOINI is set to 1, the default value is 0x0000_0000 and all pins will be
N     * |        |          |input mode after chip powered on.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[9:8]   |MODE4     |Port 0-5 I/O Pin[N] Mode Control
N     * |        |          |Determine each I/O mode of Px.n pins.
N     * |        |          |00 = Px.n is in Input mode.
N     * |        |          |01 = Px.n is in Push-pull Output mode.
N     * |        |          |10 = Px.n is in Open-drain Output mode.
N     * |        |          |11 = Px.n is in Quasi-bidirectional mode.
N     * |        |          |Note1: The initial value of this field is defined by CIOINI (Config0[10]).
N     * |        |          |If CIOINI is set to 0, the default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip powered on.
N     * |        |          |If CIOINI is set to 1, the default value is 0x0000_0000 and all pins will be
N     * |        |          |input mode after chip powered on.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[11:10] |MODE5     |Port 0-5 I/O Pin[N] Mode Control
N     * |        |          |Determine each I/O mode of Px.n pins.
N     * |        |          |00 = Px.n is in Input mode.
N     * |        |          |01 = Px.n is in Push-pull Output mode.
N     * |        |          |10 = Px.n is in Open-drain Output mode.
N     * |        |          |11 = Px.n is in Quasi-bidirectional mode.
N     * |        |          |Note1: The initial value of this field is defined by CIOINI (Config0[10]).
N     * |        |          |If CIOINI is set to 0, the default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip powered on.
N     * |        |          |If CIOINI is set to 1, the default value is 0x0000_0000 and all pins will be
N     * |        |          |input mode after chip powered on.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[13:12] |MODE6     |Port 0-5 I/O Pin[N] Mode Control
N     * |        |          |Determine each I/O mode of Px.n pins.
N     * |        |          |00 = Px.n is in Input mode.
N     * |        |          |01 = Px.n is in Push-pull Output mode.
N     * |        |          |10 = Px.n is in Open-drain Output mode.
N     * |        |          |11 = Px.n is in Quasi-bidirectional mode.
N     * |        |          |Note1: The initial value of this field is defined by CIOINI (Config0[10]).
N     * |        |          |If CIOINI is set to 0, the default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip powered on.
N     * |        |          |If CIOINI is set to 1, the default value is 0x0000_0000 and all pins will be
N     * |        |          |input mode after chip powered on.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[15:14] |MODE7     |Port 0-5 I/O Pin[N] Mode Control
N     * |        |          |Determine each I/O mode of Px.n pins.
N     * |        |          |00 = Px.n is in Input mode.
N     * |        |          |01 = Px.n is in Push-pull Output mode.
N     * |        |          |10 = Px.n is in Open-drain Output mode.
N     * |        |          |11 = Px.n is in Quasi-bidirectional mode.
N     * |        |          |Note1: The initial value of this field is defined by CIOINI (Config0[10]).
N     * |        |          |If CIOINI is set to 0, the default value is 0x0000_FFFF and all pins will be quasi-bidirectional mode after chip powered on.
N     * |        |          |If CIOINI is set to 1, the default value is 0x0000_0000 and all pins will be
N     * |        |          |input mode after chip powered on.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N    */
N    __IO uint32_t MODE;
X    volatile uint32_t MODE;
N
N    /**
N     * DINOFF
N     * ===================================================================================================
N     * Offset: 0x04  P0 Digital Input Path Disable Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[16]    |DINOFF0   |Port 0-5 Pin[N] Digital Input Path Disable Control
N     * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.
N     * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
N     * |        |          |0 = Px.n digital input path Enabled.
N     * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[17]    |DINOFF1   |Port 0-5 Pin[N] Digital Input Path Disable Control
N     * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.
N     * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
N     * |        |          |0 = Px.n digital input path Enabled.
N     * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[18]    |DINOFF2   |Port 0-5 Pin[N] Digital Input Path Disable Control
N     * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.
N     * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
N     * |        |          |0 = Px.n digital input path Enabled.
N     * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[19]    |DINOFF3   |Port 0-5 Pin[N] Digital Input Path Disable Control
N     * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.
N     * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
N     * |        |          |0 = Px.n digital input path Enabled.
N     * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[20]    |DINOFF4   |Port 0-5 Pin[N] Digital Input Path Disable Control
N     * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.
N     * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
N     * |        |          |0 = Px.n digital input path Enabled.
N     * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[21]    |DINOFF5   |Port 0-5 Pin[N] Digital Input Path Disable Control
N     * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.
N     * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
N     * |        |          |0 = Px.n digital input path Enabled.
N     * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[22]    |DINOFF6   |Port 0-5 Pin[N] Digital Input Path Disable Control
N     * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.
N     * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
N     * |        |          |0 = Px.n digital input path Enabled.
N     * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[23]    |DINOFF7   |Port 0-5 Pin[N] Digital Input Path Disable Control
N     * |        |          |Each of these bits is used to control if the digital input path of corresponding Px.n pin is disabled.
N     * |        |          |If input is analog signal, users can disable Px.n digital input path to avoid input current leakage.
N     * |        |          |0 = Px.n digital input path Enabled.
N     * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N    */
N    __IO uint32_t DINOFF;
X    volatile uint32_t DINOFF;
N
N    /**
N     * DOUT
N     * ===================================================================================================
N     * Offset: 0x08  P0 Data Output Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DOUT0     |Port 0-5 Pin[N] Output Value
N     * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[1]     |DOUT1     |Port 0-5 Pin[N] Output Value
N     * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[2]     |DOUT2     |Port 0-5 Pin[N] Output Value
N     * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[3]     |DOUT3     |Port 0-5 Pin[N] Output Value
N     * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[4]     |DOUT4     |Port 0-5 Pin[N] Output Value
N     * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[5]     |DOUT5     |Port 0-5 Pin[N] Output Value
N     * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[6]     |DOUT6     |Port 0-5 Pin[N] Output Value
N     * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[7]     |DOUT7     |Port 0-5 Pin[N] Output Value
N     * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N    */
N    __IO uint32_t DOUT;
X    volatile uint32_t DOUT;
N
N    /**
N     * DATMSK
N     * ===================================================================================================
N     * Offset: 0x0C  P0 Data Output Write Mask
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DATMSK0   |Port 0-5 Pin[N] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.
N     * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.
N     * |        |          |If the write signal is masked, writing data to the protect bit is ignore.
N     * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
N     * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
N     * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[1]     |DATMSK1   |Port 0-5 Pin[N] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.
N     * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.
N     * |        |          |If the write signal is masked, writing data to the protect bit is ignore.
N     * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
N     * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
N     * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[2]     |DATMSK2   |Port 0-5 Pin[N] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.
N     * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.
N     * |        |          |If the write signal is masked, writing data to the protect bit is ignore.
N     * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
N     * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
N     * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[3]     |DATMSK3   |Port 0-5 Pin[N] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.
N     * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.
N     * |        |          |If the write signal is masked, writing data to the protect bit is ignore.
N     * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
N     * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
N     * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[4]     |DATMSK4   |Port 0-5 Pin[N] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.
N     * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.
N     * |        |          |If the write signal is masked, writing data to the protect bit is ignore.
N     * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
N     * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
N     * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[5]     |DATMSK5   |Port 0-5 Pin[N] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.
N     * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.
N     * |        |          |If the write signal is masked, writing data to the protect bit is ignore.
N     * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
N     * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
N     * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[6]     |DATMSK6   |Port 0-5 Pin[N] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.
N     * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.
N     * |        |          |If the write signal is masked, writing data to the protect bit is ignore.
N     * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
N     * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
N     * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[7]     |DATMSK7   |Port 0-5 Pin[N] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding DOUT (Px_DOUT[n]) bit.
N     * |        |          |When the DATMSK (Px_DATMSK[n]) bit is set to 1, the corresponding DOUT (Px_DOUT[n]) bit is protected.
N     * |        |          |If the write signal is masked, writing data to the protect bit is ignore.
N     * |        |          |0 = Corresponding DOUT (Px_DOUT[n]) bit can be updated.
N     * |        |          |1 = Corresponding DOUT (Px_DOUT[n]) bit protected.
N     * |        |          |Note1: This function only protects the corresponding DOUT (Px_DOUT[n]) bit, and will not protect the corresponding PDIO (Pxn_PDIO[0]) bit.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N    */
N    __IO uint32_t DATMSK;
X    volatile uint32_t DATMSK;
N
N    /**
N     * PIN
N     * ===================================================================================================
N     * Offset: 0x10  P0 Pin Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PIN0      |Port 0-5 Pin[N] Pin Value
N     * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin.
N     * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[1]     |PIN1      |Port 0-5 Pin[N] Pin Value
N     * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin.
N     * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[2]     |PIN2      |Port 0-5 Pin[N] Pin Value
N     * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin.
N     * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[3]     |PIN3      |Port 0-5 Pin[N] Pin Value
N     * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin.
N     * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[4]     |PIN4      |Port 0-5 Pin[N] Pin Value
N     * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin.
N     * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[5]     |PIN5      |Port 0-5 Pin[N] Pin Value
N     * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin.
N     * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[6]     |PIN6      |Port 0-5 Pin[N] Pin Value
N     * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin.
N     * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[7]     |PIN7      |Port 0-5 Pin[N] Pin Value
N     * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin.
N     * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N    */
N    __I  uint32_t PIN;
X    volatile const  uint32_t PIN;
N
N    /**
N     * DBEN
N     * ===================================================================================================
N     * Offset: 0x14  P0 De-bounce Enable Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DBEN0     |Port 0-5 Pin[N] Input Signal De-bounce Enable Bit
N     * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.
N     * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N     * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
N     * |        |          |0 = Px.n de-bounce function Disabled.
N     * |        |          |1 = Px.n de-bounce function Enabled.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignore.
N     * |        |          |Note1: If Px.n pin is chosen as Power-down wake-up source, user should be disable the de-bounce function before entering Power-down mode to avoid the second interrupt event occurred after system waken up which caused by Px.n de-bounce function.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[1]     |DBEN1     |Port 0-5 Pin[N] Input Signal De-bounce Enable Bit
N     * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.
N     * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N     * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
N     * |        |          |0 = Px.n de-bounce function Disabled.
N     * |        |          |1 = Px.n de-bounce function Enabled.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignore.
N     * |        |          |Note1: If Px.n pin is chosen as Power-down wake-up source, user should be disable the de-bounce function before entering Power-down mode to avoid the second interrupt event occurred after system waken up which caused by Px.n de-bounce function.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[2]     |DBEN2     |Port 0-5 Pin[N] Input Signal De-bounce Enable Bit
N     * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.
N     * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N     * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
N     * |        |          |0 = Px.n de-bounce function Disabled.
N     * |        |          |1 = Px.n de-bounce function Enabled.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignore.
N     * |        |          |Note1: If Px.n pin is chosen as Power-down wake-up source, user should be disable the de-bounce function before entering Power-down mode to avoid the second interrupt event occurred after system waken up which caused by Px.n de-bounce function.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[3]     |DBEN3     |Port 0-5 Pin[N] Input Signal De-bounce Enable Bit
N     * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.
N     * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N     * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
N     * |        |          |0 = Px.n de-bounce function Disabled.
N     * |        |          |1 = Px.n de-bounce function Enabled.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignore.
N     * |        |          |Note1: If Px.n pin is chosen as Power-down wake-up source, user should be disable the de-bounce function before entering Power-down mode to avoid the second interrupt event occurred after system waken up which caused by Px.n de-bounce function.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[4]     |DBEN4     |Port 0-5 Pin[N] Input Signal De-bounce Enable Bit
N     * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.
N     * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N     * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
N     * |        |          |0 = Px.n de-bounce function Disabled.
N     * |        |          |1 = Px.n de-bounce function Enabled.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignore.
N     * |        |          |Note1: If Px.n pin is chosen as Power-down wake-up source, user should be disable the de-bounce function before entering Power-down mode to avoid the second interrupt event occurred after system waken up which caused by Px.n de-bounce function.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[5]     |DBEN5     |Port 0-5 Pin[N] Input Signal De-bounce Enable Bit
N     * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.
N     * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N     * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
N     * |        |          |0 = Px.n de-bounce function Disabled.
N     * |        |          |1 = Px.n de-bounce function Enabled.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignore.
N     * |        |          |Note1: If Px.n pin is chosen as Power-down wake-up source, user should be disable the de-bounce function before entering Power-down mode to avoid the second interrupt event occurred after system waken up which caused by Px.n de-bounce function.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[6]     |DBEN6     |Port 0-5 Pin[N] Input Signal De-bounce Enable Bit
N     * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.
N     * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N     * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
N     * |        |          |0 = Px.n de-bounce function Disabled.
N     * |        |          |1 = Px.n de-bounce function Enabled.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignore.
N     * |        |          |Note1: If Px.n pin is chosen as Power-down wake-up source, user should be disable the de-bounce function before entering Power-down mode to avoid the second interrupt event occurred after system waken up which caused by Px.n de-bounce function.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[7]     |DBEN7     |Port 0-5 Pin[N] Input Signal De-bounce Enable Bit
N     * |        |          |The DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.
N     * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N     * |        |          |The de-bounce clock source is controlled by DBCLKSRC (GPIO_DBCTL [4]), one de-bounce sample cycle period is controlled by DBCLKSEL (GPIO_DBCTL [3:0]).
N     * |        |          |0 = Px.n de-bounce function Disabled.
N     * |        |          |1 = Px.n de-bounce function Enabled.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignore.
N     * |        |          |Note1: If Px.n pin is chosen as Power-down wake-up source, user should be disable the de-bounce function before entering Power-down mode to avoid the second interrupt event occurred after system waken up which caused by Px.n de-bounce function.
N     * |        |          |Note2:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N    */
N    __IO uint32_t DBEN;
X    volatile uint32_t DBEN;
N
N    /**
N     * INTTYPE
N     * ===================================================================================================
N     * Offset: 0x18  P0 Interrupt Mode Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TYPE0     |Port 0-5 Pin[N] Edge Or Level Detection Interrupt Trigger Type Control
N     * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.
N     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
N     * |        |          |0 = Edge trigger interrupt.
N     * |        |          |1 = Level trigger interrupt.
N     * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).
N     * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignore.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[1]     |TYPE1     |Port 0-5 Pin[N] Edge Or Level Detection Interrupt Trigger Type Control
N     * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.
N     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
N     * |        |          |0 = Edge trigger interrupt.
N     * |        |          |1 = Level trigger interrupt.
N     * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).
N     * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignore.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[2]     |TYPE2     |Port 0-5 Pin[N] Edge Or Level Detection Interrupt Trigger Type Control
N     * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.
N     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
N     * |        |          |0 = Edge trigger interrupt.
N     * |        |          |1 = Level trigger interrupt.
N     * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).
N     * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignore.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[3]     |TYPE3     |Port 0-5 Pin[N] Edge Or Level Detection Interrupt Trigger Type Control
N     * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.
N     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
N     * |        |          |0 = Edge trigger interrupt.
N     * |        |          |1 = Level trigger interrupt.
N     * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).
N     * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignore.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[4]     |TYPE4     |Port 0-5 Pin[N] Edge Or Level Detection Interrupt Trigger Type Control
N     * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.
N     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
N     * |        |          |0 = Edge trigger interrupt.
N     * |        |          |1 = Level trigger interrupt.
N     * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).
N     * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignore.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[5]     |TYPE5     |Port 0-5 Pin[N] Edge Or Level Detection Interrupt Trigger Type Control
N     * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.
N     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
N     * |        |          |0 = Edge trigger interrupt.
N     * |        |          |1 = Level trigger interrupt.
N     * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).
N     * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignore.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[6]     |TYPE6     |Port 0-5 Pin[N] Edge Or Level Detection Interrupt Trigger Type Control
N     * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.
N     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
N     * |        |          |0 = Edge trigger interrupt.
N     * |        |          |1 = Level trigger interrupt.
N     * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).
N     * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignore.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[7]     |TYPE7     |Port 0-5 Pin[N] Edge Or Level Detection Interrupt Trigger Type Control
N     * |        |          |TYPE (Px_INTTYPE[n]) bit is used to control the triggered interrupt is by level trigger or by edge trigger.
N     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
N     * |        |          |0 = Edge trigger interrupt.
N     * |        |          |1 = Level trigger interrupt.
N     * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]).
N     * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignore.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N    */
N    __IO uint32_t INTTYPE;
X    volatile uint32_t INTTYPE;
N
N    /**
N     * INTEN
N     * ===================================================================================================
N     * Offset: 0x1C  P0 Interrupt Enable Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |FLIEN0    |Port 0-5 Pin[N] Falling Edge Or Low Level Interrupt Trigger Type Enable Bit
N     * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1:
N     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
N     * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
N     * |        |          |0 = Px.n level low or high to low interrupt Disabled.
N     * |        |          |1 = Px.n level low or high to low interrupt Enabled.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[1]     |FLIEN1    |Port 0-5 Pin[N] Falling Edge Or Low Level Interrupt Trigger Type Enable Bit
N     * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1:
N     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
N     * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
N     * |        |          |0 = Px.n level low or high to low interrupt Disabled.
N     * |        |          |1 = Px.n level low or high to low interrupt Enabled.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[2]     |FLIEN2    |Port 0-5 Pin[N] Falling Edge Or Low Level Interrupt Trigger Type Enable Bit
N     * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1:
N     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
N     * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
N     * |        |          |0 = Px.n level low or high to low interrupt Disabled.
N     * |        |          |1 = Px.n level low or high to low interrupt Enabled.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[3]     |FLIEN3    |Port 0-5 Pin[N] Falling Edge Or Low Level Interrupt Trigger Type Enable Bit
N     * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1:
N     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
N     * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
N     * |        |          |0 = Px.n level low or high to low interrupt Disabled.
N     * |        |          |1 = Px.n level low or high to low interrupt Enabled.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[4]     |FLIEN4    |Port 0-5 Pin[N] Falling Edge Or Low Level Interrupt Trigger Type Enable Bit
N     * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1:
N     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
N     * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
N     * |        |          |0 = Px.n level low or high to low interrupt Disabled.
N     * |        |          |1 = Px.n level low or high to low interrupt Enabled.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[5]     |FLIEN5    |Port 0-5 Pin[N] Falling Edge Or Low Level Interrupt Trigger Type Enable Bit
N     * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1:
N     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
N     * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
N     * |        |          |0 = Px.n level low or high to low interrupt Disabled.
N     * |        |          |1 = Px.n level low or high to low interrupt Enabled.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[6]     |FLIEN6    |Port 0-5 Pin[N] Falling Edge Or Low Level Interrupt Trigger Type Enable Bit
N     * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1:
N     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
N     * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
N     * |        |          |0 = Px.n level low or high to low interrupt Disabled.
N     * |        |          |1 = Px.n level low or high to low interrupt Enabled.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[7]     |FLIEN7    |Port 0-5 Pin[N] Falling Edge Or Low Level Interrupt Trigger Type Enable Bit
N     * |        |          |The FLIEN (Px_INTEN[n]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the FLIEN (Px_INTEN[n]) bit to 1function
N     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
N     * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
N     * |        |          |0 = Px.n level low or high to low interrupt Disabled.
N     * |        |          |1 = Px.n level low or high to low interrupt Enabled.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[16]    |RHIEN0    |Port 0-5 Pin[N] Rising Edge Or High Level Interrupt Trigger Type Enable Bit
N     * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1:
N     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
N     * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
N     * |        |          |0 = Px.n level high or low to high interrupt Disabled.
N     * |        |          |1 = Px.n level high or low to high interrupt Enabled.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[17]    |RHIEN1    |Port 0-5 Pin[N] Rising Edge Or High Level Interrupt Trigger Type Enable Bit
N     * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1:
N     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
N     * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
N     * |        |          |0 = Px.n level high or low to high interrupt Disabled.
N     * |        |          |1 = Px.n level high or low to high interrupt Enabled.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[18]    |RHIEN2    |Port 0-5 Pin[N] Rising Edge Or High Level Interrupt Trigger Type Enable Bit
N     * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1:
N     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
N     * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
N     * |        |          |0 = Px.n level high or low to high interrupt Disabled.
N     * |        |          |1 = Px.n level high or low to high interrupt Enabled.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[19]    |RHIEN3    |Port 0-5 Pin[N] Rising Edge Or High Level Interrupt Trigger Type Enable Bit
N     * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1:
N     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
N     * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
N     * |        |          |0 = Px.n level high or low to high interrupt Disabled.
N     * |        |          |1 = Px.n level high or low to high interrupt Enabled.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[20]    |RHIEN4    |Port 0-5 Pin[N] Rising Edge Or High Level Interrupt Trigger Type Enable Bit
N     * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1:
N     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
N     * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
N     * |        |          |0 = Px.n level high or low to high interrupt Disabled.
N     * |        |          |1 = Px.n level high or low to high interrupt Enabled.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[21]    |RHIEN5    |Port 0-5 Pin[N] Rising Edge Or High Level Interrupt Trigger Type Enable Bit
N     * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1:
N     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
N     * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
N     * |        |          |0 = Px.n level high or low to high interrupt Disabled.
N     * |        |          |1 = Px.n level high or low to high interrupt Enabled.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[22]    |RHIEN6    |Port 0-5 Pin[N] Rising Edge Or High Level Interrupt Trigger Type Enable Bit
N     * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1:
N     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
N     * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
N     * |        |          |0 = Px.n level high or low to high interrupt Disabled.
N     * |        |          |1 = Px.n level high or low to high interrupt Enabled.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[23]    |RHIEN7    |Port 0-5 Pin[N] Rising Edge Or High Level Interrupt Trigger Type Enable Bit
N     * |        |          |The RHIEN (Px_INTEN[n+16]) bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the RHIEN (Px_INTEN[n+16]) bit to 1:
N     * |        |          |If the interrupt is level trigger (TYPE (Px_INTTYPE[n]) bit is set to 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
N     * |        |          |If the interrupt is edge trigger (TYPE (Px_INTTYPE[n]) bit is set to 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
N     * |        |          |0 = Px.n level high or low to high interrupt Disabled.
N     * |        |          |1 = Px.n level high or low to high interrupt Enabled.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N    */
N    __IO uint32_t INTEN;
X    volatile uint32_t INTEN;
N
N    /**
N     * INTSRC
N     * ===================================================================================================
N     * Offset: 0x20  P0 Interrupt Source Flag
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |INTSRC0   |Port 0-5 Pin[N] Interrupt Source Flag
N     * |        |          |Write Operation:
N     * |        |          |0 = No action.
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |Read Operation:
N     * |        |          |0 = No interrupt at Px.n.
N     * |        |          |1 = Px.n generates an interrupt.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[1]     |INTSRC1   |Port 0-5 Pin[N] Interrupt Source Flag
N     * |        |          |Write Operation:
N     * |        |          |0 = No action.
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |Read Operation:
N     * |        |          |0 = No interrupt at Px.n.
N     * |        |          |1 = Px.n generates an interrupt.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[2]     |INTSRC2   |Port 0-5 Pin[N] Interrupt Source Flag
N     * |        |          |Write Operation:
N     * |        |          |0 = No action.
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |Read Operation:
N     * |        |          |0 = No interrupt at Px.n.
N     * |        |          |1 = Px.n generates an interrupt.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[3]     |INTSRC3   |Port 0-5 Pin[N] Interrupt Source Flag
N     * |        |          |Write Operation:
N     * |        |          |0 = No action.
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |Read Operation:
N     * |        |          |0 = No interrupt at Px.n.
N     * |        |          |1 = Px.n generates an interrupt.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[4]     |INTSRC4   |Port 0-5 Pin[N] Interrupt Source Flag
N     * |        |          |Write Operation:
N     * |        |          |0 = No action.
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |Read Operation:
N     * |        |          |0 = No interrupt at Px.n.
N     * |        |          |1 = Px.n generates an interrupt.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[5]     |INTSRC5   |Port 0-5 Pin[N] Interrupt Source Flag
N     * |        |          |Write Operation:
N     * |        |          |0 = No action.
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |Read Operation:
N     * |        |          |0 = No interrupt at Px.n.
N     * |        |          |1 = Px.n generates an interrupt.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[6]     |INTSRC6   |Port 0-5 Pin[N] Interrupt Source Flag
N     * |        |          |Write Operation:
N     * |        |          |0 = No action.
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |Read Operation:
N     * |        |          |0 = No interrupt at Px.n.
N     * |        |          |1 = Px.n generates an interrupt.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[7]     |INTSRC7   |Port 0-5 Pin[N] Interrupt Source Flag
N     * |        |          |Write Operation:
N     * |        |          |0 = No action.
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |Read Operation:
N     * |        |          |0 = No interrupt at Px.n.
N     * |        |          |1 = Px.n generates an interrupt.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[8]     |INTSRC8   |Port 0-5 Pin[N] Interrupt Source Flag
N     * |        |          |Write Operation:
N     * |        |          |0 = No action.
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |Read Operation:
N     * |        |          |0 = No interrupt at Px.n.
N     * |        |          |1 = Px.n generates an interrupt.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[9]     |INTSRC9   |Port 0-5 Pin[N] Interrupt Source Flag
N     * |        |          |Write Operation:
N     * |        |          |0 = No action.
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |Read Operation:
N     * |        |          |0 = No interrupt at Px.n.
N     * |        |          |1 = Px.n generates an interrupt.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[10]    |INTSRC10  |Port 0-5 Pin[N] Interrupt Source Flag
N     * |        |          |Write Operation:
N     * |        |          |0 = No action.
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |Read Operation:
N     * |        |          |0 = No interrupt at Px.n.
N     * |        |          |1 = Px.n generates an interrupt.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[11]    |INTSRC11  |Port 0-5 Pin[N] Interrupt Source Flag
N     * |        |          |Write Operation:
N     * |        |          |0 = No action.
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |Read Operation:
N     * |        |          |0 = No interrupt at Px.n.
N     * |        |          |1 = Px.n generates an interrupt.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[12]    |INTSRC12  |Port 0-5 Pin[N] Interrupt Source Flag
N     * |        |          |Write Operation:
N     * |        |          |0 = No action.
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |Read Operation:
N     * |        |          |0 = No interrupt at Px.n.
N     * |        |          |1 = Px.n generates an interrupt.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[13]    |INTSRC13  |Port 0-5 Pin[N] Interrupt Source Flag
N     * |        |          |Write Operation:
N     * |        |          |0 = No action.
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |Read Operation:
N     * |        |          |0 = No interrupt at Px.n.
N     * |        |          |1 = Px.n generates an interrupt.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[14]    |INTSRC14  |Port 0-5 Pin[N] Interrupt Source Flag
N     * |        |          |Write Operation:
N     * |        |          |0 = No action.
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |Read Operation:
N     * |        |          |0 = No interrupt at Px.n.
N     * |        |          |1 = Px.n generates an interrupt.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N     * |[15]    |INTSRC15  |Port 0-5 Pin[N] Interrupt Source Flag
N     * |        |          |Write Operation:
N     * |        |          |0 = No action.
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |Read Operation:
N     * |        |          |0 = No interrupt at Px.n.
N     * |        |          |1 = Px.n generates an interrupt.
N     * |        |          |Note:
N     * |        |          |Max. n=7 for port 0, n=2, n=3 are reserved.
N     * |        |          |Max. n=7 for port 1, n=1, n=6, n=7 are reserved.
N     * |        |          |Max. n=7 for port 2, n=0, n=1, n=7 are reserved.
N     * |        |          |Max. n=7 for port 3, n=3, n=7 are reserved.
N     * |        |          |Max. n=7 for port 4, n=0,.5 are reserved.
N     * |        |          |Max. n=7 for port 5, n=6, n=7 are reserved.
N    */
N    __IO uint32_t INTSRC;
X    volatile uint32_t INTSRC;
N
N} GPIO_T;
N
Ntypedef struct {
N
N    /**
N     * DBCTL
N     * ===================================================================================================
N     * Offset: 0x180  De-bounce Cycle Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |DBCLKSEL  |De-bounce Sampling Cycle Selection
N     * |        |          |0000 = Sample interrupt input once per 1 clock.
N     * |        |          |0001 = Sample interrupt input once per 2 clocks.
N     * |        |          |0010 = Sample interrupt input once per 4 clocks.
N     * |        |          |0011 = Sample interrupt input once per 8 clocks.
N     * |        |          |0100 = Sample interrupt input once per 16 clocks.
N     * |        |          |0101 = Sample interrupt input once per 32 clocks.
N     * |        |          |0110 = Sample interrupt input once per 64 clocks.
N     * |        |          |0111 = Sample interrupt input once per 128 clocks.
N     * |        |          |1000 = Sample interrupt input once per 256 clocks.
N     * |        |          |1001 = Sample interrupt input once per 2*256 clocks.
N     * |        |          |1010 = Sample interrupt input once per 4*256 clocks.
N     * |        |          |1011 = Sample interrupt input once per 8*256 clocks.
N     * |        |          |1100 = Sample interrupt input once per 16*256 clocks.
N     * |        |          |1101 = Sample interrupt input once per 32*256 clocks.
N     * |        |          |1110 = Sample interrupt input once per 64*256 clocks.
N     * |        |          |1111 = Sample interrupt input once per 128*256 clocks.
N     * |[4]     |DBCLKSRC  |De-bounce Counter Clock Source Selection
N     * |        |          |0 = De-bounce counter clock source is HCLK.
N     * |        |          |1 = De-bounce counter clock source is 10 kHz internal low speed RC oscillator (LIRC).
N     * |[5]     |ICLKON    |Interrupt Clock On Mode
N     * |        |          |0 = Edge detection circuit is active only if I/O pin corresponding RHIEN (Px_INTEN[n+16])/FLIEN (Px_INTEN[n]) bit is set to 1.
N     * |        |          |1 = All I/O pins edge detection circuit is always active after reset.
N     * |        |          |Note: It is recommended to disable this bit to save system power if no special application concern.
N    */
N    __IO uint32_t DBCTL;
X    volatile uint32_t DBCTL;
N
N} GPIO_DB_T;
N
N
N/**
N    @addtogroup GP_CONST GP Bit Field Definition
N    Constant Definitions for GP Controller
N@{ */
N
N#define GP_MODE_MODE0_Pos                (0)                                               /*!< GP_T::MODE: MODE0 Position                */
N#define GP_MODE_MODE0_Msk                (0x3ul << GP_MODE_MODE0_Pos)                      /*!< GP_T::MODE: MODE0 Mask                    */
N
N#define GP_MODE_MODE1_Pos                (2)                                               /*!< GP_T::MODE: MODE1 Position                */
N#define GP_MODE_MODE1_Msk                (0x3ul << GP_MODE_MODE1_Pos)                      /*!< GP_T::MODE: MODE1 Mask                    */
N
N#define GP_MODE_MODE2_Pos                (4)                                               /*!< GP_T::MODE: MODE2 Position                */
N#define GP_MODE_MODE2_Msk                (0x3ul << GP_MODE_MODE2_Pos)                      /*!< GP_T::MODE: MODE2 Mask                    */
N
N#define GP_MODE_MODE3_Pos                (6)                                               /*!< GP_T::MODE: MODE3 Position                */
N#define GP_MODE_MODE3_Msk                (0x3ul << GP_MODE_MODE3_Pos)                      /*!< GP_T::MODE: MODE3 Mask                    */
N
N#define GP_MODE_MODE4_Pos                (8)                                               /*!< GP_T::MODE: MODE4 Position                */
N#define GP_MODE_MODE4_Msk                (0x3ul << GP_MODE_MODE4_Pos)                      /*!< GP_T::MODE: MODE4 Mask                    */
N
N#define GP_MODE_MODE5_Pos                (10)                                              /*!< GP_T::MODE: MODE5 Position                */
N#define GP_MODE_MODE5_Msk                (0x3ul << GP_MODE_MODE5_Pos)                      /*!< GP_T::MODE: MODE5 Mask                    */
N
N#define GP_DINOFF_DINOFF0_Pos            (16)                                              /*!< GP_T::DINOFF: DINOFF0 Position            */
N#define GP_DINOFF_DINOFF0_Msk            (0x1ul << GP_DINOFF_DINOFF0_Pos)                  /*!< GP_T::DINOFF: DINOFF0 Mask                */
N
N#define GP_DINOFF_DINOFF1_Pos            (17)                                              /*!< GP_T::DINOFF: DINOFF1 Position            */
N#define GP_DINOFF_DINOFF1_Msk            (0x1ul << GP_DINOFF_DINOFF1_Pos)                  /*!< GP_T::DINOFF: DINOFF1 Mask                */
N
N#define GP_DINOFF_DINOFF2_Pos            (18)                                              /*!< GP_T::DINOFF: DINOFF2 Position            */
N#define GP_DINOFF_DINOFF2_Msk            (0x1ul << GP_DINOFF_DINOFF2_Pos)                  /*!< GP_T::DINOFF: DINOFF2 Mask                */
N
N#define GP_DINOFF_DINOFF3_Pos            (19)                                              /*!< GP_T::DINOFF: DINOFF3 Position            */
N#define GP_DINOFF_DINOFF3_Msk            (0x1ul << GP_DINOFF_DINOFF3_Pos)                  /*!< GP_T::DINOFF: DINOFF3 Mask                */
N
N#define GP_DINOFF_DINOFF4_Pos            (20)                                              /*!< GP_T::DINOFF: DINOFF4 Position            */
N#define GP_DINOFF_DINOFF4_Msk            (0x1ul << GP_DINOFF_DINOFF4_Pos)                  /*!< GP_T::DINOFF: DINOFF4 Mask                */
N
N#define GP_DINOFF_DINOFF5_Pos            (21)                                              /*!< GP_T::DINOFF: DINOFF5 Position            */
N#define GP_DINOFF_DINOFF5_Msk            (0x1ul << GP_DINOFF_DINOFF5_Pos)                  /*!< GP_T::DINOFF: DINOFF5 Mask                */
N
N#define GP_DINOFF_DINOFF6_Pos            (22)                                              /*!< GP_T::DINOFF: DINOFF6 Position            */
N#define GP_DINOFF_DINOFF6_Msk            (0x1ul << GP_DINOFF_DINOFF6_Pos)                  /*!< GP_T::DINOFF: DINOFF6 Mask                */
N
N#define GP_DINOFF_DINOFF7_Pos            (23)                                              /*!< GP_T::DINOFF: DINOFF7 Position            */
N#define GP_DINOFF_DINOFF7_Msk            (0x1ul << GP_DINOFF_DINOFF7_Pos)                  /*!< GP_T::DINOFF: DINOFF7 Mask                */
N
N#define GP_DOUT_DOUT0_Pos                (0)                                               /*!< GP_T::DOUT: DOUT0 Position                */
N#define GP_DOUT_DOUT0_Msk                (0x1ul << GP_DOUT_DOUT0_Pos)                      /*!< GP_T::DOUT: DOUT0 Mask                    */
N
N#define GP_DOUT_DOUT1_Pos                (1)                                               /*!< GP_T::DOUT: DOUT1 Position                */
N#define GP_DOUT_DOUT1_Msk                (0x1ul << GP_DOUT_DOUT1_Pos)                      /*!< GP_T::DOUT: DOUT1 Mask                    */
N
N#define GP_DOUT_DOUT2_Pos                (2)                                               /*!< GP_T::DOUT: DOUT2 Position                */
N#define GP_DOUT_DOUT2_Msk                (0x1ul << GP_DOUT_DOUT2_Pos)                      /*!< GP_T::DOUT: DOUT2 Mask                    */
N
N#define GP_DOUT_DOUT3_Pos                (3)                                               /*!< GP_T::DOUT: DOUT3 Position                */
N#define GP_DOUT_DOUT3_Msk                (0x1ul << GP_DOUT_DOUT3_Pos)                      /*!< GP_T::DOUT: DOUT3 Mask                    */
N
N#define GP_DOUT_DOUT4_Pos                (4)                                               /*!< GP_T::DOUT: DOUT4 Position                */
N#define GP_DOUT_DOUT4_Msk                (0x1ul << GP_DOUT_DOUT4_Pos)                      /*!< GP_T::DOUT: DOUT4 Mask                    */
N
N#define GP_DOUT_DOUT5_Pos                (5)                                               /*!< GP_T::DOUT: DOUT5 Position                */
N#define GP_DOUT_DOUT5_Msk                (0x1ul << GP_DOUT_DOUT5_Pos)                      /*!< GP_T::DOUT: DOUT5 Mask                    */
N
N#define GP_DOUT_DOUT6_Pos                (6)                                               /*!< GP_T::DOUT: DOUT6 Position                */
N#define GP_DOUT_DOUT6_Msk                (0x1ul << GP_DOUT_DOUT6_Pos)                      /*!< GP_T::DOUT: DOUT6 Mask                    */
N
N#define GP_DOUT_DOUT7_Pos                (7)                                               /*!< GP_T::DOUT: DOUT7 Position                */
N#define GP_DOUT_DOUT7_Msk                (0x1ul << GP_DOUT_DOUT7_Pos)                      /*!< GP_T::DOUT: DOUT7 Mask                    */
N
N#define GP_DATMSK_DATMSK0_Pos            (0)                                               /*!< GP_T::DATMSK: DATMSK0 Position            */
N#define GP_DATMSK_DATMSK0_Msk            (0x1ul << GP_DATMSK_DATMSK0_Pos)                  /*!< GP_T::DATMSK: DATMSK0 Mask                */
N
N#define GP_DATMSK_DATMSK1_Pos            (1)                                               /*!< GP_T::DATMSK: DATMSK1 Position            */
N#define GP_DATMSK_DATMSK1_Msk            (0x1ul << GP_DATMSK_DATMSK1_Pos)                  /*!< GP_T::DATMSK: DATMSK1 Mask                */
N
N#define GP_DATMSK_DATMSK2_Pos            (2)                                               /*!< GP_T::DATMSK: DATMSK2 Position            */
N#define GP_DATMSK_DATMSK2_Msk            (0x1ul << GP_DATMSK_DATMSK2_Pos)                  /*!< GP_T::DATMSK: DATMSK2 Mask                */
N
N#define GP_DATMSK_DATMSK3_Pos            (3)                                               /*!< GP_T::DATMSK: DATMSK3 Position            */
N#define GP_DATMSK_DATMSK3_Msk            (0x1ul << GP_DATMSK_DATMSK3_Pos)                  /*!< GP_T::DATMSK: DATMSK3 Mask                */
N
N#define GP_DATMSK_DATMSK4_Pos            (4)                                               /*!< GP_T::DATMSK: DATMSK4 Position            */
N#define GP_DATMSK_DATMSK4_Msk            (0x1ul << GP_DATMSK_DATMSK4_Pos)                  /*!< GP_T::DATMSK: DATMSK4 Mask                */
N
N#define GP_DATMSK_DATMSK5_Pos            (5)                                               /*!< GP_T::DATMSK: DATMSK5 Position            */
N#define GP_DATMSK_DATMSK5_Msk            (0x1ul << GP_DATMSK_DATMSK5_Pos)                  /*!< GP_T::DATMSK: DATMSK5 Mask                */
N
N#define GP_DATMSK_DATMSK6_Pos            (6)                                               /*!< GP_T::DATMSK: DATMSK6 Position            */
N#define GP_DATMSK_DATMSK6_Msk            (0x1ul << GP_DATMSK_DATMSK6_Pos)                  /*!< GP_T::DATMSK: DATMSK6 Mask                */
N
N#define GP_DATMSK_DATMSK7_Pos            (7)                                               /*!< GP_T::DATMSK: DATMSK7 Position            */
N#define GP_DATMSK_DATMSK7_Msk            (0x1ul << GP_DATMSK_DATMSK7_Pos)                  /*!< GP_T::DATMSK: DATMSK7 Mask                */
N
N#define GP_PIN_PIN0_Pos                  (0)                                               /*!< GP_T::PIN: PIN0 Position                  */
N#define GP_PIN_PIN0_Msk                  (0x1ul << GP_PIN_PIN0_Pos)                        /*!< GP_T::PIN: PIN0 Mask                      */
N
N#define GP_PIN_PIN1_Pos                  (1)                                               /*!< GP_T::PIN: PIN1 Position                  */
N#define GP_PIN_PIN1_Msk                  (0x1ul << GP_PIN_PIN1_Pos)                        /*!< GP_T::PIN: PIN1 Mask                      */
N
N#define GP_PIN_PIN2_Pos                  (2)                                               /*!< GP_T::PIN: PIN2 Position                  */
N#define GP_PIN_PIN2_Msk                  (0x1ul << GP_PIN_PIN2_Pos)                        /*!< GP_T::PIN: PIN2 Mask                      */
N
N#define GP_PIN_PIN3_Pos                  (3)                                               /*!< GP_T::PIN: PIN3 Position                  */
N#define GP_PIN_PIN3_Msk                  (0x1ul << GP_PIN_PIN3_Pos)                        /*!< GP_T::PIN: PIN3 Mask                      */
N
N#define GP_PIN_PIN4_Pos                  (4)                                               /*!< GP_T::PIN: PIN4 Position                  */
N#define GP_PIN_PIN4_Msk                  (0x1ul << GP_PIN_PIN4_Pos)                        /*!< GP_T::PIN: PIN4 Mask                      */
N
N#define GP_PIN_PIN5_Pos                  (5)                                               /*!< GP_T::PIN: PIN5 Position                  */
N#define GP_PIN_PIN5_Msk                  (0x1ul << GP_PIN_PIN5_Pos)                        /*!< GP_T::PIN: PIN5 Mask                      */
N
N#define GP_PIN_PIN6_Pos                  (6)                                               /*!< GP_T::PIN: PIN6 Position                  */
N#define GP_PIN_PIN6_Msk                  (0x1ul << GP_PIN_PIN6_Pos)                        /*!< GP_T::PIN: PIN6 Mask                      */
N
N#define GP_PIN_PIN7_Pos                  (7)                                               /*!< GP_T::PIN: PIN7 Position                  */
N#define GP_PIN_PIN7_Msk                  (0x1ul << GP_PIN_PIN7_Pos)                        /*!< GP_T::PIN: PIN7 Mask                      */
N
N#define GP_DBEN_DBEN0_Pos                (0)                                               /*!< GP_T::DBEN: DBEN0 Position                */
N#define GP_DBEN_DBEN0_Msk                (0x1ul << GP_DBEN_DBEN0_Pos)                      /*!< GP_T::DBEN: DBEN0 Mask                    */
N
N#define GP_DBEN_DBEN1_Pos                (1)                                               /*!< GP_T::DBEN: DBEN1 Position                */
N#define GP_DBEN_DBEN1_Msk                (0x1ul << GP_DBEN_DBEN1_Pos)                      /*!< GP_T::DBEN: DBEN1 Mask                    */
N
N#define GP_DBEN_DBEN2_Pos                (2)                                               /*!< GP_T::DBEN: DBEN2 Position                */
N#define GP_DBEN_DBEN2_Msk                (0x1ul << GP_DBEN_DBEN2_Pos)                      /*!< GP_T::DBEN: DBEN2 Mask                    */
N
N#define GP_DBEN_DBEN3_Pos                (3)                                               /*!< GP_T::DBEN: DBEN3 Position                */
N#define GP_DBEN_DBEN3_Msk                (0x1ul << GP_DBEN_DBEN3_Pos)                      /*!< GP_T::DBEN: DBEN3 Mask                    */
N
N#define GP_DBEN_DBEN4_Pos                (4)                                               /*!< GP_T::DBEN: DBEN4 Position                */
N#define GP_DBEN_DBEN4_Msk                (0x1ul << GP_DBEN_DBEN4_Pos)                      /*!< GP_T::DBEN: DBEN4 Mask                    */
N
N#define GP_DBEN_DBEN5_Pos                (5)                                               /*!< GP_T::DBEN: DBEN5 Position                */
N#define GP_DBEN_DBEN5_Msk                (0x1ul << GP_DBEN_DBEN5_Pos)                      /*!< GP_T::DBEN: DBEN5 Mask                    */
N
N#define GP_DBEN_DBEN6_Pos                (6)                                               /*!< GP_T::DBEN: DBEN6 Position                */
N#define GP_DBEN_DBEN6_Msk                (0x1ul << GP_DBEN_DBEN6_Pos)                      /*!< GP_T::DBEN: DBEN6 Mask                    */
N
N#define GP_DBEN_DBEN7_Pos                (7)                                               /*!< GP_T::DBEN: DBEN7 Position                */
N#define GP_DBEN_DBEN7_Msk                (0x1ul << GP_DBEN_DBEN7_Pos)                      /*!< GP_T::DBEN: DBEN7 Mask                    */
N
N#define GP_INTTYPE_TYPE0_Pos             (0)                                               /*!< GP_T::INTTYPE: TYPE0 Position             */
N#define GP_INTTYPE_TYPE0_Msk             (0x1ul << GP_INTTYPE_TYPE0_Pos)                   /*!< GP_T::INTTYPE: TYPE0 Mask                 */
N
N#define GP_INTTYPE_TYPE1_Pos             (1)                                               /*!< GP_T::INTTYPE: TYPE1 Position             */
N#define GP_INTTYPE_TYPE1_Msk             (0x1ul << GP_INTTYPE_TYPE1_Pos)                   /*!< GP_T::INTTYPE: TYPE1 Mask                 */
N
N#define GP_INTTYPE_TYPE2_Pos             (2)                                               /*!< GP_T::INTTYPE: TYPE2 Position             */
N#define GP_INTTYPE_TYPE2_Msk             (0x1ul << GP_INTTYPE_TYPE2_Pos)                   /*!< GP_T::INTTYPE: TYPE2 Mask                 */
N
N#define GP_INTTYPE_TYPE3_Pos             (3)                                               /*!< GP_T::INTTYPE: TYPE3 Position             */
N#define GP_INTTYPE_TYPE3_Msk             (0x1ul << GP_INTTYPE_TYPE3_Pos)                   /*!< GP_T::INTTYPE: TYPE3 Mask                 */
N
N#define GP_INTTYPE_TYPE4_Pos             (4)                                               /*!< GP_T::INTTYPE: TYPE4 Position             */
N#define GP_INTTYPE_TYPE4_Msk             (0x1ul << GP_INTTYPE_TYPE4_Pos)                   /*!< GP_T::INTTYPE: TYPE4 Mask                 */
N
N#define GP_INTTYPE_TYPE5_Pos             (5)                                               /*!< GP_T::INTTYPE: TYPE5 Position             */
N#define GP_INTTYPE_TYPE5_Msk             (0x1ul << GP_INTTYPE_TYPE5_Pos)                   /*!< GP_T::INTTYPE: TYPE5 Mask                 */
N
N#define GP_INTTYPE_TYPE6_Pos             (6)                                               /*!< GP_T::INTTYPE: TYPE6 Position             */
N#define GP_INTTYPE_TYPE6_Msk             (0x1ul << GP_INTTYPE_TYPE6_Pos)                   /*!< GP_T::INTTYPE: TYPE6 Mask                 */
N
N#define GP_INTTYPE_TYPE7_Pos             (7)                                               /*!< GP_T::INTTYPE: TYPE7 Position             */
N#define GP_INTTYPE_TYPE7_Msk             (0x1ul << GP_INTTYPE_TYPE7_Pos)                   /*!< GP_T::INTTYPE: TYPE7 Mask                 */
N
N#define GP_INTEN_FLIEN0_Pos              (0)                                               /*!< GP_T::INTEN: FLIEN0 Position              */
N#define GP_INTEN_FLIEN0_Msk              (0x1ul << GP_INTEN_FLIEN0_Pos)                    /*!< GP_T::INTEN: FLIEN0 Mask                  */
N
N#define GP_INTEN_FLIEN1_Pos              (1)                                               /*!< GP_T::INTEN: FLIEN1 Position              */
N#define GP_INTEN_FLIEN1_Msk              (0x1ul << GP_INTEN_FLIEN1_Pos)                    /*!< GP_T::INTEN: FLIEN1 Mask                  */
N
N#define GP_INTEN_FLIEN2_Pos              (2)                                               /*!< GP_T::INTEN: FLIEN2 Position              */
N#define GP_INTEN_FLIEN2_Msk              (0x1ul << GP_INTEN_FLIEN2_Pos)                    /*!< GP_T::INTEN: FLIEN2 Mask                  */
N
N#define GP_INTEN_FLIEN3_Pos              (3)                                               /*!< GP_T::INTEN: FLIEN3 Position              */
N#define GP_INTEN_FLIEN3_Msk              (0x1ul << GP_INTEN_FLIEN3_Pos)                    /*!< GP_T::INTEN: FLIEN3 Mask                  */
N
N#define GP_INTEN_FLIEN4_Pos              (4)                                               /*!< GP_T::INTEN: FLIEN4 Position              */
N#define GP_INTEN_FLIEN4_Msk              (0x1ul << GP_INTEN_FLIEN4_Pos)                    /*!< GP_T::INTEN: FLIEN4 Mask                  */
N
N#define GP_INTEN_FLIEN5_Pos              (5)                                               /*!< GP_T::INTEN: FLIEN5 Position              */
N#define GP_INTEN_FLIEN5_Msk              (0x1ul << GP_INTEN_FLIEN5_Pos)                    /*!< GP_T::INTEN: FLIEN5 Mask                  */
N
N#define GP_INTEN_FLIEN6_Pos              (6)                                               /*!< GP_T::INTEN: FLIEN6 Position              */
N#define GP_INTEN_FLIEN6_Msk              (0x1ul << GP_INTEN_FLIEN6_Pos)                    /*!< GP_T::INTEN: FLIEN6 Mask                  */
N
N#define GP_INTEN_FLIEN7_Pos              (7)                                               /*!< GP_T::INTEN: FLIEN7 Position              */
N#define GP_INTEN_FLIEN7_Msk              (0x1ul << GP_INTEN_FLIEN7_Pos)                    /*!< GP_T::INTEN: FLIEN7 Mask                  */
N
N#define GP_INTEN_RHIEN0_Pos              (16)                                              /*!< GP_T::INTEN: RHIEN0 Position              */
N#define GP_INTEN_RHIEN0_Msk              (0x1ul << GP_INTEN_RHIEN0_Pos)                    /*!< GP_T::INTEN: RHIEN0 Mask                  */
N
N#define GP_INTEN_RHIEN1_Pos              (17)                                              /*!< GP_T::INTEN: RHIEN1 Position              */
N#define GP_INTEN_RHIEN1_Msk              (0x1ul << GP_INTEN_RHIEN1_Pos)                    /*!< GP_T::INTEN: RHIEN1 Mask                  */
N
N#define GP_INTEN_RHIEN2_Pos              (18)                                              /*!< GP_T::INTEN: RHIEN2 Position              */
N#define GP_INTEN_RHIEN2_Msk              (0x1ul << GP_INTEN_RHIEN2_Pos)                    /*!< GP_T::INTEN: RHIEN2 Mask                  */
N
N#define GP_INTEN_RHIEN3_Pos              (19)                                              /*!< GP_T::INTEN: RHIEN3 Position              */
N#define GP_INTEN_RHIEN3_Msk              (0x1ul << GP_INTEN_RHIEN3_Pos)                    /*!< GP_T::INTEN: RHIEN3 Mask                  */
N
N#define GP_INTEN_RHIEN4_Pos              (20)                                              /*!< GP_T::INTEN: RHIEN4 Position              */
N#define GP_INTEN_RHIEN4_Msk              (0x1ul << GP_INTEN_RHIEN4_Pos)                    /*!< GP_T::INTEN: RHIEN4 Mask                  */
N
N#define GP_INTEN_RHIEN5_Pos              (21)                                              /*!< GP_T::INTEN: RHIEN5 Position              */
N#define GP_INTEN_RHIEN5_Msk              (0x1ul << GP_INTEN_RHIEN5_Pos)                    /*!< GP_T::INTEN: RHIEN5 Mask                  */
N
N#define GP_INTEN_RHIEN6_Pos              (22)                                              /*!< GP_T::INTEN: RHIEN6 Position              */
N#define GP_INTEN_RHIEN6_Msk              (0x1ul << GP_INTEN_RHIEN6_Pos)                    /*!< GP_T::INTEN: RHIEN6 Mask                  */
N
N#define GP_INTEN_RHIEN7_Pos              (23)                                              /*!< GP_T::INTEN: RHIEN7 Position              */
N#define GP_INTEN_RHIEN7_Msk              (0x1ul << GP_INTEN_RHIEN7_Pos)                    /*!< GP_T::INTEN: RHIEN7 Mask                  */
N
N#define GP_INTSRC_INTSRC0_Pos            (0)                                               /*!< GP_T::INTSRC: INTSRC0 Position            */
N#define GP_INTSRC_INTSRC0_Msk            (0x1ul << GP_INTSRC_INTSRC0_Pos)                  /*!< GP_T::INTSRC: INTSRC0 Mask                */
N
N#define GP_INTSRC_INTSRC1_Pos            (1)                                               /*!< GP_T::INTSRC: INTSRC1 Position            */
N#define GP_INTSRC_INTSRC1_Msk            (0x1ul << GP_INTSRC_INTSRC1_Pos)                  /*!< GP_T::INTSRC: INTSRC1 Mask                */
N
N#define GP_INTSRC_INTSRC2_Pos            (2)                                               /*!< GP_T::INTSRC: INTSRC2 Position            */
N#define GP_INTSRC_INTSRC2_Msk            (0x1ul << GP_INTSRC_INTSRC2_Pos)                  /*!< GP_T::INTSRC: INTSRC2 Mask                */
N
N#define GP_INTSRC_INTSRC3_Pos            (3)                                               /*!< GP_T::INTSRC: INTSRC3 Position            */
N#define GP_INTSRC_INTSRC3_Msk            (0x1ul << GP_INTSRC_INTSRC3_Pos)                  /*!< GP_T::INTSRC: INTSRC3 Mask                */
N
N#define GP_INTSRC_INTSRC4_Pos            (4)                                               /*!< GP_T::INTSRC: INTSRC4 Position            */
N#define GP_INTSRC_INTSRC4_Msk            (0x1ul << GP_INTSRC_INTSRC4_Pos)                  /*!< GP_T::INTSRC: INTSRC4 Mask                */
N
N#define GP_INTSRC_INTSRC5_Pos            (5)                                               /*!< GP_T::INTSRC: INTSRC5 Position            */
N#define GP_INTSRC_INTSRC5_Msk            (0x1ul << GP_INTSRC_INTSRC5_Pos)                  /*!< GP_T::INTSRC: INTSRC5 Mask                */
N
N#define GP_INTSRC_INTSRC6_Pos            (6)                                               /*!< GP_T::INTSRC: INTSRC6 Position            */
N#define GP_INTSRC_INTSRC6_Msk            (0x1ul << GP_INTSRC_INTSRC6_Pos)                  /*!< GP_T::INTSRC: INTSRC6 Mask                */
N
N#define GP_INTSRC_INTSRC7_Pos            (7)                                               /*!< GP_T::INTSRC: INTSRC7 Position            */
N#define GP_INTSRC_INTSRC7_Msk            (0x1ul << GP_INTSRC_INTSRC7_Pos)                  /*!< GP_T::INTSRC: INTSRC7 Mask                */
N
N#define GP_INTSRC_INTSRC8_Pos            (8)                                               /*!< GP_T::INTSRC: INTSRC8 Position            */
N#define GP_INTSRC_INTSRC8_Msk            (0x1ul << GP_INTSRC_INTSRC8_Pos)                  /*!< GP_T::INTSRC: INTSRC8 Mask                */
N
N#define GP_INTSRC_INTSRC9_Pos            (9)                                               /*!< GP_T::INTSRC: INTSRC9 Position            */
N#define GP_INTSRC_INTSRC9_Msk            (0x1ul << GP_INTSRC_INTSRC9_Pos)                  /*!< GP_T::INTSRC: INTSRC9 Mask                */
N
N#define GP_INTSRC_INTSRC10_Pos           (10)                                              /*!< GP_T::INTSRC: INTSRC10 Position           */
N#define GP_INTSRC_INTSRC10_Msk           (0x1ul << GP_INTSRC_INTSRC10_Pos)                 /*!< GP_T::INTSRC: INTSRC10 Mask               */
N
N#define GP_INTSRC_INTSRC11_Pos           (11)                                              /*!< GP_T::INTSRC: INTSRC11 Position           */
N#define GP_INTSRC_INTSRC11_Msk           (0x1ul << GP_INTSRC_INTSRC11_Pos)                 /*!< GP_T::INTSRC: INTSRC11 Mask               */
N
N#define GP_INTSRC_INTSRC12_Pos           (12)                                              /*!< GP_T::INTSRC: INTSRC12 Position           */
N#define GP_INTSRC_INTSRC12_Msk           (0x1ul << GP_INTSRC_INTSRC12_Pos)                 /*!< GP_T::INTSRC: INTSRC12 Mask               */
N
N#define GP_INTSRC_INTSRC13_Pos           (13)                                              /*!< GP_T::INTSRC: INTSRC13 Position           */
N#define GP_INTSRC_INTSRC13_Msk           (0x1ul << GP_INTSRC_INTSRC13_Pos)                 /*!< GP_T::INTSRC: INTSRC13 Mask               */
N
N#define GP_INTSRC_INTSRC14_Pos           (14)                                              /*!< GP_T::INTSRC: INTSRC14 Position           */
N#define GP_INTSRC_INTSRC14_Msk           (0x1ul << GP_INTSRC_INTSRC14_Pos)                 /*!< GP_T::INTSRC: INTSRC14 Mask               */
N
N#define GP_INTSRC_INTSRC15_Pos           (15)                                              /*!< GP_T::INTSRC: INTSRC15 Position           */
N#define GP_INTSRC_INTSRC15_Msk           (0x1ul << GP_INTSRC_INTSRC15_Pos)                 /*!< GP_T::INTSRC: INTSRC15 Mask               */
N
N#define GP_MODE_MODE0_Pos                (0)                                               /*!< GP_T::MODE: MODE0 Position                */
N#define GP_MODE_MODE0_Msk                (0x3ul << GP_MODE_MODE0_Pos)                      /*!< GP_T::MODE: MODE0 Mask                    */
N
N#define GP_MODE_MODE1_Pos                (2)                                               /*!< GP_T::MODE: MODE1 Position                */
N#define GP_MODE_MODE1_Msk                (0x3ul << GP_MODE_MODE1_Pos)                      /*!< GP_T::MODE: MODE1 Mask                    */
N
N#define GP_MODE_MODE2_Pos                (4)                                               /*!< GP_T::MODE: MODE2 Position                */
N#define GP_MODE_MODE2_Msk                (0x3ul << GP_MODE_MODE2_Pos)                      /*!< GP_T::MODE: MODE2 Mask                    */
N
N#define GP_MODE_MODE3_Pos                (6)                                               /*!< GP_T::MODE: MODE3 Position                */
N#define GP_MODE_MODE3_Msk                (0x3ul << GP_MODE_MODE3_Pos)                      /*!< GP_T::MODE: MODE3 Mask                    */
N
N#define GP_MODE_MODE4_Pos                (8)                                               /*!< GP_T::MODE: MODE4 Position                */
N#define GP_MODE_MODE4_Msk                (0x3ul << GP_MODE_MODE4_Pos)                      /*!< GP_T::MODE: MODE4 Mask                    */
N
N#define GP_MODE_MODE5_Pos                (10)                                              /*!< GP_T::MODE: MODE5 Position                */
N#define GP_MODE_MODE5_Msk                (0x3ul << GP_MODE_MODE5_Pos)                      /*!< GP_T::MODE: MODE5 Mask                    */
N
N#define GP_DINOFF_DINOFF0_Pos            (16)                                              /*!< GP_T::DINOFF: DINOFF0 Position            */
N#define GP_DINOFF_DINOFF0_Msk            (0x1ul << GP_DINOFF_DINOFF0_Pos)                  /*!< GP_T::DINOFF: DINOFF0 Mask                */
N
N#define GP_DINOFF_DINOFF1_Pos            (17)                                              /*!< GP_T::DINOFF: DINOFF1 Position            */
N#define GP_DINOFF_DINOFF1_Msk            (0x1ul << GP_DINOFF_DINOFF1_Pos)                  /*!< GP_T::DINOFF: DINOFF1 Mask                */
N
N#define GP_DINOFF_DINOFF2_Pos            (18)                                              /*!< GP_T::DINOFF: DINOFF2 Position            */
N#define GP_DINOFF_DINOFF2_Msk            (0x1ul << GP_DINOFF_DINOFF2_Pos)                  /*!< GP_T::DINOFF: DINOFF2 Mask                */
N
N#define GP_DINOFF_DINOFF3_Pos            (19)                                              /*!< GP_T::DINOFF: DINOFF3 Position            */
N#define GP_DINOFF_DINOFF3_Msk            (0x1ul << GP_DINOFF_DINOFF3_Pos)                  /*!< GP_T::DINOFF: DINOFF3 Mask                */
N
N#define GP_DINOFF_DINOFF4_Pos            (20)                                              /*!< GP_T::DINOFF: DINOFF4 Position            */
N#define GP_DINOFF_DINOFF4_Msk            (0x1ul << GP_DINOFF_DINOFF4_Pos)                  /*!< GP_T::DINOFF: DINOFF4 Mask                */
N
N#define GP_DINOFF_DINOFF5_Pos            (21)                                              /*!< GP_T::DINOFF: DINOFF5 Position            */
N#define GP_DINOFF_DINOFF5_Msk            (0x1ul << GP_DINOFF_DINOFF5_Pos)                  /*!< GP_T::DINOFF: DINOFF5 Mask                */
N
N#define GP_DINOFF_DINOFF6_Pos            (22)                                              /*!< GP_T::DINOFF: DINOFF6 Position            */
N#define GP_DINOFF_DINOFF6_Msk            (0x1ul << GP_DINOFF_DINOFF6_Pos)                  /*!< GP_T::DINOFF: DINOFF6 Mask                */
N
N#define GP_DINOFF_DINOFF7_Pos            (23)                                              /*!< GP_T::DINOFF: DINOFF7 Position            */
N#define GP_DINOFF_DINOFF7_Msk            (0x1ul << GP_DINOFF_DINOFF7_Pos)                  /*!< GP_T::DINOFF: DINOFF7 Mask                */
N
N#define GP_DOUT_DOUT0_Pos                (0)                                               /*!< GP_T::DOUT: DOUT0 Position                */
N#define GP_DOUT_DOUT0_Msk                (0x1ul << GP_DOUT_DOUT0_Pos)                      /*!< GP_T::DOUT: DOUT0 Mask                    */
N
N#define GP_DOUT_DOUT1_Pos                (1)                                               /*!< GP_T::DOUT: DOUT1 Position                */
N#define GP_DOUT_DOUT1_Msk                (0x1ul << GP_DOUT_DOUT1_Pos)                      /*!< GP_T::DOUT: DOUT1 Mask                    */
N
N#define GP_DOUT_DOUT2_Pos                (2)                                               /*!< GP_T::DOUT: DOUT2 Position                */
N#define GP_DOUT_DOUT2_Msk                (0x1ul << GP_DOUT_DOUT2_Pos)                      /*!< GP_T::DOUT: DOUT2 Mask                    */
N
N#define GP_DOUT_DOUT3_Pos                (3)                                               /*!< GP_T::DOUT: DOUT3 Position                */
N#define GP_DOUT_DOUT3_Msk                (0x1ul << GP_DOUT_DOUT3_Pos)                      /*!< GP_T::DOUT: DOUT3 Mask                    */
N
N#define GP_DOUT_DOUT4_Pos                (4)                                               /*!< GP_T::DOUT: DOUT4 Position                */
N#define GP_DOUT_DOUT4_Msk                (0x1ul << GP_DOUT_DOUT4_Pos)                      /*!< GP_T::DOUT: DOUT4 Mask                    */
N
N#define GP_DOUT_DOUT5_Pos                (5)                                               /*!< GP_T::DOUT: DOUT5 Position                */
N#define GP_DOUT_DOUT5_Msk                (0x1ul << GP_DOUT_DOUT5_Pos)                      /*!< GP_T::DOUT: DOUT5 Mask                    */
N
N#define GP_DOUT_DOUT6_Pos                (6)                                               /*!< GP_T::DOUT: DOUT6 Position                */
N#define GP_DOUT_DOUT6_Msk                (0x1ul << GP_DOUT_DOUT6_Pos)                      /*!< GP_T::DOUT: DOUT6 Mask                    */
N
N#define GP_DOUT_DOUT7_Pos                (7)                                               /*!< GP_T::DOUT: DOUT7 Position                */
N#define GP_DOUT_DOUT7_Msk                (0x1ul << GP_DOUT_DOUT7_Pos)                      /*!< GP_T::DOUT: DOUT7 Mask                    */
N
N#define GP_DATMSK_DATMSK0_Pos            (0)                                               /*!< GP_T::DATMSK: DATMSK0 Position            */
N#define GP_DATMSK_DATMSK0_Msk            (0x1ul << GP_DATMSK_DATMSK0_Pos)                  /*!< GP_T::DATMSK: DATMSK0 Mask                */
N
N#define GP_DATMSK_DATMSK1_Pos            (1)                                               /*!< GP_T::DATMSK: DATMSK1 Position            */
N#define GP_DATMSK_DATMSK1_Msk            (0x1ul << GP_DATMSK_DATMSK1_Pos)                  /*!< GP_T::DATMSK: DATMSK1 Mask                */
N
N#define GP_DATMSK_DATMSK2_Pos            (2)                                               /*!< GP_T::DATMSK: DATMSK2 Position            */
N#define GP_DATMSK_DATMSK2_Msk            (0x1ul << GP_DATMSK_DATMSK2_Pos)                  /*!< GP_T::DATMSK: DATMSK2 Mask                */
N
N#define GP_DATMSK_DATMSK3_Pos            (3)                                               /*!< GP_T::DATMSK: DATMSK3 Position            */
N#define GP_DATMSK_DATMSK3_Msk            (0x1ul << GP_DATMSK_DATMSK3_Pos)                  /*!< GP_T::DATMSK: DATMSK3 Mask                */
N
N#define GP_DATMSK_DATMSK4_Pos            (4)                                               /*!< GP_T::DATMSK: DATMSK4 Position            */
N#define GP_DATMSK_DATMSK4_Msk            (0x1ul << GP_DATMSK_DATMSK4_Pos)                  /*!< GP_T::DATMSK: DATMSK4 Mask                */
N
N#define GP_DATMSK_DATMSK5_Pos            (5)                                               /*!< GP_T::DATMSK: DATMSK5 Position            */
N#define GP_DATMSK_DATMSK5_Msk            (0x1ul << GP_DATMSK_DATMSK5_Pos)                  /*!< GP_T::DATMSK: DATMSK5 Mask                */
N
N#define GP_DATMSK_DATMSK6_Pos            (6)                                               /*!< GP_T::DATMSK: DATMSK6 Position            */
N#define GP_DATMSK_DATMSK6_Msk            (0x1ul << GP_DATMSK_DATMSK6_Pos)                  /*!< GP_T::DATMSK: DATMSK6 Mask                */
N
N#define GP_DATMSK_DATMSK7_Pos            (7)                                               /*!< GP_T::DATMSK: DATMSK7 Position            */
N#define GP_DATMSK_DATMSK7_Msk            (0x1ul << GP_DATMSK_DATMSK7_Pos)                  /*!< GP_T::DATMSK: DATMSK7 Mask                */
N
N#define GP_PIN_PIN0_Pos                  (0)                                               /*!< GP_T::PIN: PIN0 Position                  */
N#define GP_PIN_PIN0_Msk                  (0x1ul << GP_PIN_PIN0_Pos)                        /*!< GP_T::PIN: PIN0 Mask                      */
N
N#define GP_PIN_PIN1_Pos                  (1)                                               /*!< GP_T::PIN: PIN1 Position                  */
N#define GP_PIN_PIN1_Msk                  (0x1ul << GP_PIN_PIN1_Pos)                        /*!< GP_T::PIN: PIN1 Mask                      */
N
N#define GP_PIN_PIN2_Pos                  (2)                                               /*!< GP_T::PIN: PIN2 Position                  */
N#define GP_PIN_PIN2_Msk                  (0x1ul << GP_PIN_PIN2_Pos)                        /*!< GP_T::PIN: PIN2 Mask                      */
N
N#define GP_PIN_PIN3_Pos                  (3)                                               /*!< GP_T::PIN: PIN3 Position                  */
N#define GP_PIN_PIN3_Msk                  (0x1ul << GP_PIN_PIN3_Pos)                        /*!< GP_T::PIN: PIN3 Mask                      */
N
N#define GP_PIN_PIN4_Pos                  (4)                                               /*!< GP_T::PIN: PIN4 Position                  */
N#define GP_PIN_PIN4_Msk                  (0x1ul << GP_PIN_PIN4_Pos)                        /*!< GP_T::PIN: PIN4 Mask                      */
N
N#define GP_PIN_PIN5_Pos                  (5)                                               /*!< GP_T::PIN: PIN5 Position                  */
N#define GP_PIN_PIN5_Msk                  (0x1ul << GP_PIN_PIN5_Pos)                        /*!< GP_T::PIN: PIN5 Mask                      */
N
N#define GP_PIN_PIN6_Pos                  (6)                                               /*!< GP_T::PIN: PIN6 Position                  */
N#define GP_PIN_PIN6_Msk                  (0x1ul << GP_PIN_PIN6_Pos)                        /*!< GP_T::PIN: PIN6 Mask                      */
N
N#define GP_PIN_PIN7_Pos                  (7)                                               /*!< GP_T::PIN: PIN7 Position                  */
N#define GP_PIN_PIN7_Msk                  (0x1ul << GP_PIN_PIN7_Pos)                        /*!< GP_T::PIN: PIN7 Mask                      */
N
N#define GP_DBEN_DBEN0_Pos                (0)                                               /*!< GP_T::DBEN: DBEN0 Position                */
N#define GP_DBEN_DBEN0_Msk                (0x1ul << GP_DBEN_DBEN0_Pos)                      /*!< GP_T::DBEN: DBEN0 Mask                    */
N
N#define GP_DBEN_DBEN1_Pos                (1)                                               /*!< GP_T::DBEN: DBEN1 Position                */
N#define GP_DBEN_DBEN1_Msk                (0x1ul << GP_DBEN_DBEN1_Pos)                      /*!< GP_T::DBEN: DBEN1 Mask                    */
N
N#define GP_DBEN_DBEN2_Pos                (2)                                               /*!< GP_T::DBEN: DBEN2 Position                */
N#define GP_DBEN_DBEN2_Msk                (0x1ul << GP_DBEN_DBEN2_Pos)                      /*!< GP_T::DBEN: DBEN2 Mask                    */
N
N#define GP_DBEN_DBEN3_Pos                (3)                                               /*!< GP_T::DBEN: DBEN3 Position                */
N#define GP_DBEN_DBEN3_Msk                (0x1ul << GP_DBEN_DBEN3_Pos)                      /*!< GP_T::DBEN: DBEN3 Mask                    */
N
N#define GP_DBEN_DBEN4_Pos                (4)                                               /*!< GP_T::DBEN: DBEN4 Position                */
N#define GP_DBEN_DBEN4_Msk                (0x1ul << GP_DBEN_DBEN4_Pos)                      /*!< GP_T::DBEN: DBEN4 Mask                    */
N
N#define GP_DBEN_DBEN5_Pos                (5)                                               /*!< GP_T::DBEN: DBEN5 Position                */
N#define GP_DBEN_DBEN5_Msk                (0x1ul << GP_DBEN_DBEN5_Pos)                      /*!< GP_T::DBEN: DBEN5 Mask                    */
N
N#define GP_DBEN_DBEN6_Pos                (6)                                               /*!< GP_T::DBEN: DBEN6 Position                */
N#define GP_DBEN_DBEN6_Msk                (0x1ul << GP_DBEN_DBEN6_Pos)                      /*!< GP_T::DBEN: DBEN6 Mask                    */
N
N#define GP_DBEN_DBEN7_Pos                (7)                                               /*!< GP_T::DBEN: DBEN7 Position                */
N#define GP_DBEN_DBEN7_Msk                (0x1ul << GP_DBEN_DBEN7_Pos)                      /*!< GP_T::DBEN: DBEN7 Mask                    */
N
N#define GP_INTTYPE_TYPE0_Pos             (0)                                               /*!< GP_T::INTTYPE: TYPE0 Position             */
N#define GP_INTTYPE_TYPE0_Msk             (0x1ul << GP_INTTYPE_TYPE0_Pos)                   /*!< GP_T::INTTYPE: TYPE0 Mask                 */
N
N#define GP_INTTYPE_TYPE1_Pos             (1)                                               /*!< GP_T::INTTYPE: TYPE1 Position             */
N#define GP_INTTYPE_TYPE1_Msk             (0x1ul << GP_INTTYPE_TYPE1_Pos)                   /*!< GP_T::INTTYPE: TYPE1 Mask                 */
N
N#define GP_INTTYPE_TYPE2_Pos             (2)                                               /*!< GP_T::INTTYPE: TYPE2 Position             */
N#define GP_INTTYPE_TYPE2_Msk             (0x1ul << GP_INTTYPE_TYPE2_Pos)                   /*!< GP_T::INTTYPE: TYPE2 Mask                 */
N
N#define GP_INTTYPE_TYPE3_Pos             (3)                                               /*!< GP_T::INTTYPE: TYPE3 Position             */
N#define GP_INTTYPE_TYPE3_Msk             (0x1ul << GP_INTTYPE_TYPE3_Pos)                   /*!< GP_T::INTTYPE: TYPE3 Mask                 */
N
N#define GP_INTTYPE_TYPE4_Pos             (4)                                               /*!< GP_T::INTTYPE: TYPE4 Position             */
N#define GP_INTTYPE_TYPE4_Msk             (0x1ul << GP_INTTYPE_TYPE4_Pos)                   /*!< GP_T::INTTYPE: TYPE4 Mask                 */
N
N#define GP_INTTYPE_TYPE5_Pos             (5)                                               /*!< GP_T::INTTYPE: TYPE5 Position             */
N#define GP_INTTYPE_TYPE5_Msk             (0x1ul << GP_INTTYPE_TYPE5_Pos)                   /*!< GP_T::INTTYPE: TYPE5 Mask                 */
N
N#define GP_INTTYPE_TYPE6_Pos             (6)                                               /*!< GP_T::INTTYPE: TYPE6 Position             */
N#define GP_INTTYPE_TYPE6_Msk             (0x1ul << GP_INTTYPE_TYPE6_Pos)                   /*!< GP_T::INTTYPE: TYPE6 Mask                 */
N
N#define GP_INTTYPE_TYPE7_Pos             (7)                                               /*!< GP_T::INTTYPE: TYPE7 Position             */
N#define GP_INTTYPE_TYPE7_Msk             (0x1ul << GP_INTTYPE_TYPE7_Pos)                   /*!< GP_T::INTTYPE: TYPE7 Mask                 */
N
N#define GP_INTEN_FLIEN0_Pos              (0)                                               /*!< GP_T::INTEN: FLIEN0 Position              */
N#define GP_INTEN_FLIEN0_Msk              (0x1ul << GP_INTEN_FLIEN0_Pos)                    /*!< GP_T::INTEN: FLIEN0 Mask                  */
N
N#define GP_INTEN_FLIEN1_Pos              (1)                                               /*!< GP_T::INTEN: FLIEN1 Position              */
N#define GP_INTEN_FLIEN1_Msk              (0x1ul << GP_INTEN_FLIEN1_Pos)                    /*!< GP_T::INTEN: FLIEN1 Mask                  */
N
N#define GP_INTEN_FLIEN2_Pos              (2)                                               /*!< GP_T::INTEN: FLIEN2 Position              */
N#define GP_INTEN_FLIEN2_Msk              (0x1ul << GP_INTEN_FLIEN2_Pos)                    /*!< GP_T::INTEN: FLIEN2 Mask                  */
N
N#define GP_INTEN_FLIEN3_Pos              (3)                                               /*!< GP_T::INTEN: FLIEN3 Position              */
N#define GP_INTEN_FLIEN3_Msk              (0x1ul << GP_INTEN_FLIEN3_Pos)                    /*!< GP_T::INTEN: FLIEN3 Mask                  */
N
N#define GP_INTEN_FLIEN4_Pos              (4)                                               /*!< GP_T::INTEN: FLIEN4 Position              */
N#define GP_INTEN_FLIEN4_Msk              (0x1ul << GP_INTEN_FLIEN4_Pos)                    /*!< GP_T::INTEN: FLIEN4 Mask                  */
N
N#define GP_INTEN_FLIEN5_Pos              (5)                                               /*!< GP_T::INTEN: FLIEN5 Position              */
N#define GP_INTEN_FLIEN5_Msk              (0x1ul << GP_INTEN_FLIEN5_Pos)                    /*!< GP_T::INTEN: FLIEN5 Mask                  */
N
N#define GP_INTEN_FLIEN6_Pos              (6)                                               /*!< GP_T::INTEN: FLIEN6 Position              */
N#define GP_INTEN_FLIEN6_Msk              (0x1ul << GP_INTEN_FLIEN6_Pos)                    /*!< GP_T::INTEN: FLIEN6 Mask                  */
N
N#define GP_INTEN_FLIEN7_Pos              (7)                                               /*!< GP_T::INTEN: FLIEN7 Position              */
N#define GP_INTEN_FLIEN7_Msk              (0x1ul << GP_INTEN_FLIEN7_Pos)                    /*!< GP_T::INTEN: FLIEN7 Mask                  */
N
N#define GP_INTEN_RHIEN0_Pos              (16)                                              /*!< GP_T::INTEN: RHIEN0 Position              */
N#define GP_INTEN_RHIEN0_Msk              (0x1ul << GP_INTEN_RHIEN0_Pos)                    /*!< GP_T::INTEN: RHIEN0 Mask                  */
N
N#define GP_INTEN_RHIEN1_Pos              (17)                                              /*!< GP_T::INTEN: RHIEN1 Position              */
N#define GP_INTEN_RHIEN1_Msk              (0x1ul << GP_INTEN_RHIEN1_Pos)                    /*!< GP_T::INTEN: RHIEN1 Mask                  */
N
N#define GP_INTEN_RHIEN2_Pos              (18)                                              /*!< GP_T::INTEN: RHIEN2 Position              */
N#define GP_INTEN_RHIEN2_Msk              (0x1ul << GP_INTEN_RHIEN2_Pos)                    /*!< GP_T::INTEN: RHIEN2 Mask                  */
N
N#define GP_INTEN_RHIEN3_Pos              (19)                                              /*!< GP_T::INTEN: RHIEN3 Position              */
N#define GP_INTEN_RHIEN3_Msk              (0x1ul << GP_INTEN_RHIEN3_Pos)                    /*!< GP_T::INTEN: RHIEN3 Mask                  */
N
N#define GP_INTEN_RHIEN4_Pos              (20)                                              /*!< GP_T::INTEN: RHIEN4 Position              */
N#define GP_INTEN_RHIEN4_Msk              (0x1ul << GP_INTEN_RHIEN4_Pos)                    /*!< GP_T::INTEN: RHIEN4 Mask                  */
N
N#define GP_INTEN_RHIEN5_Pos              (21)                                              /*!< GP_T::INTEN: RHIEN5 Position              */
N#define GP_INTEN_RHIEN5_Msk              (0x1ul << GP_INTEN_RHIEN5_Pos)                    /*!< GP_T::INTEN: RHIEN5 Mask                  */
N
N#define GP_INTEN_RHIEN6_Pos              (22)                                              /*!< GP_T::INTEN: RHIEN6 Position              */
N#define GP_INTEN_RHIEN6_Msk              (0x1ul << GP_INTEN_RHIEN6_Pos)                    /*!< GP_T::INTEN: RHIEN6 Mask                  */
N
N#define GP_INTEN_RHIEN7_Pos              (23)                                              /*!< GP_T::INTEN: RHIEN7 Position              */
N#define GP_INTEN_RHIEN7_Msk              (0x1ul << GP_INTEN_RHIEN7_Pos)                    /*!< GP_T::INTEN: RHIEN7 Mask                  */
N
N#define GP_INTSRC_INTSRC0_Pos            (0)                                               /*!< GP_T::INTSRC: INTSRC0 Position            */
N#define GP_INTSRC_INTSRC0_Msk            (0x1ul << GP_INTSRC_INTSRC0_Pos)                  /*!< GP_T::INTSRC: INTSRC0 Mask                */
N
N#define GP_INTSRC_INTSRC1_Pos            (1)                                               /*!< GP_T::INTSRC: INTSRC1 Position            */
N#define GP_INTSRC_INTSRC1_Msk            (0x1ul << GP_INTSRC_INTSRC1_Pos)                  /*!< GP_T::INTSRC: INTSRC1 Mask                */
N
N#define GP_INTSRC_INTSRC2_Pos            (2)                                               /*!< GP_T::INTSRC: INTSRC2 Position            */
N#define GP_INTSRC_INTSRC2_Msk            (0x1ul << GP_INTSRC_INTSRC2_Pos)                  /*!< GP_T::INTSRC: INTSRC2 Mask                */
N
N#define GP_INTSRC_INTSRC3_Pos            (3)                                               /*!< GP_T::INTSRC: INTSRC3 Position            */
N#define GP_INTSRC_INTSRC3_Msk            (0x1ul << GP_INTSRC_INTSRC3_Pos)                  /*!< GP_T::INTSRC: INTSRC3 Mask                */
N
N#define GP_INTSRC_INTSRC4_Pos            (4)                                               /*!< GP_T::INTSRC: INTSRC4 Position            */
N#define GP_INTSRC_INTSRC4_Msk            (0x1ul << GP_INTSRC_INTSRC4_Pos)                  /*!< GP_T::INTSRC: INTSRC4 Mask                */
N
N#define GP_INTSRC_INTSRC5_Pos            (5)                                               /*!< GP_T::INTSRC: INTSRC5 Position            */
N#define GP_INTSRC_INTSRC5_Msk            (0x1ul << GP_INTSRC_INTSRC5_Pos)                  /*!< GP_T::INTSRC: INTSRC5 Mask                */
N
N#define GP_INTSRC_INTSRC6_Pos            (6)                                               /*!< GP_T::INTSRC: INTSRC6 Position            */
N#define GP_INTSRC_INTSRC6_Msk            (0x1ul << GP_INTSRC_INTSRC6_Pos)                  /*!< GP_T::INTSRC: INTSRC6 Mask                */
N
N#define GP_INTSRC_INTSRC7_Pos            (7)                                               /*!< GP_T::INTSRC: INTSRC7 Position            */
N#define GP_INTSRC_INTSRC7_Msk            (0x1ul << GP_INTSRC_INTSRC7_Pos)                  /*!< GP_T::INTSRC: INTSRC7 Mask                */
N
N#define GP_INTSRC_INTSRC8_Pos            (8)                                               /*!< GP_T::INTSRC: INTSRC8 Position            */
N#define GP_INTSRC_INTSRC8_Msk            (0x1ul << GP_INTSRC_INTSRC8_Pos)                  /*!< GP_T::INTSRC: INTSRC8 Mask                */
N
N#define GP_INTSRC_INTSRC9_Pos            (9)                                               /*!< GP_T::INTSRC: INTSRC9 Position            */
N#define GP_INTSRC_INTSRC9_Msk            (0x1ul << GP_INTSRC_INTSRC9_Pos)                  /*!< GP_T::INTSRC: INTSRC9 Mask                */
N
N#define GP_INTSRC_INTSRC10_Pos           (10)                                              /*!< GP_T::INTSRC: INTSRC10 Position           */
N#define GP_INTSRC_INTSRC10_Msk           (0x1ul << GP_INTSRC_INTSRC10_Pos)                 /*!< GP_T::INTSRC: INTSRC10 Mask               */
N
N#define GP_INTSRC_INTSRC11_Pos           (11)                                              /*!< GP_T::INTSRC: INTSRC11 Position           */
N#define GP_INTSRC_INTSRC11_Msk           (0x1ul << GP_INTSRC_INTSRC11_Pos)                 /*!< GP_T::INTSRC: INTSRC11 Mask               */
N
N#define GP_INTSRC_INTSRC12_Pos           (12)                                              /*!< GP_T::INTSRC: INTSRC12 Position           */
N#define GP_INTSRC_INTSRC12_Msk           (0x1ul << GP_INTSRC_INTSRC12_Pos)                 /*!< GP_T::INTSRC: INTSRC12 Mask               */
N
N#define GP_INTSRC_INTSRC13_Pos           (13)                                              /*!< GP_T::INTSRC: INTSRC13 Position           */
N#define GP_INTSRC_INTSRC13_Msk           (0x1ul << GP_INTSRC_INTSRC13_Pos)                 /*!< GP_T::INTSRC: INTSRC13 Mask               */
N
N#define GP_INTSRC_INTSRC14_Pos           (14)                                              /*!< GP_T::INTSRC: INTSRC14 Position           */
N#define GP_INTSRC_INTSRC14_Msk           (0x1ul << GP_INTSRC_INTSRC14_Pos)                 /*!< GP_T::INTSRC: INTSRC14 Mask               */
N
N#define GP_INTSRC_INTSRC15_Pos           (15)                                              /*!< GP_T::INTSRC: INTSRC15 Position           */
N#define GP_INTSRC_INTSRC15_Msk           (0x1ul << GP_INTSRC_INTSRC15_Pos)                 /*!< GP_T::INTSRC: INTSRC15 Mask               */
N
N#define GP_MODE_MODE0_Pos                (0)                                               /*!< GP_T::MODE: MODE0 Position                */
N#define GP_MODE_MODE0_Msk                (0x3ul << GP_MODE_MODE0_Pos)                      /*!< GP_T::MODE: MODE0 Mask                    */
N
N#define GP_MODE_MODE1_Pos                (2)                                               /*!< GP_T::MODE: MODE1 Position                */
N#define GP_MODE_MODE1_Msk                (0x3ul << GP_MODE_MODE1_Pos)                      /*!< GP_T::MODE: MODE1 Mask                    */
N
N#define GP_MODE_MODE2_Pos                (4)                                               /*!< GP_T::MODE: MODE2 Position                */
N#define GP_MODE_MODE2_Msk                (0x3ul << GP_MODE_MODE2_Pos)                      /*!< GP_T::MODE: MODE2 Mask                    */
N
N#define GP_MODE_MODE3_Pos                (6)                                               /*!< GP_T::MODE: MODE3 Position                */
N#define GP_MODE_MODE3_Msk                (0x3ul << GP_MODE_MODE3_Pos)                      /*!< GP_T::MODE: MODE3 Mask                    */
N
N#define GP_MODE_MODE4_Pos                (8)                                               /*!< GP_T::MODE: MODE4 Position                */
N#define GP_MODE_MODE4_Msk                (0x3ul << GP_MODE_MODE4_Pos)                      /*!< GP_T::MODE: MODE4 Mask                    */
N
N#define GP_MODE_MODE5_Pos                (10)                                              /*!< GP_T::MODE: MODE5 Position                */
N#define GP_MODE_MODE5_Msk                (0x3ul << GP_MODE_MODE5_Pos)                      /*!< GP_T::MODE: MODE5 Mask                    */
N
N#define GP_DINOFF_DINOFF0_Pos            (16)                                              /*!< GP_T::DINOFF: DINOFF0 Position            */
N#define GP_DINOFF_DINOFF0_Msk            (0x1ul << GP_DINOFF_DINOFF0_Pos)                  /*!< GP_T::DINOFF: DINOFF0 Mask                */
N
N#define GP_DINOFF_DINOFF1_Pos            (17)                                              /*!< GP_T::DINOFF: DINOFF1 Position            */
N#define GP_DINOFF_DINOFF1_Msk            (0x1ul << GP_DINOFF_DINOFF1_Pos)                  /*!< GP_T::DINOFF: DINOFF1 Mask                */
N
N#define GP_DINOFF_DINOFF2_Pos            (18)                                              /*!< GP_T::DINOFF: DINOFF2 Position            */
N#define GP_DINOFF_DINOFF2_Msk            (0x1ul << GP_DINOFF_DINOFF2_Pos)                  /*!< GP_T::DINOFF: DINOFF2 Mask                */
N
N#define GP_DINOFF_DINOFF3_Pos            (19)                                              /*!< GP_T::DINOFF: DINOFF3 Position            */
N#define GP_DINOFF_DINOFF3_Msk            (0x1ul << GP_DINOFF_DINOFF3_Pos)                  /*!< GP_T::DINOFF: DINOFF3 Mask                */
N
N#define GP_DINOFF_DINOFF4_Pos            (20)                                              /*!< GP_T::DINOFF: DINOFF4 Position            */
N#define GP_DINOFF_DINOFF4_Msk            (0x1ul << GP_DINOFF_DINOFF4_Pos)                  /*!< GP_T::DINOFF: DINOFF4 Mask                */
N
N#define GP_DINOFF_DINOFF5_Pos            (21)                                              /*!< GP_T::DINOFF: DINOFF5 Position            */
N#define GP_DINOFF_DINOFF5_Msk            (0x1ul << GP_DINOFF_DINOFF5_Pos)                  /*!< GP_T::DINOFF: DINOFF5 Mask                */
N
N#define GP_DINOFF_DINOFF6_Pos            (22)                                              /*!< GP_T::DINOFF: DINOFF6 Position            */
N#define GP_DINOFF_DINOFF6_Msk            (0x1ul << GP_DINOFF_DINOFF6_Pos)                  /*!< GP_T::DINOFF: DINOFF6 Mask                */
N
N#define GP_DINOFF_DINOFF7_Pos            (23)                                              /*!< GP_T::DINOFF: DINOFF7 Position            */
N#define GP_DINOFF_DINOFF7_Msk            (0x1ul << GP_DINOFF_DINOFF7_Pos)                  /*!< GP_T::DINOFF: DINOFF7 Mask                */
N
N#define GP_DOUT_DOUT0_Pos                (0)                                               /*!< GP_T::DOUT: DOUT0 Position                */
N#define GP_DOUT_DOUT0_Msk                (0x1ul << GP_DOUT_DOUT0_Pos)                      /*!< GP_T::DOUT: DOUT0 Mask                    */
N
N#define GP_DOUT_DOUT1_Pos                (1)                                               /*!< GP_T::DOUT: DOUT1 Position                */
N#define GP_DOUT_DOUT1_Msk                (0x1ul << GP_DOUT_DOUT1_Pos)                      /*!< GP_T::DOUT: DOUT1 Mask                    */
N
N#define GP_DOUT_DOUT2_Pos                (2)                                               /*!< GP_T::DOUT: DOUT2 Position                */
N#define GP_DOUT_DOUT2_Msk                (0x1ul << GP_DOUT_DOUT2_Pos)                      /*!< GP_T::DOUT: DOUT2 Mask                    */
N
N#define GP_DOUT_DOUT3_Pos                (3)                                               /*!< GP_T::DOUT: DOUT3 Position                */
N#define GP_DOUT_DOUT3_Msk                (0x1ul << GP_DOUT_DOUT3_Pos)                      /*!< GP_T::DOUT: DOUT3 Mask                    */
N
N#define GP_DOUT_DOUT4_Pos                (4)                                               /*!< GP_T::DOUT: DOUT4 Position                */
N#define GP_DOUT_DOUT4_Msk                (0x1ul << GP_DOUT_DOUT4_Pos)                      /*!< GP_T::DOUT: DOUT4 Mask                    */
N
N#define GP_DOUT_DOUT5_Pos                (5)                                               /*!< GP_T::DOUT: DOUT5 Position                */
N#define GP_DOUT_DOUT5_Msk                (0x1ul << GP_DOUT_DOUT5_Pos)                      /*!< GP_T::DOUT: DOUT5 Mask                    */
N
N#define GP_DOUT_DOUT6_Pos                (6)                                               /*!< GP_T::DOUT: DOUT6 Position                */
N#define GP_DOUT_DOUT6_Msk                (0x1ul << GP_DOUT_DOUT6_Pos)                      /*!< GP_T::DOUT: DOUT6 Mask                    */
N
N#define GP_DOUT_DOUT7_Pos                (7)                                               /*!< GP_T::DOUT: DOUT7 Position                */
N#define GP_DOUT_DOUT7_Msk                (0x1ul << GP_DOUT_DOUT7_Pos)                      /*!< GP_T::DOUT: DOUT7 Mask                    */
N
N#define GP_DATMSK_DATMSK0_Pos            (0)                                               /*!< GP_T::DATMSK: DATMSK0 Position            */
N#define GP_DATMSK_DATMSK0_Msk            (0x1ul << GP_DATMSK_DATMSK0_Pos)                  /*!< GP_T::DATMSK: DATMSK0 Mask                */
N
N#define GP_DATMSK_DATMSK1_Pos            (1)                                               /*!< GP_T::DATMSK: DATMSK1 Position            */
N#define GP_DATMSK_DATMSK1_Msk            (0x1ul << GP_DATMSK_DATMSK1_Pos)                  /*!< GP_T::DATMSK: DATMSK1 Mask                */
N
N#define GP_DATMSK_DATMSK2_Pos            (2)                                               /*!< GP_T::DATMSK: DATMSK2 Position            */
N#define GP_DATMSK_DATMSK2_Msk            (0x1ul << GP_DATMSK_DATMSK2_Pos)                  /*!< GP_T::DATMSK: DATMSK2 Mask                */
N
N#define GP_DATMSK_DATMSK3_Pos            (3)                                               /*!< GP_T::DATMSK: DATMSK3 Position            */
N#define GP_DATMSK_DATMSK3_Msk            (0x1ul << GP_DATMSK_DATMSK3_Pos)                  /*!< GP_T::DATMSK: DATMSK3 Mask                */
N
N#define GP_DATMSK_DATMSK4_Pos            (4)                                               /*!< GP_T::DATMSK: DATMSK4 Position            */
N#define GP_DATMSK_DATMSK4_Msk            (0x1ul << GP_DATMSK_DATMSK4_Pos)                  /*!< GP_T::DATMSK: DATMSK4 Mask                */
N
N#define GP_DATMSK_DATMSK5_Pos            (5)                                               /*!< GP_T::DATMSK: DATMSK5 Position            */
N#define GP_DATMSK_DATMSK5_Msk            (0x1ul << GP_DATMSK_DATMSK5_Pos)                  /*!< GP_T::DATMSK: DATMSK5 Mask                */
N
N#define GP_DATMSK_DATMSK6_Pos            (6)                                               /*!< GP_T::DATMSK: DATMSK6 Position            */
N#define GP_DATMSK_DATMSK6_Msk            (0x1ul << GP_DATMSK_DATMSK6_Pos)                  /*!< GP_T::DATMSK: DATMSK6 Mask                */
N
N#define GP_DATMSK_DATMSK7_Pos            (7)                                               /*!< GP_T::DATMSK: DATMSK7 Position            */
N#define GP_DATMSK_DATMSK7_Msk            (0x1ul << GP_DATMSK_DATMSK7_Pos)                  /*!< GP_T::DATMSK: DATMSK7 Mask                */
N
N#define GP_PIN_PIN0_Pos                  (0)                                               /*!< GP_T::PIN: PIN0 Position                  */
N#define GP_PIN_PIN0_Msk                  (0x1ul << GP_PIN_PIN0_Pos)                        /*!< GP_T::PIN: PIN0 Mask                      */
N
N#define GP_PIN_PIN1_Pos                  (1)                                               /*!< GP_T::PIN: PIN1 Position                  */
N#define GP_PIN_PIN1_Msk                  (0x1ul << GP_PIN_PIN1_Pos)                        /*!< GP_T::PIN: PIN1 Mask                      */
N
N#define GP_PIN_PIN2_Pos                  (2)                                               /*!< GP_T::PIN: PIN2 Position                  */
N#define GP_PIN_PIN2_Msk                  (0x1ul << GP_PIN_PIN2_Pos)                        /*!< GP_T::PIN: PIN2 Mask                      */
N
N#define GP_PIN_PIN3_Pos                  (3)                                               /*!< GP_T::PIN: PIN3 Position                  */
N#define GP_PIN_PIN3_Msk                  (0x1ul << GP_PIN_PIN3_Pos)                        /*!< GP_T::PIN: PIN3 Mask                      */
N
N#define GP_PIN_PIN4_Pos                  (4)                                               /*!< GP_T::PIN: PIN4 Position                  */
N#define GP_PIN_PIN4_Msk                  (0x1ul << GP_PIN_PIN4_Pos)                        /*!< GP_T::PIN: PIN4 Mask                      */
N
N#define GP_PIN_PIN5_Pos                  (5)                                               /*!< GP_T::PIN: PIN5 Position                  */
N#define GP_PIN_PIN5_Msk                  (0x1ul << GP_PIN_PIN5_Pos)                        /*!< GP_T::PIN: PIN5 Mask                      */
N
N#define GP_PIN_PIN6_Pos                  (6)                                               /*!< GP_T::PIN: PIN6 Position                  */
N#define GP_PIN_PIN6_Msk                  (0x1ul << GP_PIN_PIN6_Pos)                        /*!< GP_T::PIN: PIN6 Mask                      */
N
N#define GP_PIN_PIN7_Pos                  (7)                                               /*!< GP_T::PIN: PIN7 Position                  */
N#define GP_PIN_PIN7_Msk                  (0x1ul << GP_PIN_PIN7_Pos)                        /*!< GP_T::PIN: PIN7 Mask                      */
N
N#define GP_DBEN_DBEN0_Pos                (0)                                               /*!< GP_T::DBEN: DBEN0 Position                */
N#define GP_DBEN_DBEN0_Msk                (0x1ul << GP_DBEN_DBEN0_Pos)                      /*!< GP_T::DBEN: DBEN0 Mask                    */
N
N#define GP_DBEN_DBEN1_Pos                (1)                                               /*!< GP_T::DBEN: DBEN1 Position                */
N#define GP_DBEN_DBEN1_Msk                (0x1ul << GP_DBEN_DBEN1_Pos)                      /*!< GP_T::DBEN: DBEN1 Mask                    */
N
N#define GP_DBEN_DBEN2_Pos                (2)                                               /*!< GP_T::DBEN: DBEN2 Position                */
N#define GP_DBEN_DBEN2_Msk                (0x1ul << GP_DBEN_DBEN2_Pos)                      /*!< GP_T::DBEN: DBEN2 Mask                    */
N
N#define GP_DBEN_DBEN3_Pos                (3)                                               /*!< GP_T::DBEN: DBEN3 Position                */
N#define GP_DBEN_DBEN3_Msk                (0x1ul << GP_DBEN_DBEN3_Pos)                      /*!< GP_T::DBEN: DBEN3 Mask                    */
N
N#define GP_DBEN_DBEN4_Pos                (4)                                               /*!< GP_T::DBEN: DBEN4 Position                */
N#define GP_DBEN_DBEN4_Msk                (0x1ul << GP_DBEN_DBEN4_Pos)                      /*!< GP_T::DBEN: DBEN4 Mask                    */
N
N#define GP_DBEN_DBEN5_Pos                (5)                                               /*!< GP_T::DBEN: DBEN5 Position                */
N#define GP_DBEN_DBEN5_Msk                (0x1ul << GP_DBEN_DBEN5_Pos)                      /*!< GP_T::DBEN: DBEN5 Mask                    */
N
N#define GP_DBEN_DBEN6_Pos                (6)                                               /*!< GP_T::DBEN: DBEN6 Position                */
N#define GP_DBEN_DBEN6_Msk                (0x1ul << GP_DBEN_DBEN6_Pos)                      /*!< GP_T::DBEN: DBEN6 Mask                    */
N
N#define GP_DBEN_DBEN7_Pos                (7)                                               /*!< GP_T::DBEN: DBEN7 Position                */
N#define GP_DBEN_DBEN7_Msk                (0x1ul << GP_DBEN_DBEN7_Pos)                      /*!< GP_T::DBEN: DBEN7 Mask                    */
N
N#define GP_INTTYPE_TYPE0_Pos             (0)                                               /*!< GP_T::INTTYPE: TYPE0 Position             */
N#define GP_INTTYPE_TYPE0_Msk             (0x1ul << GP_INTTYPE_TYPE0_Pos)                   /*!< GP_T::INTTYPE: TYPE0 Mask                 */
N
N#define GP_INTTYPE_TYPE1_Pos             (1)                                               /*!< GP_T::INTTYPE: TYPE1 Position             */
N#define GP_INTTYPE_TYPE1_Msk             (0x1ul << GP_INTTYPE_TYPE1_Pos)                   /*!< GP_T::INTTYPE: TYPE1 Mask                 */
N
N#define GP_INTTYPE_TYPE2_Pos             (2)                                               /*!< GP_T::INTTYPE: TYPE2 Position             */
N#define GP_INTTYPE_TYPE2_Msk             (0x1ul << GP_INTTYPE_TYPE2_Pos)                   /*!< GP_T::INTTYPE: TYPE2 Mask                 */
N
N#define GP_INTTYPE_TYPE3_Pos             (3)                                               /*!< GP_T::INTTYPE: TYPE3 Position             */
N#define GP_INTTYPE_TYPE3_Msk             (0x1ul << GP_INTTYPE_TYPE3_Pos)                   /*!< GP_T::INTTYPE: TYPE3 Mask                 */
N
N#define GP_INTTYPE_TYPE4_Pos             (4)                                               /*!< GP_T::INTTYPE: TYPE4 Position             */
N#define GP_INTTYPE_TYPE4_Msk             (0x1ul << GP_INTTYPE_TYPE4_Pos)                   /*!< GP_T::INTTYPE: TYPE4 Mask                 */
N
N#define GP_INTTYPE_TYPE5_Pos             (5)                                               /*!< GP_T::INTTYPE: TYPE5 Position             */
N#define GP_INTTYPE_TYPE5_Msk             (0x1ul << GP_INTTYPE_TYPE5_Pos)                   /*!< GP_T::INTTYPE: TYPE5 Mask                 */
N
N#define GP_INTTYPE_TYPE6_Pos             (6)                                               /*!< GP_T::INTTYPE: TYPE6 Position             */
N#define GP_INTTYPE_TYPE6_Msk             (0x1ul << GP_INTTYPE_TYPE6_Pos)                   /*!< GP_T::INTTYPE: TYPE6 Mask                 */
N
N#define GP_INTTYPE_TYPE7_Pos             (7)                                               /*!< GP_T::INTTYPE: TYPE7 Position             */
N#define GP_INTTYPE_TYPE7_Msk             (0x1ul << GP_INTTYPE_TYPE7_Pos)                   /*!< GP_T::INTTYPE: TYPE7 Mask                 */
N
N#define GP_INTEN_FLIEN0_Pos              (0)                                               /*!< GP_T::INTEN: FLIEN0 Position              */
N#define GP_INTEN_FLIEN0_Msk              (0x1ul << GP_INTEN_FLIEN0_Pos)                    /*!< GP_T::INTEN: FLIEN0 Mask                  */
N
N#define GP_INTEN_FLIEN1_Pos              (1)                                               /*!< GP_T::INTEN: FLIEN1 Position              */
N#define GP_INTEN_FLIEN1_Msk              (0x1ul << GP_INTEN_FLIEN1_Pos)                    /*!< GP_T::INTEN: FLIEN1 Mask                  */
N
N#define GP_INTEN_FLIEN2_Pos              (2)                                               /*!< GP_T::INTEN: FLIEN2 Position              */
N#define GP_INTEN_FLIEN2_Msk              (0x1ul << GP_INTEN_FLIEN2_Pos)                    /*!< GP_T::INTEN: FLIEN2 Mask                  */
N
N#define GP_INTEN_FLIEN3_Pos              (3)                                               /*!< GP_T::INTEN: FLIEN3 Position              */
N#define GP_INTEN_FLIEN3_Msk              (0x1ul << GP_INTEN_FLIEN3_Pos)                    /*!< GP_T::INTEN: FLIEN3 Mask                  */
N
N#define GP_INTEN_FLIEN4_Pos              (4)                                               /*!< GP_T::INTEN: FLIEN4 Position              */
N#define GP_INTEN_FLIEN4_Msk              (0x1ul << GP_INTEN_FLIEN4_Pos)                    /*!< GP_T::INTEN: FLIEN4 Mask                  */
N
N#define GP_INTEN_FLIEN5_Pos              (5)                                               /*!< GP_T::INTEN: FLIEN5 Position              */
N#define GP_INTEN_FLIEN5_Msk              (0x1ul << GP_INTEN_FLIEN5_Pos)                    /*!< GP_T::INTEN: FLIEN5 Mask                  */
N
N#define GP_INTEN_FLIEN6_Pos              (6)                                               /*!< GP_T::INTEN: FLIEN6 Position              */
N#define GP_INTEN_FLIEN6_Msk              (0x1ul << GP_INTEN_FLIEN6_Pos)                    /*!< GP_T::INTEN: FLIEN6 Mask                  */
N
N#define GP_INTEN_FLIEN7_Pos              (7)                                               /*!< GP_T::INTEN: FLIEN7 Position              */
N#define GP_INTEN_FLIEN7_Msk              (0x1ul << GP_INTEN_FLIEN7_Pos)                    /*!< GP_T::INTEN: FLIEN7 Mask                  */
N
N#define GP_INTEN_RHIEN0_Pos              (16)                                              /*!< GP_T::INTEN: RHIEN0 Position              */
N#define GP_INTEN_RHIEN0_Msk              (0x1ul << GP_INTEN_RHIEN0_Pos)                    /*!< GP_T::INTEN: RHIEN0 Mask                  */
N
N#define GP_INTEN_RHIEN1_Pos              (17)                                              /*!< GP_T::INTEN: RHIEN1 Position              */
N#define GP_INTEN_RHIEN1_Msk              (0x1ul << GP_INTEN_RHIEN1_Pos)                    /*!< GP_T::INTEN: RHIEN1 Mask                  */
N
N#define GP_INTEN_RHIEN2_Pos              (18)                                              /*!< GP_T::INTEN: RHIEN2 Position              */
N#define GP_INTEN_RHIEN2_Msk              (0x1ul << GP_INTEN_RHIEN2_Pos)                    /*!< GP_T::INTEN: RHIEN2 Mask                  */
N
N#define GP_INTEN_RHIEN3_Pos              (19)                                              /*!< GP_T::INTEN: RHIEN3 Position              */
N#define GP_INTEN_RHIEN3_Msk              (0x1ul << GP_INTEN_RHIEN3_Pos)                    /*!< GP_T::INTEN: RHIEN3 Mask                  */
N
N#define GP_INTEN_RHIEN4_Pos              (20)                                              /*!< GP_T::INTEN: RHIEN4 Position              */
N#define GP_INTEN_RHIEN4_Msk              (0x1ul << GP_INTEN_RHIEN4_Pos)                    /*!< GP_T::INTEN: RHIEN4 Mask                  */
N
N#define GP_INTEN_RHIEN5_Pos              (21)                                              /*!< GP_T::INTEN: RHIEN5 Position              */
N#define GP_INTEN_RHIEN5_Msk              (0x1ul << GP_INTEN_RHIEN5_Pos)                    /*!< GP_T::INTEN: RHIEN5 Mask                  */
N
N#define GP_INTEN_RHIEN6_Pos              (22)                                              /*!< GP_T::INTEN: RHIEN6 Position              */
N#define GP_INTEN_RHIEN6_Msk              (0x1ul << GP_INTEN_RHIEN6_Pos)                    /*!< GP_T::INTEN: RHIEN6 Mask                  */
N
N#define GP_INTEN_RHIEN7_Pos              (23)                                              /*!< GP_T::INTEN: RHIEN7 Position              */
N#define GP_INTEN_RHIEN7_Msk              (0x1ul << GP_INTEN_RHIEN7_Pos)                    /*!< GP_T::INTEN: RHIEN7 Mask                  */
N
N#define GP_INTSRC_INTSRC0_Pos            (0)                                               /*!< GP_T::INTSRC: INTSRC0 Position            */
N#define GP_INTSRC_INTSRC0_Msk            (0x1ul << GP_INTSRC_INTSRC0_Pos)                  /*!< GP_T::INTSRC: INTSRC0 Mask                */
N
N#define GP_INTSRC_INTSRC1_Pos            (1)                                               /*!< GP_T::INTSRC: INTSRC1 Position            */
N#define GP_INTSRC_INTSRC1_Msk            (0x1ul << GP_INTSRC_INTSRC1_Pos)                  /*!< GP_T::INTSRC: INTSRC1 Mask                */
N
N#define GP_INTSRC_INTSRC2_Pos            (2)                                               /*!< GP_T::INTSRC: INTSRC2 Position            */
N#define GP_INTSRC_INTSRC2_Msk            (0x1ul << GP_INTSRC_INTSRC2_Pos)                  /*!< GP_T::INTSRC: INTSRC2 Mask                */
N
N#define GP_INTSRC_INTSRC3_Pos            (3)                                               /*!< GP_T::INTSRC: INTSRC3 Position            */
N#define GP_INTSRC_INTSRC3_Msk            (0x1ul << GP_INTSRC_INTSRC3_Pos)                  /*!< GP_T::INTSRC: INTSRC3 Mask                */
N
N#define GP_INTSRC_INTSRC4_Pos            (4)                                               /*!< GP_T::INTSRC: INTSRC4 Position            */
N#define GP_INTSRC_INTSRC4_Msk            (0x1ul << GP_INTSRC_INTSRC4_Pos)                  /*!< GP_T::INTSRC: INTSRC4 Mask                */
N
N#define GP_INTSRC_INTSRC5_Pos            (5)                                               /*!< GP_T::INTSRC: INTSRC5 Position            */
N#define GP_INTSRC_INTSRC5_Msk            (0x1ul << GP_INTSRC_INTSRC5_Pos)                  /*!< GP_T::INTSRC: INTSRC5 Mask                */
N
N#define GP_INTSRC_INTSRC6_Pos            (6)                                               /*!< GP_T::INTSRC: INTSRC6 Position            */
N#define GP_INTSRC_INTSRC6_Msk            (0x1ul << GP_INTSRC_INTSRC6_Pos)                  /*!< GP_T::INTSRC: INTSRC6 Mask                */
N
N#define GP_INTSRC_INTSRC7_Pos            (7)                                               /*!< GP_T::INTSRC: INTSRC7 Position            */
N#define GP_INTSRC_INTSRC7_Msk            (0x1ul << GP_INTSRC_INTSRC7_Pos)                  /*!< GP_T::INTSRC: INTSRC7 Mask                */
N
N#define GP_INTSRC_INTSRC8_Pos            (8)                                               /*!< GP_T::INTSRC: INTSRC8 Position            */
N#define GP_INTSRC_INTSRC8_Msk            (0x1ul << GP_INTSRC_INTSRC8_Pos)                  /*!< GP_T::INTSRC: INTSRC8 Mask                */
N
N#define GP_INTSRC_INTSRC9_Pos            (9)                                               /*!< GP_T::INTSRC: INTSRC9 Position            */
N#define GP_INTSRC_INTSRC9_Msk            (0x1ul << GP_INTSRC_INTSRC9_Pos)                  /*!< GP_T::INTSRC: INTSRC9 Mask                */
N
N#define GP_INTSRC_INTSRC10_Pos           (10)                                              /*!< GP_T::INTSRC: INTSRC10 Position           */
N#define GP_INTSRC_INTSRC10_Msk           (0x1ul << GP_INTSRC_INTSRC10_Pos)                 /*!< GP_T::INTSRC: INTSRC10 Mask               */
N
N#define GP_INTSRC_INTSRC11_Pos           (11)                                              /*!< GP_T::INTSRC: INTSRC11 Position           */
N#define GP_INTSRC_INTSRC11_Msk           (0x1ul << GP_INTSRC_INTSRC11_Pos)                 /*!< GP_T::INTSRC: INTSRC11 Mask               */
N
N#define GP_INTSRC_INTSRC12_Pos           (12)                                              /*!< GP_T::INTSRC: INTSRC12 Position           */
N#define GP_INTSRC_INTSRC12_Msk           (0x1ul << GP_INTSRC_INTSRC12_Pos)                 /*!< GP_T::INTSRC: INTSRC12 Mask               */
N
N#define GP_INTSRC_INTSRC13_Pos           (13)                                              /*!< GP_T::INTSRC: INTSRC13 Position           */
N#define GP_INTSRC_INTSRC13_Msk           (0x1ul << GP_INTSRC_INTSRC13_Pos)                 /*!< GP_T::INTSRC: INTSRC13 Mask               */
N
N#define GP_INTSRC_INTSRC14_Pos           (14)                                              /*!< GP_T::INTSRC: INTSRC14 Position           */
N#define GP_INTSRC_INTSRC14_Msk           (0x1ul << GP_INTSRC_INTSRC14_Pos)                 /*!< GP_T::INTSRC: INTSRC14 Mask               */
N
N#define GP_INTSRC_INTSRC15_Pos           (15)                                              /*!< GP_T::INTSRC: INTSRC15 Position           */
N#define GP_INTSRC_INTSRC15_Msk           (0x1ul << GP_INTSRC_INTSRC15_Pos)                 /*!< GP_T::INTSRC: INTSRC15 Mask               */
N
N#define GP_MODE_MODE0_Pos                (0)                                               /*!< GP_T::MODE: MODE0 Position                */
N#define GP_MODE_MODE0_Msk                (0x3ul << GP_MODE_MODE0_Pos)                      /*!< GP_T::MODE: MODE0 Mask                    */
N
N#define GP_MODE_MODE1_Pos                (2)                                               /*!< GP_T::MODE: MODE1 Position                */
N#define GP_MODE_MODE1_Msk                (0x3ul << GP_MODE_MODE1_Pos)                      /*!< GP_T::MODE: MODE1 Mask                    */
N
N#define GP_MODE_MODE2_Pos                (4)                                               /*!< GP_T::MODE: MODE2 Position                */
N#define GP_MODE_MODE2_Msk                (0x3ul << GP_MODE_MODE2_Pos)                      /*!< GP_T::MODE: MODE2 Mask                    */
N
N#define GP_MODE_MODE3_Pos                (6)                                               /*!< GP_T::MODE: MODE3 Position                */
N#define GP_MODE_MODE3_Msk                (0x3ul << GP_MODE_MODE3_Pos)                      /*!< GP_T::MODE: MODE3 Mask                    */
N
N#define GP_MODE_MODE4_Pos                (8)                                               /*!< GP_T::MODE: MODE4 Position                */
N#define GP_MODE_MODE4_Msk                (0x3ul << GP_MODE_MODE4_Pos)                      /*!< GP_T::MODE: MODE4 Mask                    */
N
N#define GP_MODE_MODE5_Pos                (10)                                              /*!< GP_T::MODE: MODE5 Position                */
N#define GP_MODE_MODE5_Msk                (0x3ul << GP_MODE_MODE5_Pos)                      /*!< GP_T::MODE: MODE5 Mask                    */
N
N#define GP_DINOFF_DINOFF0_Pos            (16)                                              /*!< GP_T::DINOFF: DINOFF0 Position            */
N#define GP_DINOFF_DINOFF0_Msk            (0x1ul << GP_DINOFF_DINOFF0_Pos)                  /*!< GP_T::DINOFF: DINOFF0 Mask                */
N
N#define GP_DINOFF_DINOFF1_Pos            (17)                                              /*!< GP_T::DINOFF: DINOFF1 Position            */
N#define GP_DINOFF_DINOFF1_Msk            (0x1ul << GP_DINOFF_DINOFF1_Pos)                  /*!< GP_T::DINOFF: DINOFF1 Mask                */
N
N#define GP_DINOFF_DINOFF2_Pos            (18)                                              /*!< GP_T::DINOFF: DINOFF2 Position            */
N#define GP_DINOFF_DINOFF2_Msk            (0x1ul << GP_DINOFF_DINOFF2_Pos)                  /*!< GP_T::DINOFF: DINOFF2 Mask                */
N
N#define GP_DINOFF_DINOFF3_Pos            (19)                                              /*!< GP_T::DINOFF: DINOFF3 Position            */
N#define GP_DINOFF_DINOFF3_Msk            (0x1ul << GP_DINOFF_DINOFF3_Pos)                  /*!< GP_T::DINOFF: DINOFF3 Mask                */
N
N#define GP_DINOFF_DINOFF4_Pos            (20)                                              /*!< GP_T::DINOFF: DINOFF4 Position            */
N#define GP_DINOFF_DINOFF4_Msk            (0x1ul << GP_DINOFF_DINOFF4_Pos)                  /*!< GP_T::DINOFF: DINOFF4 Mask                */
N
N#define GP_DINOFF_DINOFF5_Pos            (21)                                              /*!< GP_T::DINOFF: DINOFF5 Position            */
N#define GP_DINOFF_DINOFF5_Msk            (0x1ul << GP_DINOFF_DINOFF5_Pos)                  /*!< GP_T::DINOFF: DINOFF5 Mask                */
N
N#define GP_DINOFF_DINOFF6_Pos            (22)                                              /*!< GP_T::DINOFF: DINOFF6 Position            */
N#define GP_DINOFF_DINOFF6_Msk            (0x1ul << GP_DINOFF_DINOFF6_Pos)                  /*!< GP_T::DINOFF: DINOFF6 Mask                */
N
N#define GP_DINOFF_DINOFF7_Pos            (23)                                              /*!< GP_T::DINOFF: DINOFF7 Position            */
N#define GP_DINOFF_DINOFF7_Msk            (0x1ul << GP_DINOFF_DINOFF7_Pos)                  /*!< GP_T::DINOFF: DINOFF7 Mask                */
N
N#define GP_DOUT_DOUT0_Pos                (0)                                               /*!< GP_T::DOUT: DOUT0 Position                */
N#define GP_DOUT_DOUT0_Msk                (0x1ul << GP_DOUT_DOUT0_Pos)                      /*!< GP_T::DOUT: DOUT0 Mask                    */
N
N#define GP_DOUT_DOUT1_Pos                (1)                                               /*!< GP_T::DOUT: DOUT1 Position                */
N#define GP_DOUT_DOUT1_Msk                (0x1ul << GP_DOUT_DOUT1_Pos)                      /*!< GP_T::DOUT: DOUT1 Mask                    */
N
N#define GP_DOUT_DOUT2_Pos                (2)                                               /*!< GP_T::DOUT: DOUT2 Position                */
N#define GP_DOUT_DOUT2_Msk                (0x1ul << GP_DOUT_DOUT2_Pos)                      /*!< GP_T::DOUT: DOUT2 Mask                    */
N
N#define GP_DOUT_DOUT3_Pos                (3)                                               /*!< GP_T::DOUT: DOUT3 Position                */
N#define GP_DOUT_DOUT3_Msk                (0x1ul << GP_DOUT_DOUT3_Pos)                      /*!< GP_T::DOUT: DOUT3 Mask                    */
N
N#define GP_DOUT_DOUT4_Pos                (4)                                               /*!< GP_T::DOUT: DOUT4 Position                */
N#define GP_DOUT_DOUT4_Msk                (0x1ul << GP_DOUT_DOUT4_Pos)                      /*!< GP_T::DOUT: DOUT4 Mask                    */
N
N#define GP_DOUT_DOUT5_Pos                (5)                                               /*!< GP_T::DOUT: DOUT5 Position                */
N#define GP_DOUT_DOUT5_Msk                (0x1ul << GP_DOUT_DOUT5_Pos)                      /*!< GP_T::DOUT: DOUT5 Mask                    */
N
N#define GP_DOUT_DOUT6_Pos                (6)                                               /*!< GP_T::DOUT: DOUT6 Position                */
N#define GP_DOUT_DOUT6_Msk                (0x1ul << GP_DOUT_DOUT6_Pos)                      /*!< GP_T::DOUT: DOUT6 Mask                    */
N
N#define GP_DOUT_DOUT7_Pos                (7)                                               /*!< GP_T::DOUT: DOUT7 Position                */
N#define GP_DOUT_DOUT7_Msk                (0x1ul << GP_DOUT_DOUT7_Pos)                      /*!< GP_T::DOUT: DOUT7 Mask                    */
N
N#define GP_DATMSK_DATMSK0_Pos            (0)                                               /*!< GP_T::DATMSK: DATMSK0 Position            */
N#define GP_DATMSK_DATMSK0_Msk            (0x1ul << GP_DATMSK_DATMSK0_Pos)                  /*!< GP_T::DATMSK: DATMSK0 Mask                */
N
N#define GP_DATMSK_DATMSK1_Pos            (1)                                               /*!< GP_T::DATMSK: DATMSK1 Position            */
N#define GP_DATMSK_DATMSK1_Msk            (0x1ul << GP_DATMSK_DATMSK1_Pos)                  /*!< GP_T::DATMSK: DATMSK1 Mask                */
N
N#define GP_DATMSK_DATMSK2_Pos            (2)                                               /*!< GP_T::DATMSK: DATMSK2 Position            */
N#define GP_DATMSK_DATMSK2_Msk            (0x1ul << GP_DATMSK_DATMSK2_Pos)                  /*!< GP_T::DATMSK: DATMSK2 Mask                */
N
N#define GP_DATMSK_DATMSK3_Pos            (3)                                               /*!< GP_T::DATMSK: DATMSK3 Position            */
N#define GP_DATMSK_DATMSK3_Msk            (0x1ul << GP_DATMSK_DATMSK3_Pos)                  /*!< GP_T::DATMSK: DATMSK3 Mask                */
N
N#define GP_DATMSK_DATMSK4_Pos            (4)                                               /*!< GP_T::DATMSK: DATMSK4 Position            */
N#define GP_DATMSK_DATMSK4_Msk            (0x1ul << GP_DATMSK_DATMSK4_Pos)                  /*!< GP_T::DATMSK: DATMSK4 Mask                */
N
N#define GP_DATMSK_DATMSK5_Pos            (5)                                               /*!< GP_T::DATMSK: DATMSK5 Position            */
N#define GP_DATMSK_DATMSK5_Msk            (0x1ul << GP_DATMSK_DATMSK5_Pos)                  /*!< GP_T::DATMSK: DATMSK5 Mask                */
N
N#define GP_DATMSK_DATMSK6_Pos            (6)                                               /*!< GP_T::DATMSK: DATMSK6 Position            */
N#define GP_DATMSK_DATMSK6_Msk            (0x1ul << GP_DATMSK_DATMSK6_Pos)                  /*!< GP_T::DATMSK: DATMSK6 Mask                */
N
N#define GP_DATMSK_DATMSK7_Pos            (7)                                               /*!< GP_T::DATMSK: DATMSK7 Position            */
N#define GP_DATMSK_DATMSK7_Msk            (0x1ul << GP_DATMSK_DATMSK7_Pos)                  /*!< GP_T::DATMSK: DATMSK7 Mask                */
N
N#define GP_PIN_PIN0_Pos                  (0)                                               /*!< GP_T::PIN: PIN0 Position                  */
N#define GP_PIN_PIN0_Msk                  (0x1ul << GP_PIN_PIN0_Pos)                        /*!< GP_T::PIN: PIN0 Mask                      */
N
N#define GP_PIN_PIN1_Pos                  (1)                                               /*!< GP_T::PIN: PIN1 Position                  */
N#define GP_PIN_PIN1_Msk                  (0x1ul << GP_PIN_PIN1_Pos)                        /*!< GP_T::PIN: PIN1 Mask                      */
N
N#define GP_PIN_PIN2_Pos                  (2)                                               /*!< GP_T::PIN: PIN2 Position                  */
N#define GP_PIN_PIN2_Msk                  (0x1ul << GP_PIN_PIN2_Pos)                        /*!< GP_T::PIN: PIN2 Mask                      */
N
N#define GP_PIN_PIN3_Pos                  (3)                                               /*!< GP_T::PIN: PIN3 Position                  */
N#define GP_PIN_PIN3_Msk                  (0x1ul << GP_PIN_PIN3_Pos)                        /*!< GP_T::PIN: PIN3 Mask                      */
N
N#define GP_PIN_PIN4_Pos                  (4)                                               /*!< GP_T::PIN: PIN4 Position                  */
N#define GP_PIN_PIN4_Msk                  (0x1ul << GP_PIN_PIN4_Pos)                        /*!< GP_T::PIN: PIN4 Mask                      */
N
N#define GP_PIN_PIN5_Pos                  (5)                                               /*!< GP_T::PIN: PIN5 Position                  */
N#define GP_PIN_PIN5_Msk                  (0x1ul << GP_PIN_PIN5_Pos)                        /*!< GP_T::PIN: PIN5 Mask                      */
N
N#define GP_PIN_PIN6_Pos                  (6)                                               /*!< GP_T::PIN: PIN6 Position                  */
N#define GP_PIN_PIN6_Msk                  (0x1ul << GP_PIN_PIN6_Pos)                        /*!< GP_T::PIN: PIN6 Mask                      */
N
N#define GP_PIN_PIN7_Pos                  (7)                                               /*!< GP_T::PIN: PIN7 Position                  */
N#define GP_PIN_PIN7_Msk                  (0x1ul << GP_PIN_PIN7_Pos)                        /*!< GP_T::PIN: PIN7 Mask                      */
N
N#define GP_DBEN_DBEN0_Pos                (0)                                               /*!< GP_T::DBEN: DBEN0 Position                */
N#define GP_DBEN_DBEN0_Msk                (0x1ul << GP_DBEN_DBEN0_Pos)                      /*!< GP_T::DBEN: DBEN0 Mask                    */
N
N#define GP_DBEN_DBEN1_Pos                (1)                                               /*!< GP_T::DBEN: DBEN1 Position                */
N#define GP_DBEN_DBEN1_Msk                (0x1ul << GP_DBEN_DBEN1_Pos)                      /*!< GP_T::DBEN: DBEN1 Mask                    */
N
N#define GP_DBEN_DBEN2_Pos                (2)                                               /*!< GP_T::DBEN: DBEN2 Position                */
N#define GP_DBEN_DBEN2_Msk                (0x1ul << GP_DBEN_DBEN2_Pos)                      /*!< GP_T::DBEN: DBEN2 Mask                    */
N
N#define GP_DBEN_DBEN3_Pos                (3)                                               /*!< GP_T::DBEN: DBEN3 Position                */
N#define GP_DBEN_DBEN3_Msk                (0x1ul << GP_DBEN_DBEN3_Pos)                      /*!< GP_T::DBEN: DBEN3 Mask                    */
N
N#define GP_DBEN_DBEN4_Pos                (4)                                               /*!< GP_T::DBEN: DBEN4 Position                */
N#define GP_DBEN_DBEN4_Msk                (0x1ul << GP_DBEN_DBEN4_Pos)                      /*!< GP_T::DBEN: DBEN4 Mask                    */
N
N#define GP_DBEN_DBEN5_Pos                (5)                                               /*!< GP_T::DBEN: DBEN5 Position                */
N#define GP_DBEN_DBEN5_Msk                (0x1ul << GP_DBEN_DBEN5_Pos)                      /*!< GP_T::DBEN: DBEN5 Mask                    */
N
N#define GP_DBEN_DBEN6_Pos                (6)                                               /*!< GP_T::DBEN: DBEN6 Position                */
N#define GP_DBEN_DBEN6_Msk                (0x1ul << GP_DBEN_DBEN6_Pos)                      /*!< GP_T::DBEN: DBEN6 Mask                    */
N
N#define GP_DBEN_DBEN7_Pos                (7)                                               /*!< GP_T::DBEN: DBEN7 Position                */
N#define GP_DBEN_DBEN7_Msk                (0x1ul << GP_DBEN_DBEN7_Pos)                      /*!< GP_T::DBEN: DBEN7 Mask                    */
N
N#define GP_INTTYPE_TYPE0_Pos             (0)                                               /*!< GP_T::INTTYPE: TYPE0 Position             */
N#define GP_INTTYPE_TYPE0_Msk             (0x1ul << GP_INTTYPE_TYPE0_Pos)                   /*!< GP_T::INTTYPE: TYPE0 Mask                 */
N
N#define GP_INTTYPE_TYPE1_Pos             (1)                                               /*!< GP_T::INTTYPE: TYPE1 Position             */
N#define GP_INTTYPE_TYPE1_Msk             (0x1ul << GP_INTTYPE_TYPE1_Pos)                   /*!< GP_T::INTTYPE: TYPE1 Mask                 */
N
N#define GP_INTTYPE_TYPE2_Pos             (2)                                               /*!< GP_T::INTTYPE: TYPE2 Position             */
N#define GP_INTTYPE_TYPE2_Msk             (0x1ul << GP_INTTYPE_TYPE2_Pos)                   /*!< GP_T::INTTYPE: TYPE2 Mask                 */
N
N#define GP_INTTYPE_TYPE3_Pos             (3)                                               /*!< GP_T::INTTYPE: TYPE3 Position             */
N#define GP_INTTYPE_TYPE3_Msk             (0x1ul << GP_INTTYPE_TYPE3_Pos)                   /*!< GP_T::INTTYPE: TYPE3 Mask                 */
N
N#define GP_INTTYPE_TYPE4_Pos             (4)                                               /*!< GP_T::INTTYPE: TYPE4 Position             */
N#define GP_INTTYPE_TYPE4_Msk             (0x1ul << GP_INTTYPE_TYPE4_Pos)                   /*!< GP_T::INTTYPE: TYPE4 Mask                 */
N
N#define GP_INTTYPE_TYPE5_Pos             (5)                                               /*!< GP_T::INTTYPE: TYPE5 Position             */
N#define GP_INTTYPE_TYPE5_Msk             (0x1ul << GP_INTTYPE_TYPE5_Pos)                   /*!< GP_T::INTTYPE: TYPE5 Mask                 */
N
N#define GP_INTTYPE_TYPE6_Pos             (6)                                               /*!< GP_T::INTTYPE: TYPE6 Position             */
N#define GP_INTTYPE_TYPE6_Msk             (0x1ul << GP_INTTYPE_TYPE6_Pos)                   /*!< GP_T::INTTYPE: TYPE6 Mask                 */
N
N#define GP_INTTYPE_TYPE7_Pos             (7)                                               /*!< GP_T::INTTYPE: TYPE7 Position             */
N#define GP_INTTYPE_TYPE7_Msk             (0x1ul << GP_INTTYPE_TYPE7_Pos)                   /*!< GP_T::INTTYPE: TYPE7 Mask                 */
N
N#define GP_INTEN_FLIEN0_Pos              (0)                                               /*!< GP_T::INTEN: FLIEN0 Position              */
N#define GP_INTEN_FLIEN0_Msk              (0x1ul << GP_INTEN_FLIEN0_Pos)                    /*!< GP_T::INTEN: FLIEN0 Mask                  */
N
N#define GP_INTEN_FLIEN1_Pos              (1)                                               /*!< GP_T::INTEN: FLIEN1 Position              */
N#define GP_INTEN_FLIEN1_Msk              (0x1ul << GP_INTEN_FLIEN1_Pos)                    /*!< GP_T::INTEN: FLIEN1 Mask                  */
N
N#define GP_INTEN_FLIEN2_Pos              (2)                                               /*!< GP_T::INTEN: FLIEN2 Position              */
N#define GP_INTEN_FLIEN2_Msk              (0x1ul << GP_INTEN_FLIEN2_Pos)                    /*!< GP_T::INTEN: FLIEN2 Mask                  */
N
N#define GP_INTEN_FLIEN3_Pos              (3)                                               /*!< GP_T::INTEN: FLIEN3 Position              */
N#define GP_INTEN_FLIEN3_Msk              (0x1ul << GP_INTEN_FLIEN3_Pos)                    /*!< GP_T::INTEN: FLIEN3 Mask                  */
N
N#define GP_INTEN_FLIEN4_Pos              (4)                                               /*!< GP_T::INTEN: FLIEN4 Position              */
N#define GP_INTEN_FLIEN4_Msk              (0x1ul << GP_INTEN_FLIEN4_Pos)                    /*!< GP_T::INTEN: FLIEN4 Mask                  */
N
N#define GP_INTEN_FLIEN5_Pos              (5)                                               /*!< GP_T::INTEN: FLIEN5 Position              */
N#define GP_INTEN_FLIEN5_Msk              (0x1ul << GP_INTEN_FLIEN5_Pos)                    /*!< GP_T::INTEN: FLIEN5 Mask                  */
N
N#define GP_INTEN_FLIEN6_Pos              (6)                                               /*!< GP_T::INTEN: FLIEN6 Position              */
N#define GP_INTEN_FLIEN6_Msk              (0x1ul << GP_INTEN_FLIEN6_Pos)                    /*!< GP_T::INTEN: FLIEN6 Mask                  */
N
N#define GP_INTEN_FLIEN7_Pos              (7)                                               /*!< GP_T::INTEN: FLIEN7 Position              */
N#define GP_INTEN_FLIEN7_Msk              (0x1ul << GP_INTEN_FLIEN7_Pos)                    /*!< GP_T::INTEN: FLIEN7 Mask                  */
N
N#define GP_INTEN_RHIEN0_Pos              (16)                                              /*!< GP_T::INTEN: RHIEN0 Position              */
N#define GP_INTEN_RHIEN0_Msk              (0x1ul << GP_INTEN_RHIEN0_Pos)                    /*!< GP_T::INTEN: RHIEN0 Mask                  */
N
N#define GP_INTEN_RHIEN1_Pos              (17)                                              /*!< GP_T::INTEN: RHIEN1 Position              */
N#define GP_INTEN_RHIEN1_Msk              (0x1ul << GP_INTEN_RHIEN1_Pos)                    /*!< GP_T::INTEN: RHIEN1 Mask                  */
N
N#define GP_INTEN_RHIEN2_Pos              (18)                                              /*!< GP_T::INTEN: RHIEN2 Position              */
N#define GP_INTEN_RHIEN2_Msk              (0x1ul << GP_INTEN_RHIEN2_Pos)                    /*!< GP_T::INTEN: RHIEN2 Mask                  */
N
N#define GP_INTEN_RHIEN3_Pos              (19)                                              /*!< GP_T::INTEN: RHIEN3 Position              */
N#define GP_INTEN_RHIEN3_Msk              (0x1ul << GP_INTEN_RHIEN3_Pos)                    /*!< GP_T::INTEN: RHIEN3 Mask                  */
N
N#define GP_INTEN_RHIEN4_Pos              (20)                                              /*!< GP_T::INTEN: RHIEN4 Position              */
N#define GP_INTEN_RHIEN4_Msk              (0x1ul << GP_INTEN_RHIEN4_Pos)                    /*!< GP_T::INTEN: RHIEN4 Mask                  */
N
N#define GP_INTEN_RHIEN5_Pos              (21)                                              /*!< GP_T::INTEN: RHIEN5 Position              */
N#define GP_INTEN_RHIEN5_Msk              (0x1ul << GP_INTEN_RHIEN5_Pos)                    /*!< GP_T::INTEN: RHIEN5 Mask                  */
N
N#define GP_INTEN_RHIEN6_Pos              (22)                                              /*!< GP_T::INTEN: RHIEN6 Position              */
N#define GP_INTEN_RHIEN6_Msk              (0x1ul << GP_INTEN_RHIEN6_Pos)                    /*!< GP_T::INTEN: RHIEN6 Mask                  */
N
N#define GP_INTEN_RHIEN7_Pos              (23)                                              /*!< GP_T::INTEN: RHIEN7 Position              */
N#define GP_INTEN_RHIEN7_Msk              (0x1ul << GP_INTEN_RHIEN7_Pos)                    /*!< GP_T::INTEN: RHIEN7 Mask                  */
N
N#define GP_INTSRC_INTSRC0_Pos            (0)                                               /*!< GP_T::INTSRC: INTSRC0 Position            */
N#define GP_INTSRC_INTSRC0_Msk            (0x1ul << GP_INTSRC_INTSRC0_Pos)                  /*!< GP_T::INTSRC: INTSRC0 Mask                */
N
N#define GP_INTSRC_INTSRC1_Pos            (1)                                               /*!< GP_T::INTSRC: INTSRC1 Position            */
N#define GP_INTSRC_INTSRC1_Msk            (0x1ul << GP_INTSRC_INTSRC1_Pos)                  /*!< GP_T::INTSRC: INTSRC1 Mask                */
N
N#define GP_INTSRC_INTSRC2_Pos            (2)                                               /*!< GP_T::INTSRC: INTSRC2 Position            */
N#define GP_INTSRC_INTSRC2_Msk            (0x1ul << GP_INTSRC_INTSRC2_Pos)                  /*!< GP_T::INTSRC: INTSRC2 Mask                */
N
N#define GP_INTSRC_INTSRC3_Pos            (3)                                               /*!< GP_T::INTSRC: INTSRC3 Position            */
N#define GP_INTSRC_INTSRC3_Msk            (0x1ul << GP_INTSRC_INTSRC3_Pos)                  /*!< GP_T::INTSRC: INTSRC3 Mask                */
N
N#define GP_INTSRC_INTSRC4_Pos            (4)                                               /*!< GP_T::INTSRC: INTSRC4 Position            */
N#define GP_INTSRC_INTSRC4_Msk            (0x1ul << GP_INTSRC_INTSRC4_Pos)                  /*!< GP_T::INTSRC: INTSRC4 Mask                */
N
N#define GP_INTSRC_INTSRC5_Pos            (5)                                               /*!< GP_T::INTSRC: INTSRC5 Position            */
N#define GP_INTSRC_INTSRC5_Msk            (0x1ul << GP_INTSRC_INTSRC5_Pos)                  /*!< GP_T::INTSRC: INTSRC5 Mask                */
N
N#define GP_INTSRC_INTSRC6_Pos            (6)                                               /*!< GP_T::INTSRC: INTSRC6 Position            */
N#define GP_INTSRC_INTSRC6_Msk            (0x1ul << GP_INTSRC_INTSRC6_Pos)                  /*!< GP_T::INTSRC: INTSRC6 Mask                */
N
N#define GP_INTSRC_INTSRC7_Pos            (7)                                               /*!< GP_T::INTSRC: INTSRC7 Position            */
N#define GP_INTSRC_INTSRC7_Msk            (0x1ul << GP_INTSRC_INTSRC7_Pos)                  /*!< GP_T::INTSRC: INTSRC7 Mask                */
N
N#define GP_INTSRC_INTSRC8_Pos            (8)                                               /*!< GP_T::INTSRC: INTSRC8 Position            */
N#define GP_INTSRC_INTSRC8_Msk            (0x1ul << GP_INTSRC_INTSRC8_Pos)                  /*!< GP_T::INTSRC: INTSRC8 Mask                */
N
N#define GP_INTSRC_INTSRC9_Pos            (9)                                               /*!< GP_T::INTSRC: INTSRC9 Position            */
N#define GP_INTSRC_INTSRC9_Msk            (0x1ul << GP_INTSRC_INTSRC9_Pos)                  /*!< GP_T::INTSRC: INTSRC9 Mask                */
N
N#define GP_INTSRC_INTSRC10_Pos           (10)                                              /*!< GP_T::INTSRC: INTSRC10 Position           */
N#define GP_INTSRC_INTSRC10_Msk           (0x1ul << GP_INTSRC_INTSRC10_Pos)                 /*!< GP_T::INTSRC: INTSRC10 Mask               */
N
N#define GP_INTSRC_INTSRC11_Pos           (11)                                              /*!< GP_T::INTSRC: INTSRC11 Position           */
N#define GP_INTSRC_INTSRC11_Msk           (0x1ul << GP_INTSRC_INTSRC11_Pos)                 /*!< GP_T::INTSRC: INTSRC11 Mask               */
N
N#define GP_INTSRC_INTSRC12_Pos           (12)                                              /*!< GP_T::INTSRC: INTSRC12 Position           */
N#define GP_INTSRC_INTSRC12_Msk           (0x1ul << GP_INTSRC_INTSRC12_Pos)                 /*!< GP_T::INTSRC: INTSRC12 Mask               */
N
N#define GP_INTSRC_INTSRC13_Pos           (13)                                              /*!< GP_T::INTSRC: INTSRC13 Position           */
N#define GP_INTSRC_INTSRC13_Msk           (0x1ul << GP_INTSRC_INTSRC13_Pos)                 /*!< GP_T::INTSRC: INTSRC13 Mask               */
N
N#define GP_INTSRC_INTSRC14_Pos           (14)                                              /*!< GP_T::INTSRC: INTSRC14 Position           */
N#define GP_INTSRC_INTSRC14_Msk           (0x1ul << GP_INTSRC_INTSRC14_Pos)                 /*!< GP_T::INTSRC: INTSRC14 Mask               */
N
N#define GP_INTSRC_INTSRC15_Pos           (15)                                              /*!< GP_T::INTSRC: INTSRC15 Position           */
N#define GP_INTSRC_INTSRC15_Msk           (0x1ul << GP_INTSRC_INTSRC15_Pos)                 /*!< GP_T::INTSRC: INTSRC15 Mask               */
N
N#define GP_MODE_MODE0_Pos                (0)                                               /*!< GP_T::MODE: MODE0 Position                */
N#define GP_MODE_MODE0_Msk                (0x3ul << GP_MODE_MODE0_Pos)                      /*!< GP_T::MODE: MODE0 Mask                    */
N
N#define GP_MODE_MODE1_Pos                (2)                                               /*!< GP_T::MODE: MODE1 Position                */
N#define GP_MODE_MODE1_Msk                (0x3ul << GP_MODE_MODE1_Pos)                      /*!< GP_T::MODE: MODE1 Mask                    */
N
N#define GP_MODE_MODE2_Pos                (4)                                               /*!< GP_T::MODE: MODE2 Position                */
N#define GP_MODE_MODE2_Msk                (0x3ul << GP_MODE_MODE2_Pos)                      /*!< GP_T::MODE: MODE2 Mask                    */
N
N#define GP_MODE_MODE3_Pos                (6)                                               /*!< GP_T::MODE: MODE3 Position                */
N#define GP_MODE_MODE3_Msk                (0x3ul << GP_MODE_MODE3_Pos)                      /*!< GP_T::MODE: MODE3 Mask                    */
N
N#define GP_MODE_MODE4_Pos                (8)                                               /*!< GP_T::MODE: MODE4 Position                */
N#define GP_MODE_MODE4_Msk                (0x3ul << GP_MODE_MODE4_Pos)                      /*!< GP_T::MODE: MODE4 Mask                    */
N
N#define GP_MODE_MODE5_Pos                (10)                                              /*!< GP_T::MODE: MODE5 Position                */
N#define GP_MODE_MODE5_Msk                (0x3ul << GP_MODE_MODE5_Pos)                      /*!< GP_T::MODE: MODE5 Mask                    */
N
N#define GP_DINOFF_DINOFF0_Pos            (16)                                              /*!< GP_T::DINOFF: DINOFF0 Position            */
N#define GP_DINOFF_DINOFF0_Msk            (0x1ul << GP_DINOFF_DINOFF0_Pos)                  /*!< GP_T::DINOFF: DINOFF0 Mask                */
N
N#define GP_DINOFF_DINOFF1_Pos            (17)                                              /*!< GP_T::DINOFF: DINOFF1 Position            */
N#define GP_DINOFF_DINOFF1_Msk            (0x1ul << GP_DINOFF_DINOFF1_Pos)                  /*!< GP_T::DINOFF: DINOFF1 Mask                */
N
N#define GP_DINOFF_DINOFF2_Pos            (18)                                              /*!< GP_T::DINOFF: DINOFF2 Position            */
N#define GP_DINOFF_DINOFF2_Msk            (0x1ul << GP_DINOFF_DINOFF2_Pos)                  /*!< GP_T::DINOFF: DINOFF2 Mask                */
N
N#define GP_DINOFF_DINOFF3_Pos            (19)                                              /*!< GP_T::DINOFF: DINOFF3 Position            */
N#define GP_DINOFF_DINOFF3_Msk            (0x1ul << GP_DINOFF_DINOFF3_Pos)                  /*!< GP_T::DINOFF: DINOFF3 Mask                */
N
N#define GP_DINOFF_DINOFF4_Pos            (20)                                              /*!< GP_T::DINOFF: DINOFF4 Position            */
N#define GP_DINOFF_DINOFF4_Msk            (0x1ul << GP_DINOFF_DINOFF4_Pos)                  /*!< GP_T::DINOFF: DINOFF4 Mask                */
N
N#define GP_DINOFF_DINOFF5_Pos            (21)                                              /*!< GP_T::DINOFF: DINOFF5 Position            */
N#define GP_DINOFF_DINOFF5_Msk            (0x1ul << GP_DINOFF_DINOFF5_Pos)                  /*!< GP_T::DINOFF: DINOFF5 Mask                */
N
N#define GP_DINOFF_DINOFF6_Pos            (22)                                              /*!< GP_T::DINOFF: DINOFF6 Position            */
N#define GP_DINOFF_DINOFF6_Msk            (0x1ul << GP_DINOFF_DINOFF6_Pos)                  /*!< GP_T::DINOFF: DINOFF6 Mask                */
N
N#define GP_DINOFF_DINOFF7_Pos            (23)                                              /*!< GP_T::DINOFF: DINOFF7 Position            */
N#define GP_DINOFF_DINOFF7_Msk            (0x1ul << GP_DINOFF_DINOFF7_Pos)                  /*!< GP_T::DINOFF: DINOFF7 Mask                */
N
N#define GP_DOUT_DOUT0_Pos                (0)                                               /*!< GP_T::DOUT: DOUT0 Position                */
N#define GP_DOUT_DOUT0_Msk                (0x1ul << GP_DOUT_DOUT0_Pos)                      /*!< GP_T::DOUT: DOUT0 Mask                    */
N
N#define GP_DOUT_DOUT1_Pos                (1)                                               /*!< GP_T::DOUT: DOUT1 Position                */
N#define GP_DOUT_DOUT1_Msk                (0x1ul << GP_DOUT_DOUT1_Pos)                      /*!< GP_T::DOUT: DOUT1 Mask                    */
N
N#define GP_DOUT_DOUT2_Pos                (2)                                               /*!< GP_T::DOUT: DOUT2 Position                */
N#define GP_DOUT_DOUT2_Msk                (0x1ul << GP_DOUT_DOUT2_Pos)                      /*!< GP_T::DOUT: DOUT2 Mask                    */
N
N#define GP_DOUT_DOUT3_Pos                (3)                                               /*!< GP_T::DOUT: DOUT3 Position                */
N#define GP_DOUT_DOUT3_Msk                (0x1ul << GP_DOUT_DOUT3_Pos)                      /*!< GP_T::DOUT: DOUT3 Mask                    */
N
N#define GP_DOUT_DOUT4_Pos                (4)                                               /*!< GP_T::DOUT: DOUT4 Position                */
N#define GP_DOUT_DOUT4_Msk                (0x1ul << GP_DOUT_DOUT4_Pos)                      /*!< GP_T::DOUT: DOUT4 Mask                    */
N
N#define GP_DOUT_DOUT5_Pos                (5)                                               /*!< GP_T::DOUT: DOUT5 Position                */
N#define GP_DOUT_DOUT5_Msk                (0x1ul << GP_DOUT_DOUT5_Pos)                      /*!< GP_T::DOUT: DOUT5 Mask                    */
N
N#define GP_DOUT_DOUT6_Pos                (6)                                               /*!< GP_T::DOUT: DOUT6 Position                */
N#define GP_DOUT_DOUT6_Msk                (0x1ul << GP_DOUT_DOUT6_Pos)                      /*!< GP_T::DOUT: DOUT6 Mask                    */
N
N#define GP_DOUT_DOUT7_Pos                (7)                                               /*!< GP_T::DOUT: DOUT7 Position                */
N#define GP_DOUT_DOUT7_Msk                (0x1ul << GP_DOUT_DOUT7_Pos)                      /*!< GP_T::DOUT: DOUT7 Mask                    */
N
N#define GP_DATMSK_DATMSK0_Pos            (0)                                               /*!< GP_T::DATMSK: DATMSK0 Position            */
N#define GP_DATMSK_DATMSK0_Msk            (0x1ul << GP_DATMSK_DATMSK0_Pos)                  /*!< GP_T::DATMSK: DATMSK0 Mask                */
N
N#define GP_DATMSK_DATMSK1_Pos            (1)                                               /*!< GP_T::DATMSK: DATMSK1 Position            */
N#define GP_DATMSK_DATMSK1_Msk            (0x1ul << GP_DATMSK_DATMSK1_Pos)                  /*!< GP_T::DATMSK: DATMSK1 Mask                */
N
N#define GP_DATMSK_DATMSK2_Pos            (2)                                               /*!< GP_T::DATMSK: DATMSK2 Position            */
N#define GP_DATMSK_DATMSK2_Msk            (0x1ul << GP_DATMSK_DATMSK2_Pos)                  /*!< GP_T::DATMSK: DATMSK2 Mask                */
N
N#define GP_DATMSK_DATMSK3_Pos            (3)                                               /*!< GP_T::DATMSK: DATMSK3 Position            */
N#define GP_DATMSK_DATMSK3_Msk            (0x1ul << GP_DATMSK_DATMSK3_Pos)                  /*!< GP_T::DATMSK: DATMSK3 Mask                */
N
N#define GP_DATMSK_DATMSK4_Pos            (4)                                               /*!< GP_T::DATMSK: DATMSK4 Position            */
N#define GP_DATMSK_DATMSK4_Msk            (0x1ul << GP_DATMSK_DATMSK4_Pos)                  /*!< GP_T::DATMSK: DATMSK4 Mask                */
N
N#define GP_DATMSK_DATMSK5_Pos            (5)                                               /*!< GP_T::DATMSK: DATMSK5 Position            */
N#define GP_DATMSK_DATMSK5_Msk            (0x1ul << GP_DATMSK_DATMSK5_Pos)                  /*!< GP_T::DATMSK: DATMSK5 Mask                */
N
N#define GP_DATMSK_DATMSK6_Pos            (6)                                               /*!< GP_T::DATMSK: DATMSK6 Position            */
N#define GP_DATMSK_DATMSK6_Msk            (0x1ul << GP_DATMSK_DATMSK6_Pos)                  /*!< GP_T::DATMSK: DATMSK6 Mask                */
N
N#define GP_DATMSK_DATMSK7_Pos            (7)                                               /*!< GP_T::DATMSK: DATMSK7 Position            */
N#define GP_DATMSK_DATMSK7_Msk            (0x1ul << GP_DATMSK_DATMSK7_Pos)                  /*!< GP_T::DATMSK: DATMSK7 Mask                */
N
N#define GP_PIN_PIN0_Pos                  (0)                                               /*!< GP_T::PIN: PIN0 Position                  */
N#define GP_PIN_PIN0_Msk                  (0x1ul << GP_PIN_PIN0_Pos)                        /*!< GP_T::PIN: PIN0 Mask                      */
N
N#define GP_PIN_PIN1_Pos                  (1)                                               /*!< GP_T::PIN: PIN1 Position                  */
N#define GP_PIN_PIN1_Msk                  (0x1ul << GP_PIN_PIN1_Pos)                        /*!< GP_T::PIN: PIN1 Mask                      */
N
N#define GP_PIN_PIN2_Pos                  (2)                                               /*!< GP_T::PIN: PIN2 Position                  */
N#define GP_PIN_PIN2_Msk                  (0x1ul << GP_PIN_PIN2_Pos)                        /*!< GP_T::PIN: PIN2 Mask                      */
N
N#define GP_PIN_PIN3_Pos                  (3)                                               /*!< GP_T::PIN: PIN3 Position                  */
N#define GP_PIN_PIN3_Msk                  (0x1ul << GP_PIN_PIN3_Pos)                        /*!< GP_T::PIN: PIN3 Mask                      */
N
N#define GP_PIN_PIN4_Pos                  (4)                                               /*!< GP_T::PIN: PIN4 Position                  */
N#define GP_PIN_PIN4_Msk                  (0x1ul << GP_PIN_PIN4_Pos)                        /*!< GP_T::PIN: PIN4 Mask                      */
N
N#define GP_PIN_PIN5_Pos                  (5)                                               /*!< GP_T::PIN: PIN5 Position                  */
N#define GP_PIN_PIN5_Msk                  (0x1ul << GP_PIN_PIN5_Pos)                        /*!< GP_T::PIN: PIN5 Mask                      */
N
N#define GP_PIN_PIN6_Pos                  (6)                                               /*!< GP_T::PIN: PIN6 Position                  */
N#define GP_PIN_PIN6_Msk                  (0x1ul << GP_PIN_PIN6_Pos)                        /*!< GP_T::PIN: PIN6 Mask                      */
N
N#define GP_PIN_PIN7_Pos                  (7)                                               /*!< GP_T::PIN: PIN7 Position                  */
N#define GP_PIN_PIN7_Msk                  (0x1ul << GP_PIN_PIN7_Pos)                        /*!< GP_T::PIN: PIN7 Mask                      */
N
N#define GP_DBEN_DBEN0_Pos                (0)                                               /*!< GP_T::DBEN: DBEN0 Position                */
N#define GP_DBEN_DBEN0_Msk                (0x1ul << GP_DBEN_DBEN0_Pos)                      /*!< GP_T::DBEN: DBEN0 Mask                    */
N
N#define GP_DBEN_DBEN1_Pos                (1)                                               /*!< GP_T::DBEN: DBEN1 Position                */
N#define GP_DBEN_DBEN1_Msk                (0x1ul << GP_DBEN_DBEN1_Pos)                      /*!< GP_T::DBEN: DBEN1 Mask                    */
N
N#define GP_DBEN_DBEN2_Pos                (2)                                               /*!< GP_T::DBEN: DBEN2 Position                */
N#define GP_DBEN_DBEN2_Msk                (0x1ul << GP_DBEN_DBEN2_Pos)                      /*!< GP_T::DBEN: DBEN2 Mask                    */
N
N#define GP_DBEN_DBEN3_Pos                (3)                                               /*!< GP_T::DBEN: DBEN3 Position                */
N#define GP_DBEN_DBEN3_Msk                (0x1ul << GP_DBEN_DBEN3_Pos)                      /*!< GP_T::DBEN: DBEN3 Mask                    */
N
N#define GP_DBEN_DBEN4_Pos                (4)                                               /*!< GP_T::DBEN: DBEN4 Position                */
N#define GP_DBEN_DBEN4_Msk                (0x1ul << GP_DBEN_DBEN4_Pos)                      /*!< GP_T::DBEN: DBEN4 Mask                    */
N
N#define GP_DBEN_DBEN5_Pos                (5)                                               /*!< GP_T::DBEN: DBEN5 Position                */
N#define GP_DBEN_DBEN5_Msk                (0x1ul << GP_DBEN_DBEN5_Pos)                      /*!< GP_T::DBEN: DBEN5 Mask                    */
N
N#define GP_DBEN_DBEN6_Pos                (6)                                               /*!< GP_T::DBEN: DBEN6 Position                */
N#define GP_DBEN_DBEN6_Msk                (0x1ul << GP_DBEN_DBEN6_Pos)                      /*!< GP_T::DBEN: DBEN6 Mask                    */
N
N#define GP_DBEN_DBEN7_Pos                (7)                                               /*!< GP_T::DBEN: DBEN7 Position                */
N#define GP_DBEN_DBEN7_Msk                (0x1ul << GP_DBEN_DBEN7_Pos)                      /*!< GP_T::DBEN: DBEN7 Mask                    */
N
N#define GP_INTTYPE_TYPE0_Pos             (0)                                               /*!< GP_T::INTTYPE: TYPE0 Position             */
N#define GP_INTTYPE_TYPE0_Msk             (0x1ul << GP_INTTYPE_TYPE0_Pos)                   /*!< GP_T::INTTYPE: TYPE0 Mask                 */
N
N#define GP_INTTYPE_TYPE1_Pos             (1)                                               /*!< GP_T::INTTYPE: TYPE1 Position             */
N#define GP_INTTYPE_TYPE1_Msk             (0x1ul << GP_INTTYPE_TYPE1_Pos)                   /*!< GP_T::INTTYPE: TYPE1 Mask                 */
N
N#define GP_INTTYPE_TYPE2_Pos             (2)                                               /*!< GP_T::INTTYPE: TYPE2 Position             */
N#define GP_INTTYPE_TYPE2_Msk             (0x1ul << GP_INTTYPE_TYPE2_Pos)                   /*!< GP_T::INTTYPE: TYPE2 Mask                 */
N
N#define GP_INTTYPE_TYPE3_Pos             (3)                                               /*!< GP_T::INTTYPE: TYPE3 Position             */
N#define GP_INTTYPE_TYPE3_Msk             (0x1ul << GP_INTTYPE_TYPE3_Pos)                   /*!< GP_T::INTTYPE: TYPE3 Mask                 */
N
N#define GP_INTTYPE_TYPE4_Pos             (4)                                               /*!< GP_T::INTTYPE: TYPE4 Position             */
N#define GP_INTTYPE_TYPE4_Msk             (0x1ul << GP_INTTYPE_TYPE4_Pos)                   /*!< GP_T::INTTYPE: TYPE4 Mask                 */
N
N#define GP_INTTYPE_TYPE5_Pos             (5)                                               /*!< GP_T::INTTYPE: TYPE5 Position             */
N#define GP_INTTYPE_TYPE5_Msk             (0x1ul << GP_INTTYPE_TYPE5_Pos)                   /*!< GP_T::INTTYPE: TYPE5 Mask                 */
N
N#define GP_INTTYPE_TYPE6_Pos             (6)                                               /*!< GP_T::INTTYPE: TYPE6 Position             */
N#define GP_INTTYPE_TYPE6_Msk             (0x1ul << GP_INTTYPE_TYPE6_Pos)                   /*!< GP_T::INTTYPE: TYPE6 Mask                 */
N
N#define GP_INTTYPE_TYPE7_Pos             (7)                                               /*!< GP_T::INTTYPE: TYPE7 Position             */
N#define GP_INTTYPE_TYPE7_Msk             (0x1ul << GP_INTTYPE_TYPE7_Pos)                   /*!< GP_T::INTTYPE: TYPE7 Mask                 */
N
N#define GP_INTEN_FLIEN0_Pos              (0)                                               /*!< GP_T::INTEN: FLIEN0 Position              */
N#define GP_INTEN_FLIEN0_Msk              (0x1ul << GP_INTEN_FLIEN0_Pos)                    /*!< GP_T::INTEN: FLIEN0 Mask                  */
N
N#define GP_INTEN_FLIEN1_Pos              (1)                                               /*!< GP_T::INTEN: FLIEN1 Position              */
N#define GP_INTEN_FLIEN1_Msk              (0x1ul << GP_INTEN_FLIEN1_Pos)                    /*!< GP_T::INTEN: FLIEN1 Mask                  */
N
N#define GP_INTEN_FLIEN2_Pos              (2)                                               /*!< GP_T::INTEN: FLIEN2 Position              */
N#define GP_INTEN_FLIEN2_Msk              (0x1ul << GP_INTEN_FLIEN2_Pos)                    /*!< GP_T::INTEN: FLIEN2 Mask                  */
N
N#define GP_INTEN_FLIEN3_Pos              (3)                                               /*!< GP_T::INTEN: FLIEN3 Position              */
N#define GP_INTEN_FLIEN3_Msk              (0x1ul << GP_INTEN_FLIEN3_Pos)                    /*!< GP_T::INTEN: FLIEN3 Mask                  */
N
N#define GP_INTEN_FLIEN4_Pos              (4)                                               /*!< GP_T::INTEN: FLIEN4 Position              */
N#define GP_INTEN_FLIEN4_Msk              (0x1ul << GP_INTEN_FLIEN4_Pos)                    /*!< GP_T::INTEN: FLIEN4 Mask                  */
N
N#define GP_INTEN_FLIEN5_Pos              (5)                                               /*!< GP_T::INTEN: FLIEN5 Position              */
N#define GP_INTEN_FLIEN5_Msk              (0x1ul << GP_INTEN_FLIEN5_Pos)                    /*!< GP_T::INTEN: FLIEN5 Mask                  */
N
N#define GP_INTEN_FLIEN6_Pos              (6)                                               /*!< GP_T::INTEN: FLIEN6 Position              */
N#define GP_INTEN_FLIEN6_Msk              (0x1ul << GP_INTEN_FLIEN6_Pos)                    /*!< GP_T::INTEN: FLIEN6 Mask                  */
N
N#define GP_INTEN_FLIEN7_Pos              (7)                                               /*!< GP_T::INTEN: FLIEN7 Position              */
N#define GP_INTEN_FLIEN7_Msk              (0x1ul << GP_INTEN_FLIEN7_Pos)                    /*!< GP_T::INTEN: FLIEN7 Mask                  */
N
N#define GP_INTEN_RHIEN0_Pos              (16)                                              /*!< GP_T::INTEN: RHIEN0 Position              */
N#define GP_INTEN_RHIEN0_Msk              (0x1ul << GP_INTEN_RHIEN0_Pos)                    /*!< GP_T::INTEN: RHIEN0 Mask                  */
N
N#define GP_INTEN_RHIEN1_Pos              (17)                                              /*!< GP_T::INTEN: RHIEN1 Position              */
N#define GP_INTEN_RHIEN1_Msk              (0x1ul << GP_INTEN_RHIEN1_Pos)                    /*!< GP_T::INTEN: RHIEN1 Mask                  */
N
N#define GP_INTEN_RHIEN2_Pos              (18)                                              /*!< GP_T::INTEN: RHIEN2 Position              */
N#define GP_INTEN_RHIEN2_Msk              (0x1ul << GP_INTEN_RHIEN2_Pos)                    /*!< GP_T::INTEN: RHIEN2 Mask                  */
N
N#define GP_INTEN_RHIEN3_Pos              (19)                                              /*!< GP_T::INTEN: RHIEN3 Position              */
N#define GP_INTEN_RHIEN3_Msk              (0x1ul << GP_INTEN_RHIEN3_Pos)                    /*!< GP_T::INTEN: RHIEN3 Mask                  */
N
N#define GP_INTEN_RHIEN4_Pos              (20)                                              /*!< GP_T::INTEN: RHIEN4 Position              */
N#define GP_INTEN_RHIEN4_Msk              (0x1ul << GP_INTEN_RHIEN4_Pos)                    /*!< GP_T::INTEN: RHIEN4 Mask                  */
N
N#define GP_INTEN_RHIEN5_Pos              (21)                                              /*!< GP_T::INTEN: RHIEN5 Position              */
N#define GP_INTEN_RHIEN5_Msk              (0x1ul << GP_INTEN_RHIEN5_Pos)                    /*!< GP_T::INTEN: RHIEN5 Mask                  */
N
N#define GP_INTEN_RHIEN6_Pos              (22)                                              /*!< GP_T::INTEN: RHIEN6 Position              */
N#define GP_INTEN_RHIEN6_Msk              (0x1ul << GP_INTEN_RHIEN6_Pos)                    /*!< GP_T::INTEN: RHIEN6 Mask                  */
N
N#define GP_INTEN_RHIEN7_Pos              (23)                                              /*!< GP_T::INTEN: RHIEN7 Position              */
N#define GP_INTEN_RHIEN7_Msk              (0x1ul << GP_INTEN_RHIEN7_Pos)                    /*!< GP_T::INTEN: RHIEN7 Mask                  */
N
N#define GP_INTSRC_INTSRC0_Pos            (0)                                               /*!< GP_T::INTSRC: INTSRC0 Position            */
N#define GP_INTSRC_INTSRC0_Msk            (0x1ul << GP_INTSRC_INTSRC0_Pos)                  /*!< GP_T::INTSRC: INTSRC0 Mask                */
N
N#define GP_INTSRC_INTSRC1_Pos            (1)                                               /*!< GP_T::INTSRC: INTSRC1 Position            */
N#define GP_INTSRC_INTSRC1_Msk            (0x1ul << GP_INTSRC_INTSRC1_Pos)                  /*!< GP_T::INTSRC: INTSRC1 Mask                */
N
N#define GP_INTSRC_INTSRC2_Pos            (2)                                               /*!< GP_T::INTSRC: INTSRC2 Position            */
N#define GP_INTSRC_INTSRC2_Msk            (0x1ul << GP_INTSRC_INTSRC2_Pos)                  /*!< GP_T::INTSRC: INTSRC2 Mask                */
N
N#define GP_INTSRC_INTSRC3_Pos            (3)                                               /*!< GP_T::INTSRC: INTSRC3 Position            */
N#define GP_INTSRC_INTSRC3_Msk            (0x1ul << GP_INTSRC_INTSRC3_Pos)                  /*!< GP_T::INTSRC: INTSRC3 Mask                */
N
N#define GP_INTSRC_INTSRC4_Pos            (4)                                               /*!< GP_T::INTSRC: INTSRC4 Position            */
N#define GP_INTSRC_INTSRC4_Msk            (0x1ul << GP_INTSRC_INTSRC4_Pos)                  /*!< GP_T::INTSRC: INTSRC4 Mask                */
N
N#define GP_INTSRC_INTSRC5_Pos            (5)                                               /*!< GP_T::INTSRC: INTSRC5 Position            */
N#define GP_INTSRC_INTSRC5_Msk            (0x1ul << GP_INTSRC_INTSRC5_Pos)                  /*!< GP_T::INTSRC: INTSRC5 Mask                */
N
N#define GP_INTSRC_INTSRC6_Pos            (6)                                               /*!< GP_T::INTSRC: INTSRC6 Position            */
N#define GP_INTSRC_INTSRC6_Msk            (0x1ul << GP_INTSRC_INTSRC6_Pos)                  /*!< GP_T::INTSRC: INTSRC6 Mask                */
N
N#define GP_INTSRC_INTSRC7_Pos            (7)                                               /*!< GP_T::INTSRC: INTSRC7 Position            */
N#define GP_INTSRC_INTSRC7_Msk            (0x1ul << GP_INTSRC_INTSRC7_Pos)                  /*!< GP_T::INTSRC: INTSRC7 Mask                */
N
N#define GP_INTSRC_INTSRC8_Pos            (8)                                               /*!< GP_T::INTSRC: INTSRC8 Position            */
N#define GP_INTSRC_INTSRC8_Msk            (0x1ul << GP_INTSRC_INTSRC8_Pos)                  /*!< GP_T::INTSRC: INTSRC8 Mask                */
N
N#define GP_INTSRC_INTSRC9_Pos            (9)                                               /*!< GP_T::INTSRC: INTSRC9 Position            */
N#define GP_INTSRC_INTSRC9_Msk            (0x1ul << GP_INTSRC_INTSRC9_Pos)                  /*!< GP_T::INTSRC: INTSRC9 Mask                */
N
N#define GP_INTSRC_INTSRC10_Pos           (10)                                              /*!< GP_T::INTSRC: INTSRC10 Position           */
N#define GP_INTSRC_INTSRC10_Msk           (0x1ul << GP_INTSRC_INTSRC10_Pos)                 /*!< GP_T::INTSRC: INTSRC10 Mask               */
N
N#define GP_INTSRC_INTSRC11_Pos           (11)                                              /*!< GP_T::INTSRC: INTSRC11 Position           */
N#define GP_INTSRC_INTSRC11_Msk           (0x1ul << GP_INTSRC_INTSRC11_Pos)                 /*!< GP_T::INTSRC: INTSRC11 Mask               */
N
N#define GP_INTSRC_INTSRC12_Pos           (12)                                              /*!< GP_T::INTSRC: INTSRC12 Position           */
N#define GP_INTSRC_INTSRC12_Msk           (0x1ul << GP_INTSRC_INTSRC12_Pos)                 /*!< GP_T::INTSRC: INTSRC12 Mask               */
N
N#define GP_INTSRC_INTSRC13_Pos           (13)                                              /*!< GP_T::INTSRC: INTSRC13 Position           */
N#define GP_INTSRC_INTSRC13_Msk           (0x1ul << GP_INTSRC_INTSRC13_Pos)                 /*!< GP_T::INTSRC: INTSRC13 Mask               */
N
N#define GP_INTSRC_INTSRC14_Pos           (14)                                              /*!< GP_T::INTSRC: INTSRC14 Position           */
N#define GP_INTSRC_INTSRC14_Msk           (0x1ul << GP_INTSRC_INTSRC14_Pos)                 /*!< GP_T::INTSRC: INTSRC14 Mask               */
N
N#define GP_INTSRC_INTSRC15_Pos           (15)                                              /*!< GP_T::INTSRC: INTSRC15 Position           */
N#define GP_INTSRC_INTSRC15_Msk           (0x1ul << GP_INTSRC_INTSRC15_Pos)                 /*!< GP_T::INTSRC: INTSRC15 Mask               */
N
N#define GP_MODE_MODE0_Pos                (0)                                               /*!< GP_T::MODE: MODE0 Position                */
N#define GP_MODE_MODE0_Msk                (0x3ul << GP_MODE_MODE0_Pos)                      /*!< GP_T::MODE: MODE0 Mask                    */
N
N#define GP_MODE_MODE1_Pos                (2)                                               /*!< GP_T::MODE: MODE1 Position                */
N#define GP_MODE_MODE1_Msk                (0x3ul << GP_MODE_MODE1_Pos)                      /*!< GP_T::MODE: MODE1 Mask                    */
N
N#define GP_MODE_MODE2_Pos                (4)                                               /*!< GP_T::MODE: MODE2 Position                */
N#define GP_MODE_MODE2_Msk                (0x3ul << GP_MODE_MODE2_Pos)                      /*!< GP_T::MODE: MODE2 Mask                    */
N
N#define GP_MODE_MODE3_Pos                (6)                                               /*!< GP_T::MODE: MODE3 Position                */
N#define GP_MODE_MODE3_Msk                (0x3ul << GP_MODE_MODE3_Pos)                      /*!< GP_T::MODE: MODE3 Mask                    */
N
N#define GP_MODE_MODE4_Pos                (8)                                               /*!< GP_T::MODE: MODE4 Position                */
N#define GP_MODE_MODE4_Msk                (0x3ul << GP_MODE_MODE4_Pos)                      /*!< GP_T::MODE: MODE4 Mask                    */
N
N#define GP_MODE_MODE5_Pos                (10)                                              /*!< GP_T::MODE: MODE5 Position                */
N#define GP_MODE_MODE5_Msk                (0x3ul << GP_MODE_MODE5_Pos)                      /*!< GP_T::MODE: MODE5 Mask                    */
N
N#define GP_DINOFF_DINOFF0_Pos            (16)                                              /*!< GP_T::DINOFF: DINOFF0 Position            */
N#define GP_DINOFF_DINOFF0_Msk            (0x1ul << GP_DINOFF_DINOFF0_Pos)                  /*!< GP_T::DINOFF: DINOFF0 Mask                */
N
N#define GP_DINOFF_DINOFF1_Pos            (17)                                              /*!< GP_T::DINOFF: DINOFF1 Position            */
N#define GP_DINOFF_DINOFF1_Msk            (0x1ul << GP_DINOFF_DINOFF1_Pos)                  /*!< GP_T::DINOFF: DINOFF1 Mask                */
N
N#define GP_DINOFF_DINOFF2_Pos            (18)                                              /*!< GP_T::DINOFF: DINOFF2 Position            */
N#define GP_DINOFF_DINOFF2_Msk            (0x1ul << GP_DINOFF_DINOFF2_Pos)                  /*!< GP_T::DINOFF: DINOFF2 Mask                */
N
N#define GP_DINOFF_DINOFF3_Pos            (19)                                              /*!< GP_T::DINOFF: DINOFF3 Position            */
N#define GP_DINOFF_DINOFF3_Msk            (0x1ul << GP_DINOFF_DINOFF3_Pos)                  /*!< GP_T::DINOFF: DINOFF3 Mask                */
N
N#define GP_DINOFF_DINOFF4_Pos            (20)                                              /*!< GP_T::DINOFF: DINOFF4 Position            */
N#define GP_DINOFF_DINOFF4_Msk            (0x1ul << GP_DINOFF_DINOFF4_Pos)                  /*!< GP_T::DINOFF: DINOFF4 Mask                */
N
N#define GP_DINOFF_DINOFF5_Pos            (21)                                              /*!< GP_T::DINOFF: DINOFF5 Position            */
N#define GP_DINOFF_DINOFF5_Msk            (0x1ul << GP_DINOFF_DINOFF5_Pos)                  /*!< GP_T::DINOFF: DINOFF5 Mask                */
N
N#define GP_DINOFF_DINOFF6_Pos            (22)                                              /*!< GP_T::DINOFF: DINOFF6 Position            */
N#define GP_DINOFF_DINOFF6_Msk            (0x1ul << GP_DINOFF_DINOFF6_Pos)                  /*!< GP_T::DINOFF: DINOFF6 Mask                */
N
N#define GP_DINOFF_DINOFF7_Pos            (23)                                              /*!< GP_T::DINOFF: DINOFF7 Position            */
N#define GP_DINOFF_DINOFF7_Msk            (0x1ul << GP_DINOFF_DINOFF7_Pos)                  /*!< GP_T::DINOFF: DINOFF7 Mask                */
N
N#define GP_DOUT_DOUT0_Pos                (0)                                               /*!< GP_T::DOUT: DOUT0 Position                */
N#define GP_DOUT_DOUT0_Msk                (0x1ul << GP_DOUT_DOUT0_Pos)                      /*!< GP_T::DOUT: DOUT0 Mask                    */
N
N#define GP_DOUT_DOUT1_Pos                (1)                                               /*!< GP_T::DOUT: DOUT1 Position                */
N#define GP_DOUT_DOUT1_Msk                (0x1ul << GP_DOUT_DOUT1_Pos)                      /*!< GP_T::DOUT: DOUT1 Mask                    */
N
N#define GP_DOUT_DOUT2_Pos                (2)                                               /*!< GP_T::DOUT: DOUT2 Position                */
N#define GP_DOUT_DOUT2_Msk                (0x1ul << GP_DOUT_DOUT2_Pos)                      /*!< GP_T::DOUT: DOUT2 Mask                    */
N
N#define GP_DOUT_DOUT3_Pos                (3)                                               /*!< GP_T::DOUT: DOUT3 Position                */
N#define GP_DOUT_DOUT3_Msk                (0x1ul << GP_DOUT_DOUT3_Pos)                      /*!< GP_T::DOUT: DOUT3 Mask                    */
N
N#define GP_DOUT_DOUT4_Pos                (4)                                               /*!< GP_T::DOUT: DOUT4 Position                */
N#define GP_DOUT_DOUT4_Msk                (0x1ul << GP_DOUT_DOUT4_Pos)                      /*!< GP_T::DOUT: DOUT4 Mask                    */
N
N#define GP_DOUT_DOUT5_Pos                (5)                                               /*!< GP_T::DOUT: DOUT5 Position                */
N#define GP_DOUT_DOUT5_Msk                (0x1ul << GP_DOUT_DOUT5_Pos)                      /*!< GP_T::DOUT: DOUT5 Mask                    */
N
N#define GP_DOUT_DOUT6_Pos                (6)                                               /*!< GP_T::DOUT: DOUT6 Position                */
N#define GP_DOUT_DOUT6_Msk                (0x1ul << GP_DOUT_DOUT6_Pos)                      /*!< GP_T::DOUT: DOUT6 Mask                    */
N
N#define GP_DOUT_DOUT7_Pos                (7)                                               /*!< GP_T::DOUT: DOUT7 Position                */
N#define GP_DOUT_DOUT7_Msk                (0x1ul << GP_DOUT_DOUT7_Pos)                      /*!< GP_T::DOUT: DOUT7 Mask                    */
N
N#define GP_DATMSK_DATMSK0_Pos            (0)                                               /*!< GP_T::DATMSK: DATMSK0 Position            */
N#define GP_DATMSK_DATMSK0_Msk            (0x1ul << GP_DATMSK_DATMSK0_Pos)                  /*!< GP_T::DATMSK: DATMSK0 Mask                */
N
N#define GP_DATMSK_DATMSK1_Pos            (1)                                               /*!< GP_T::DATMSK: DATMSK1 Position            */
N#define GP_DATMSK_DATMSK1_Msk            (0x1ul << GP_DATMSK_DATMSK1_Pos)                  /*!< GP_T::DATMSK: DATMSK1 Mask                */
N
N#define GP_DATMSK_DATMSK2_Pos            (2)                                               /*!< GP_T::DATMSK: DATMSK2 Position            */
N#define GP_DATMSK_DATMSK2_Msk            (0x1ul << GP_DATMSK_DATMSK2_Pos)                  /*!< GP_T::DATMSK: DATMSK2 Mask                */
N
N#define GP_DATMSK_DATMSK3_Pos            (3)                                               /*!< GP_T::DATMSK: DATMSK3 Position            */
N#define GP_DATMSK_DATMSK3_Msk            (0x1ul << GP_DATMSK_DATMSK3_Pos)                  /*!< GP_T::DATMSK: DATMSK3 Mask                */
N
N#define GP_DATMSK_DATMSK4_Pos            (4)                                               /*!< GP_T::DATMSK: DATMSK4 Position            */
N#define GP_DATMSK_DATMSK4_Msk            (0x1ul << GP_DATMSK_DATMSK4_Pos)                  /*!< GP_T::DATMSK: DATMSK4 Mask                */
N
N#define GP_DATMSK_DATMSK5_Pos            (5)                                               /*!< GP_T::DATMSK: DATMSK5 Position            */
N#define GP_DATMSK_DATMSK5_Msk            (0x1ul << GP_DATMSK_DATMSK5_Pos)                  /*!< GP_T::DATMSK: DATMSK5 Mask                */
N
N#define GP_DATMSK_DATMSK6_Pos            (6)                                               /*!< GP_T::DATMSK: DATMSK6 Position            */
N#define GP_DATMSK_DATMSK6_Msk            (0x1ul << GP_DATMSK_DATMSK6_Pos)                  /*!< GP_T::DATMSK: DATMSK6 Mask                */
N
N#define GP_DATMSK_DATMSK7_Pos            (7)                                               /*!< GP_T::DATMSK: DATMSK7 Position            */
N#define GP_DATMSK_DATMSK7_Msk            (0x1ul << GP_DATMSK_DATMSK7_Pos)                  /*!< GP_T::DATMSK: DATMSK7 Mask                */
N
N#define GP_PIN_PIN0_Pos                  (0)                                               /*!< GP_T::PIN: PIN0 Position                  */
N#define GP_PIN_PIN0_Msk                  (0x1ul << GP_PIN_PIN0_Pos)                        /*!< GP_T::PIN: PIN0 Mask                      */
N
N#define GP_PIN_PIN1_Pos                  (1)                                               /*!< GP_T::PIN: PIN1 Position                  */
N#define GP_PIN_PIN1_Msk                  (0x1ul << GP_PIN_PIN1_Pos)                        /*!< GP_T::PIN: PIN1 Mask                      */
N
N#define GP_PIN_PIN2_Pos                  (2)                                               /*!< GP_T::PIN: PIN2 Position                  */
N#define GP_PIN_PIN2_Msk                  (0x1ul << GP_PIN_PIN2_Pos)                        /*!< GP_T::PIN: PIN2 Mask                      */
N
N#define GP_PIN_PIN3_Pos                  (3)                                               /*!< GP_T::PIN: PIN3 Position                  */
N#define GP_PIN_PIN3_Msk                  (0x1ul << GP_PIN_PIN3_Pos)                        /*!< GP_T::PIN: PIN3 Mask                      */
N
N#define GP_PIN_PIN4_Pos                  (4)                                               /*!< GP_T::PIN: PIN4 Position                  */
N#define GP_PIN_PIN4_Msk                  (0x1ul << GP_PIN_PIN4_Pos)                        /*!< GP_T::PIN: PIN4 Mask                      */
N
N#define GP_PIN_PIN5_Pos                  (5)                                               /*!< GP_T::PIN: PIN5 Position                  */
N#define GP_PIN_PIN5_Msk                  (0x1ul << GP_PIN_PIN5_Pos)                        /*!< GP_T::PIN: PIN5 Mask                      */
N
N#define GP_PIN_PIN6_Pos                  (6)                                               /*!< GP_T::PIN: PIN6 Position                  */
N#define GP_PIN_PIN6_Msk                  (0x1ul << GP_PIN_PIN6_Pos)                        /*!< GP_T::PIN: PIN6 Mask                      */
N
N#define GP_PIN_PIN7_Pos                  (7)                                               /*!< GP_T::PIN: PIN7 Position                  */
N#define GP_PIN_PIN7_Msk                  (0x1ul << GP_PIN_PIN7_Pos)                        /*!< GP_T::PIN: PIN7 Mask                      */
N
N#define GP_DBEN_DBEN0_Pos                (0)                                               /*!< GP_T::DBEN: DBEN0 Position                */
N#define GP_DBEN_DBEN0_Msk                (0x1ul << GP_DBEN_DBEN0_Pos)                      /*!< GP_T::DBEN: DBEN0 Mask                    */
N
N#define GP_DBEN_DBEN1_Pos                (1)                                               /*!< GP_T::DBEN: DBEN1 Position                */
N#define GP_DBEN_DBEN1_Msk                (0x1ul << GP_DBEN_DBEN1_Pos)                      /*!< GP_T::DBEN: DBEN1 Mask                    */
N
N#define GP_DBEN_DBEN2_Pos                (2)                                               /*!< GP_T::DBEN: DBEN2 Position                */
N#define GP_DBEN_DBEN2_Msk                (0x1ul << GP_DBEN_DBEN2_Pos)                      /*!< GP_T::DBEN: DBEN2 Mask                    */
N
N#define GP_DBEN_DBEN3_Pos                (3)                                               /*!< GP_T::DBEN: DBEN3 Position                */
N#define GP_DBEN_DBEN3_Msk                (0x1ul << GP_DBEN_DBEN3_Pos)                      /*!< GP_T::DBEN: DBEN3 Mask                    */
N
N#define GP_DBEN_DBEN4_Pos                (4)                                               /*!< GP_T::DBEN: DBEN4 Position                */
N#define GP_DBEN_DBEN4_Msk                (0x1ul << GP_DBEN_DBEN4_Pos)                      /*!< GP_T::DBEN: DBEN4 Mask                    */
N
N#define GP_DBEN_DBEN5_Pos                (5)                                               /*!< GP_T::DBEN: DBEN5 Position                */
N#define GP_DBEN_DBEN5_Msk                (0x1ul << GP_DBEN_DBEN5_Pos)                      /*!< GP_T::DBEN: DBEN5 Mask                    */
N
N#define GP_DBEN_DBEN6_Pos                (6)                                               /*!< GP_T::DBEN: DBEN6 Position                */
N#define GP_DBEN_DBEN6_Msk                (0x1ul << GP_DBEN_DBEN6_Pos)                      /*!< GP_T::DBEN: DBEN6 Mask                    */
N
N#define GP_DBEN_DBEN7_Pos                (7)                                               /*!< GP_T::DBEN: DBEN7 Position                */
N#define GP_DBEN_DBEN7_Msk                (0x1ul << GP_DBEN_DBEN7_Pos)                      /*!< GP_T::DBEN: DBEN7 Mask                    */
N
N#define GP_INTTYPE_TYPE0_Pos             (0)                                               /*!< GP_T::INTTYPE: TYPE0 Position             */
N#define GP_INTTYPE_TYPE0_Msk             (0x1ul << GP_INTTYPE_TYPE0_Pos)                   /*!< GP_T::INTTYPE: TYPE0 Mask                 */
N
N#define GP_INTTYPE_TYPE1_Pos             (1)                                               /*!< GP_T::INTTYPE: TYPE1 Position             */
N#define GP_INTTYPE_TYPE1_Msk             (0x1ul << GP_INTTYPE_TYPE1_Pos)                   /*!< GP_T::INTTYPE: TYPE1 Mask                 */
N
N#define GP_INTTYPE_TYPE2_Pos             (2)                                               /*!< GP_T::INTTYPE: TYPE2 Position             */
N#define GP_INTTYPE_TYPE2_Msk             (0x1ul << GP_INTTYPE_TYPE2_Pos)                   /*!< GP_T::INTTYPE: TYPE2 Mask                 */
N
N#define GP_INTTYPE_TYPE3_Pos             (3)                                               /*!< GP_T::INTTYPE: TYPE3 Position             */
N#define GP_INTTYPE_TYPE3_Msk             (0x1ul << GP_INTTYPE_TYPE3_Pos)                   /*!< GP_T::INTTYPE: TYPE3 Mask                 */
N
N#define GP_INTTYPE_TYPE4_Pos             (4)                                               /*!< GP_T::INTTYPE: TYPE4 Position             */
N#define GP_INTTYPE_TYPE4_Msk             (0x1ul << GP_INTTYPE_TYPE4_Pos)                   /*!< GP_T::INTTYPE: TYPE4 Mask                 */
N
N#define GP_INTTYPE_TYPE5_Pos             (5)                                               /*!< GP_T::INTTYPE: TYPE5 Position             */
N#define GP_INTTYPE_TYPE5_Msk             (0x1ul << GP_INTTYPE_TYPE5_Pos)                   /*!< GP_T::INTTYPE: TYPE5 Mask                 */
N
N#define GP_INTTYPE_TYPE6_Pos             (6)                                               /*!< GP_T::INTTYPE: TYPE6 Position             */
N#define GP_INTTYPE_TYPE6_Msk             (0x1ul << GP_INTTYPE_TYPE6_Pos)                   /*!< GP_T::INTTYPE: TYPE6 Mask                 */
N
N#define GP_INTTYPE_TYPE7_Pos             (7)                                               /*!< GP_T::INTTYPE: TYPE7 Position             */
N#define GP_INTTYPE_TYPE7_Msk             (0x1ul << GP_INTTYPE_TYPE7_Pos)                   /*!< GP_T::INTTYPE: TYPE7 Mask                 */
N
N#define GP_INTEN_FLIEN0_Pos              (0)                                               /*!< GP_T::INTEN: FLIEN0 Position              */
N#define GP_INTEN_FLIEN0_Msk              (0x1ul << GP_INTEN_FLIEN0_Pos)                    /*!< GP_T::INTEN: FLIEN0 Mask                  */
N
N#define GP_INTEN_FLIEN1_Pos              (1)                                               /*!< GP_T::INTEN: FLIEN1 Position              */
N#define GP_INTEN_FLIEN1_Msk              (0x1ul << GP_INTEN_FLIEN1_Pos)                    /*!< GP_T::INTEN: FLIEN1 Mask                  */
N
N#define GP_INTEN_FLIEN2_Pos              (2)                                               /*!< GP_T::INTEN: FLIEN2 Position              */
N#define GP_INTEN_FLIEN2_Msk              (0x1ul << GP_INTEN_FLIEN2_Pos)                    /*!< GP_T::INTEN: FLIEN2 Mask                  */
N
N#define GP_INTEN_FLIEN3_Pos              (3)                                               /*!< GP_T::INTEN: FLIEN3 Position              */
N#define GP_INTEN_FLIEN3_Msk              (0x1ul << GP_INTEN_FLIEN3_Pos)                    /*!< GP_T::INTEN: FLIEN3 Mask                  */
N
N#define GP_INTEN_FLIEN4_Pos              (4)                                               /*!< GP_T::INTEN: FLIEN4 Position              */
N#define GP_INTEN_FLIEN4_Msk              (0x1ul << GP_INTEN_FLIEN4_Pos)                    /*!< GP_T::INTEN: FLIEN4 Mask                  */
N
N#define GP_INTEN_FLIEN5_Pos              (5)                                               /*!< GP_T::INTEN: FLIEN5 Position              */
N#define GP_INTEN_FLIEN5_Msk              (0x1ul << GP_INTEN_FLIEN5_Pos)                    /*!< GP_T::INTEN: FLIEN5 Mask                  */
N
N#define GP_INTEN_FLIEN6_Pos              (6)                                               /*!< GP_T::INTEN: FLIEN6 Position              */
N#define GP_INTEN_FLIEN6_Msk              (0x1ul << GP_INTEN_FLIEN6_Pos)                    /*!< GP_T::INTEN: FLIEN6 Mask                  */
N
N#define GP_INTEN_FLIEN7_Pos              (7)                                               /*!< GP_T::INTEN: FLIEN7 Position              */
N#define GP_INTEN_FLIEN7_Msk              (0x1ul << GP_INTEN_FLIEN7_Pos)                    /*!< GP_T::INTEN: FLIEN7 Mask                  */
N
N#define GP_INTEN_RHIEN0_Pos              (16)                                              /*!< GP_T::INTEN: RHIEN0 Position              */
N#define GP_INTEN_RHIEN0_Msk              (0x1ul << GP_INTEN_RHIEN0_Pos)                    /*!< GP_T::INTEN: RHIEN0 Mask                  */
N
N#define GP_INTEN_RHIEN1_Pos              (17)                                              /*!< GP_T::INTEN: RHIEN1 Position              */
N#define GP_INTEN_RHIEN1_Msk              (0x1ul << GP_INTEN_RHIEN1_Pos)                    /*!< GP_T::INTEN: RHIEN1 Mask                  */
N
N#define GP_INTEN_RHIEN2_Pos              (18)                                              /*!< GP_T::INTEN: RHIEN2 Position              */
N#define GP_INTEN_RHIEN2_Msk              (0x1ul << GP_INTEN_RHIEN2_Pos)                    /*!< GP_T::INTEN: RHIEN2 Mask                  */
N
N#define GP_INTEN_RHIEN3_Pos              (19)                                              /*!< GP_T::INTEN: RHIEN3 Position              */
N#define GP_INTEN_RHIEN3_Msk              (0x1ul << GP_INTEN_RHIEN3_Pos)                    /*!< GP_T::INTEN: RHIEN3 Mask                  */
N
N#define GP_INTEN_RHIEN4_Pos              (20)                                              /*!< GP_T::INTEN: RHIEN4 Position              */
N#define GP_INTEN_RHIEN4_Msk              (0x1ul << GP_INTEN_RHIEN4_Pos)                    /*!< GP_T::INTEN: RHIEN4 Mask                  */
N
N#define GP_INTEN_RHIEN5_Pos              (21)                                              /*!< GP_T::INTEN: RHIEN5 Position              */
N#define GP_INTEN_RHIEN5_Msk              (0x1ul << GP_INTEN_RHIEN5_Pos)                    /*!< GP_T::INTEN: RHIEN5 Mask                  */
N
N#define GP_INTEN_RHIEN6_Pos              (22)                                              /*!< GP_T::INTEN: RHIEN6 Position              */
N#define GP_INTEN_RHIEN6_Msk              (0x1ul << GP_INTEN_RHIEN6_Pos)                    /*!< GP_T::INTEN: RHIEN6 Mask                  */
N
N#define GP_INTEN_RHIEN7_Pos              (23)                                              /*!< GP_T::INTEN: RHIEN7 Position              */
N#define GP_INTEN_RHIEN7_Msk              (0x1ul << GP_INTEN_RHIEN7_Pos)                    /*!< GP_T::INTEN: RHIEN7 Mask                  */
N
N#define GP_INTSRC_INTSRC0_Pos            (0)                                               /*!< GP_T::INTSRC: INTSRC0 Position            */
N#define GP_INTSRC_INTSRC0_Msk            (0x1ul << GP_INTSRC_INTSRC0_Pos)                  /*!< GP_T::INTSRC: INTSRC0 Mask                */
N
N#define GP_INTSRC_INTSRC1_Pos            (1)                                               /*!< GP_T::INTSRC: INTSRC1 Position            */
N#define GP_INTSRC_INTSRC1_Msk            (0x1ul << GP_INTSRC_INTSRC1_Pos)                  /*!< GP_T::INTSRC: INTSRC1 Mask                */
N
N#define GP_INTSRC_INTSRC2_Pos            (2)                                               /*!< GP_T::INTSRC: INTSRC2 Position            */
N#define GP_INTSRC_INTSRC2_Msk            (0x1ul << GP_INTSRC_INTSRC2_Pos)                  /*!< GP_T::INTSRC: INTSRC2 Mask                */
N
N#define GP_INTSRC_INTSRC3_Pos            (3)                                               /*!< GP_T::INTSRC: INTSRC3 Position            */
N#define GP_INTSRC_INTSRC3_Msk            (0x1ul << GP_INTSRC_INTSRC3_Pos)                  /*!< GP_T::INTSRC: INTSRC3 Mask                */
N
N#define GP_INTSRC_INTSRC4_Pos            (4)                                               /*!< GP_T::INTSRC: INTSRC4 Position            */
N#define GP_INTSRC_INTSRC4_Msk            (0x1ul << GP_INTSRC_INTSRC4_Pos)                  /*!< GP_T::INTSRC: INTSRC4 Mask                */
N
N#define GP_INTSRC_INTSRC5_Pos            (5)                                               /*!< GP_T::INTSRC: INTSRC5 Position            */
N#define GP_INTSRC_INTSRC5_Msk            (0x1ul << GP_INTSRC_INTSRC5_Pos)                  /*!< GP_T::INTSRC: INTSRC5 Mask                */
N
N#define GP_INTSRC_INTSRC6_Pos            (6)                                               /*!< GP_T::INTSRC: INTSRC6 Position            */
N#define GP_INTSRC_INTSRC6_Msk            (0x1ul << GP_INTSRC_INTSRC6_Pos)                  /*!< GP_T::INTSRC: INTSRC6 Mask                */
N
N#define GP_INTSRC_INTSRC7_Pos            (7)                                               /*!< GP_T::INTSRC: INTSRC7 Position            */
N#define GP_INTSRC_INTSRC7_Msk            (0x1ul << GP_INTSRC_INTSRC7_Pos)                  /*!< GP_T::INTSRC: INTSRC7 Mask                */
N
N#define GP_INTSRC_INTSRC8_Pos            (8)                                               /*!< GP_T::INTSRC: INTSRC8 Position            */
N#define GP_INTSRC_INTSRC8_Msk            (0x1ul << GP_INTSRC_INTSRC8_Pos)                  /*!< GP_T::INTSRC: INTSRC8 Mask                */
N
N#define GP_INTSRC_INTSRC9_Pos            (9)                                               /*!< GP_T::INTSRC: INTSRC9 Position            */
N#define GP_INTSRC_INTSRC9_Msk            (0x1ul << GP_INTSRC_INTSRC9_Pos)                  /*!< GP_T::INTSRC: INTSRC9 Mask                */
N
N#define GP_INTSRC_INTSRC10_Pos           (10)                                              /*!< GP_T::INTSRC: INTSRC10 Position           */
N#define GP_INTSRC_INTSRC10_Msk           (0x1ul << GP_INTSRC_INTSRC10_Pos)                 /*!< GP_T::INTSRC: INTSRC10 Mask               */
N
N#define GP_INTSRC_INTSRC11_Pos           (11)                                              /*!< GP_T::INTSRC: INTSRC11 Position           */
N#define GP_INTSRC_INTSRC11_Msk           (0x1ul << GP_INTSRC_INTSRC11_Pos)                 /*!< GP_T::INTSRC: INTSRC11 Mask               */
N
N#define GP_INTSRC_INTSRC12_Pos           (12)                                              /*!< GP_T::INTSRC: INTSRC12 Position           */
N#define GP_INTSRC_INTSRC12_Msk           (0x1ul << GP_INTSRC_INTSRC12_Pos)                 /*!< GP_T::INTSRC: INTSRC12 Mask               */
N
N#define GP_INTSRC_INTSRC13_Pos           (13)                                              /*!< GP_T::INTSRC: INTSRC13 Position           */
N#define GP_INTSRC_INTSRC13_Msk           (0x1ul << GP_INTSRC_INTSRC13_Pos)                 /*!< GP_T::INTSRC: INTSRC13 Mask               */
N
N#define GP_INTSRC_INTSRC14_Pos           (14)                                              /*!< GP_T::INTSRC: INTSRC14 Position           */
N#define GP_INTSRC_INTSRC14_Msk           (0x1ul << GP_INTSRC_INTSRC14_Pos)                 /*!< GP_T::INTSRC: INTSRC14 Mask               */
N
N#define GP_INTSRC_INTSRC15_Pos           (15)                                              /*!< GP_T::INTSRC: INTSRC15 Position           */
N#define GP_INTSRC_INTSRC15_Msk           (0x1ul << GP_INTSRC_INTSRC15_Pos)                 /*!< GP_T::INTSRC: INTSRC15 Mask               */
N
N#define GP_DBCTL_DBCLKSEL_Pos            (0)                                               /*!< GP_T::DBCTL: DBCLKSEL Position            */
N#define GP_DBCTL_DBCLKSEL_Msk            (0xful << GP_DBCTL_DBCLKSEL_Pos)                  /*!< GP_T::DBCTL: DBCLKSEL Mask                */
N
N#define GP_DBCTL_DBCLKSRC_Pos            (4)                                               /*!< GP_T::DBCTL: DBCLKSRC Position            */
N#define GP_DBCTL_DBCLKSRC_Msk            (0x1ul << GP_DBCTL_DBCLKSRC_Pos)                  /*!< GP_T::DBCTL: DBCLKSRC Mask                */
N
N#define GP_DBCTL_ICLKON_Pos              (5)                                               /*!< GP_T::DBCTL: ICLKON Position              */
N#define GP_DBCTL_ICLKON_Msk              (0x1ul << GP_DBCTL_ICLKON_Pos)                    /*!< GP_T::DBCTL: ICLKON Mask                  */
N
N/**@}*/ /* GP_CONST */
N/**@}*/ /* end of GP register group */
N
N
N/*---------------------- Inter-IC Bus Controller -------------------------*/
N/**
N    @addtogroup I2C Inter-IC Bus Controller(I2C)
N    Memory Mapped Structure for I2C Controller
N@{ */
N
Ntypedef struct {
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x00  I2C Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2]     |AA        |Assert Acknowledge Control Bit
N     * |        |          |When AA=1 is prior to address or data received, an acknowledged (low level to SDA) will be returned during the acknowledge clock pulse on the SCL line when 1.) A slave is acknowledging the address sent from master, 2.) The receiver devices are acknowledging the data sent by transmitter.
N     * |        |          |When AA=0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse on the SCL line.
N     * |[3]     |SI        |I2C Interrupt Flag
N     * |        |          |When a new I2C state is present in the I2C_STATUS register, the SI flag is set by hardware, and if bit INTEN (I2C_CTL[7]) is set, the I2C interrupt is requested.
N     * |        |          |SI must be cleared by software.
N     * |        |          |This bit can be cleared by software writing '1'.
N     * |[4]     |STO       |I2C STOP Control Bit
N     * |        |          |In Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this bit will be cleared by hardware automatically.
N     * |        |          |In Slave mode, setting STO resets I2C hardware to the defined "not addressed" Slave mode.
N     * |        |          |This means it is NO LONGER in the Slave receiver mode to receive data from the master transmit device.
N     * |[5]     |STA       |I2C START Control Bit
N     * |        |          |Set STA to logic 1 to enter Master mode.
N     * |        |          |I2C hardware sends a START or repeats the START condition to bus when the bus is free.
N     * |[6]     |I2CEN     |I2C Controller Enable Bit
N     * |        |          |0 = I2C Controller Disabled.
N     * |        |          |1 = I2C Controller Enabled.
N     * |        |          |Set to enable I2C serial function controller.
N     * |        |          |When I2CEN=1 the I2C serial function enables.
N     * |        |          |The function of multi-function pin must be set to I2C firs.
N     * |[7]     |INTEN     |Interrupt Enable Bit
N     * |        |          |0 = I2C interrupt Disabled.
N     * |        |          |1 = I2C interrupt Enabled.
N    */
N    __IO uint32_t CTL;
X    volatile uint32_t CTL;
N
N    /**
N     * ADDR0
N     * ===================================================================================================
N     * Offset: 0x04  I2C Slave Address Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function Control
N     * |        |          |0 = General Call Function Disabled.
N     * |        |          |1 = General Call Function Enabled.
N     * |[7:1]   |ADDR      |I2C Address
N     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N     * |        |          |In Slave mode, the seven most significant bits must be loaded with the MCU's own address.
N     * |        |          |The I2C hardware will react if either of the address is matched.
N    */
N    __IO uint32_t ADDR0;
X    volatile uint32_t ADDR0;
N
N    /**
N     * DAT
N     * ===================================================================================================
N     * Offset: 0x08  I2C DATA Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |DAT       |I2C Data Register
N     * |        |          |Bit [7:0] is located with the 8-bit transferred data of the I2C serial port.
N    */
N    __IO uint32_t DAT;
X    volatile uint32_t DAT;
N
N    /**
N     * STATUS
N     * ===================================================================================================
N     * Offset: 0x0C  I2C Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |STATUS    |I2C Status Register
N     * |        |          |The three least significant bits are always 0.
N     * |        |          |The five most significant bits contain the status code.
N     * |        |          |There are 26 possible status codes.
N     * |        |          |When I2C_STATUS contains F8H, no serial interrupt is requested.
N     * |        |          |All the other I2C_STATUS values correspond to defined I2C states.
N     * |        |          |When each of these states is entered, a status interrupt is requested (SI = 1).
N     * |        |          |A valid status code is present in I2C_STATUS one cycle after SI is set by hardware and is still present one cycle after SI has been reset by software.
N     * |        |          |In addition, the states 00H stands for a Bus Error.
N     * |        |          |A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame.
N     * |        |          |Examples of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.
N    */
N    __I  uint32_t STATUS;
X    volatile const  uint32_t STATUS;
N
N    /**
N     * CLKDIV
N     * ===================================================================================================
N     * Offset: 0x10  I2C Clock Divided Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |DIVIDER   |I2C Clock Divided Register
N     * |        |          |The I2C clock rate bits: Data Baud Rate of I2C = (system clock) / (4 * (I2C_CLKDIV+1)).
N     * |        |          |Note: The minimum value of I2C_CLKDIV is 4.
N    */
N    __IO uint32_t CLKDIV;
X    volatile uint32_t CLKDIV;
N
N    /**
N     * TOCTL
N     * ===================================================================================================
N     * Offset: 0x14  I2C Time-out Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TOIF      |Time-out Flag
N     * |        |          |This bit is set by hardware when I2C time-out happened and it can interrupt CPU if I2C interrupt enable bit (INTEN) is set to 1.
N     * |        |          |Note: This bit can be cleared by software writing '1'.
N     * |[1]     |TOCURIEN  |Time-out Counter Input Clock Divided By 4
N     * |        |          |0 = Time-out counter input clock divided by 4 Disabled.
N     * |        |          |1 = Time-out counter input clock divided by 4 Enabled.
N     * |        |          |Note: When enabled, the time-out period is extended 4 times.
N     * |[2]     |TOCEN     |Time-out Counter Enable Bit
N     * |        |          |0 = Time-out counter Disabled.
N     * |        |          |1 = Time-out counter Enabled.
N     * |        |          |Note: When the 14-bit time-out counter is enabled, it will start counting when SI is cleared.
N     * |        |          |Setting 1 to the SI flag will reset counter and re-start up counting after SI is cleared.
N    */
N    __IO uint32_t TOCTL;
X    volatile uint32_t TOCTL;
N
N    /**
N     * ADDR1
N     * ===================================================================================================
N     * Offset: 0x18  I2C Slave Address Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function Control
N     * |        |          |0 = General Call Function Disabled.
N     * |        |          |1 = General Call Function Enabled.
N     * |[7:1]   |ADDR      |I2C Address
N     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N     * |        |          |In Slave mode, the seven most significant bits must be loaded with the MCU's own address.
N     * |        |          |The I2C hardware will react if either of the address is matched.
N    */
N    __IO uint32_t ADDR1;
X    volatile uint32_t ADDR1;
N
N    /**
N     * ADDR2
N     * ===================================================================================================
N     * Offset: 0x1C  I2C Slave Address Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function Control
N     * |        |          |0 = General Call Function Disabled.
N     * |        |          |1 = General Call Function Enabled.
N     * |[7:1]   |ADDR      |I2C Address
N     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N     * |        |          |In Slave mode, the seven most significant bits must be loaded with the MCU's own address.
N     * |        |          |The I2C hardware will react if either of the address is matched.
N    */
N    __IO uint32_t ADDR2;
X    volatile uint32_t ADDR2;
N
N    /**
N     * ADDR3
N     * ===================================================================================================
N     * Offset: 0x20  I2C Slave Address Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function Control
N     * |        |          |0 = General Call Function Disabled.
N     * |        |          |1 = General Call Function Enabled.
N     * |[7:1]   |ADDR      |I2C Address
N     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N     * |        |          |In Slave mode, the seven most significant bits must be loaded with the MCU's own address.
N     * |        |          |The I2C hardware will react if either of the address is matched.
N    */
N    __IO uint32_t ADDR3;
X    volatile uint32_t ADDR3;
N
N    /**
N     * ADDRMSK0
N     * ===================================================================================================
N     * Offset: 0x24  I2C Slave Address Mask Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |ADDRMSK   |I2C Address Mask Bits
N     * |        |          |0 = I2C address mask Disabled (the received corresponding register bit should be exactly the same as address register).
N     * |        |          |1 = I2C address mask Enabled (the received corresponding address bit is "Don't care").
N    */
N    __IO uint32_t ADDRMSK0;
X    volatile uint32_t ADDRMSK0;
N
N    /**
N     * ADDRMSK1
N     * ===================================================================================================
N     * Offset: 0x28  I2C Slave Address Mask Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |ADDRMSK   |I2C Address Mask Bits
N     * |        |          |0 = I2C address mask Disabled (the received corresponding register bit should be exactly the same as address register).
N     * |        |          |1 = I2C address mask Enabled (the received corresponding address bit is "Don't care").
N    */
N    __IO uint32_t ADDRMSK1;
X    volatile uint32_t ADDRMSK1;
N
N    /**
N     * ADDRMSK2
N     * ===================================================================================================
N     * Offset: 0x2C  I2C Slave Address Mask Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |ADDRMSK   |I2C Address Mask Bits
N     * |        |          |0 = I2C address mask Disabled (the received corresponding register bit should be exactly the same as address register).
N     * |        |          |1 = I2C address mask Enabled (the received corresponding address bit is "Don't care").
N    */
N    __IO uint32_t ADDRMSK2;
X    volatile uint32_t ADDRMSK2;
N
N    /**
N     * ADDRMSK3
N     * ===================================================================================================
N     * Offset: 0x30  I2C Slave Address Mask Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |ADDRMSK   |I2C Address Mask Bits
N     * |        |          |0 = I2C address mask Disabled (the received corresponding register bit should be exactly the same as address register).
N     * |        |          |1 = I2C address mask Enabled (the received corresponding address bit is "Don't care").
N    */
N    __IO uint32_t ADDRMSK3;
X    volatile uint32_t ADDRMSK3;
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVED0[2];
X    volatile const  uint32_t RESERVED0[2];
N    /// @endcond //HIDDEN_SYMBOLS
N
N    /**
N     * CTL1
N     * ===================================================================================================
N     * Offset: 0x3C  I2C Control Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WKEN      |Wake-up Enable Bit
N     * |        |          |0 = I2C wake-up function Disabled.
N     * |        |          |1 = I2C wake-up function Enabled.
N     * |        |          |The system can be woken up by I2C bus when the system is set into Power mode and the received data matched one of the addresses in Address Register.
N     * |        |          |Note: Only I2C0 channel supports wake-up function. This bit is not valid on I2C1 channel.
N     * |[1]     |TWOLVFIFO |Two-level Buffer Enable Bit
N     * |        |          |0 = Two-level buffer Disabled.
N     * |        |          |1 = Two-level buffer Enabled.
N     * |        |          |Set to enable the two-level buffer for I2C transmitted or received buffer.
N     * |        |          |It is used to improve the performance of the I2C bus.
N     * |        |          |If this bit is set = 1, the control bit of STA for repeat start or STO bit should be set after the current SI is clear.
N     * |        |          |For example: if there are 4 data shall be transmitted and then stop it.
N     * |        |          |The STO bit shall be set after the 3rd data's SI event being clear.
N     * |        |          |In this time, the 4th data can be transmitted and the I2C stop after the 4th data transmission don.
N     * |[2]     |NSTRETCH  |No Stretch On The I2C Bus
N     * |        |          |0 = The I2C SCL bus is stretched by hardware if the SI is not cleared in master mode.
N     * |        |          |1 = The I2C SCL bus is not stretched by hardware if the SI is not cleared in master mode.
N     * |[3]     |OVIEN     |I2C Overrun Interrupt Control
N     * |        |          |Setting OVIEN to 1 will send a interrupt to system when the TWOLVFF bit is enabled and there is overrun event in received buffer.
N     * |        |          |0 = Overrun Interrupt Disabled.
N     * |        |          |1 = Overrun Interrupt Enabled.
N     * |[4]     |URIEN     |I2C Under Run Interrupt Control
N     * |        |          |Setting URIEN to 1 will send a interrupt to system when the TWOLVFF bit is enabled and there is under run event happened in transmitted buffer.
N     * |        |          |0 = Under run Interrupt Disabled.
N     * |        |          |1 = Under run Interrupt Enabled.
N    */
N    __IO uint32_t CTL1;
X    volatile uint32_t CTL1;
N
N    /**
N     * STATUS1
N     * ===================================================================================================
N     * Offset: 0x40  I2C Status Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WKIF      |I2C Wake-up Interrupt Flag
N     * |        |          |When chip is woken up from Power-down mode by I2C, this bit is set to 1.
N     * |        |          |This bit can be cleared by software writing "1".
N     * |        |          |Note: Only I2C0 channel supports wake-up function. This bit is not valid on I2C1 channel.
N     * |[1]     |FULL      |I2C Two-level Buffer Full
N     * |        |          |This bit indicates if the TX buffer is full or not when the TWOLVFIFO = 1.
N     * |[2]     |EMPTY     |I2C Two-level Buffer Empty
N     * |        |          |This bit indicates if the RX buffer is empty or not when the TWOLVFIFO = 1.
N     * |[3]     |OVIF      |I2C Overrun Status
N     * |        |          |This bit indicates the received buffer is overrun when the TWOLVFIFO = 1.
N     * |[4]     |URIF      |I2C Under Run Status
N     * |        |          |This bit indicates the transmitted buffer is under run when the TWOLVFIFO = 1.
N    */
N    __IO uint32_t STATUS1;
X    volatile uint32_t STATUS1;
N
N} I2C_T;
N
N/**
N    @addtogroup I2C_CONST I2C Bit Field Definition
N    Constant Definitions for I2C Controller
N@{ */
N
N#define I2C_CTL_AA_Pos                   (2)                                               /*!< I2C_T::CTL: AA Position                   */
N#define I2C_CTL_AA_Msk                   (0x1ul << I2C_CTL_AA_Pos)                         /*!< I2C_T::CTL: AA Mask                       */
N
N#define I2C_CTL_SI_Pos                   (3)                                               /*!< I2C_T::CTL: SI Position                   */
N#define I2C_CTL_SI_Msk                   (0x1ul << I2C_CTL_SI_Pos)                         /*!< I2C_T::CTL: SI Mask                       */
N
N#define I2C_CTL_STO_Pos                  (4)                                               /*!< I2C_T::CTL: STO Position                  */
N#define I2C_CTL_STO_Msk                  (0x1ul << I2C_CTL_STO_Pos)                        /*!< I2C_T::CTL: STO Mask                      */
N
N#define I2C_CTL_STA_Pos                  (5)                                               /*!< I2C_T::CTL: STA Position                  */
N#define I2C_CTL_STA_Msk                  (0x1ul << I2C_CTL_STA_Pos)                        /*!< I2C_T::CTL: STA Mask                      */
N
N#define I2C_CTL_I2CEN_Pos                (6)                                               /*!< I2C_T::CTL: I2CEN Position                */
N#define I2C_CTL_I2CEN_Msk                (0x1ul << I2C_CTL_I2CEN_Pos)                      /*!< I2C_T::CTL: I2CEN Mask                    */
N
N#define I2C_CTL_INTEN_Pos                (7)                                               /*!< I2C_T::CTL: INTEN Position                */
N#define I2C_CTL_INTEN_Msk                (0x1ul << I2C_CTL_INTEN_Pos)                      /*!< I2C_T::CTL: INTEN Mask                    */
N
N#define I2C_ADDR0_GC_Pos                 (0)                                               /*!< I2C_T::ADDR0: GC Position                 */
N#define I2C_ADDR0_GC_Msk                 (0x1ul << I2C_ADDR0_GC_Pos)                       /*!< I2C_T::ADDR0: GC Mask                     */
N
N#define I2C_ADDR0_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR0: ADDR Position               */
N#define I2C_ADDR0_ADDR_Msk               (0x7ful << I2C_ADDR0_ADDR_Pos)                    /*!< I2C_T::ADDR0: ADDR Mask                   */
N
N#define I2C_DAT_DAT_Pos                  (0)                                               /*!< I2C_T::DAT: DAT Position                  */
N#define I2C_DAT_DAT_Msk                  (0xfful << I2C_DAT_DAT_Pos)                       /*!< I2C_T::DAT: DAT Mask                      */
N
N#define I2C_STATUS_STATUS_Pos            (0)                                               /*!< I2C_T::STATUS: STATUS Position            */
N#define I2C_STATUS_STATUS_Msk            (0xfful << I2C_STATUS_STATUS_Pos)                 /*!< I2C_T::STATUS: STATUS Mask                */
N
N#define I2C_CLKDIV_DIVIDER_Pos           (0)                                               /*!< I2C_T::CLKDIV: DIVIDER Position           */
N#define I2C_CLKDIV_DIVIDER_Msk           (0xfful << I2C_CLKDIV_DIVIDER_Pos)                /*!< I2C_T::CLKDIV: DIVIDER Mask               */
N
N#define I2C_TOCTL_TOIF_Pos               (0)                                               /*!< I2C_T::TOCTL: TOIF Position               */
N#define I2C_TOCTL_TOIF_Msk               (0x1ul << I2C_TOCTL_TOIF_Pos)                     /*!< I2C_T::TOCTL: TOIF Mask                   */
N
N#define I2C_TOCTL_TOCURIEN_Pos           (1)                                               /*!< I2C_T::TOCTL: TOCURIEN Position           */
N#define I2C_TOCTL_TOCURIEN_Msk           (0x1ul << I2C_TOCTL_TOCURIEN_Pos)                 /*!< I2C_T::TOCTL: TOCURIEN Mask               */
N
N#define I2C_TOCTL_TOCEN_Pos              (2)                                               /*!< I2C_T::TOCTL: TOCEN Position              */
N#define I2C_TOCTL_TOCEN_Msk              (0x1ul << I2C_TOCTL_TOCEN_Pos)                    /*!< I2C_T::TOCTL: TOCEN Mask                  */
N
N#define I2C_ADDR1_GC_Pos                 (0)                                               /*!< I2C_T::ADDR1: GC Position                 */
N#define I2C_ADDR1_GC_Msk                 (0x1ul << I2C_ADDR1_GC_Pos)                       /*!< I2C_T::ADDR1: GC Mask                     */
N
N#define I2C_ADDR1_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR1: ADDR Position               */
N#define I2C_ADDR1_ADDR_Msk               (0x7ful << I2C_ADDR1_ADDR_Pos)                    /*!< I2C_T::ADDR1: ADDR Mask                   */
N
N#define I2C_ADDR2_GC_Pos                 (0)                                               /*!< I2C_T::ADDR2: GC Position                 */
N#define I2C_ADDR2_GC_Msk                 (0x1ul << I2C_ADDR2_GC_Pos)                       /*!< I2C_T::ADDR2: GC Mask                     */
N
N#define I2C_ADDR2_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR2: ADDR Position               */
N#define I2C_ADDR2_ADDR_Msk               (0x7ful << I2C_ADDR2_ADDR_Pos)                    /*!< I2C_T::ADDR2: ADDR Mask                   */
N
N#define I2C_ADDR3_GC_Pos                 (0)                                               /*!< I2C_T::ADDR3: GC Position                 */
N#define I2C_ADDR3_GC_Msk                 (0x1ul << I2C_ADDR3_GC_Pos)                       /*!< I2C_T::ADDR3: GC Mask                     */
N
N#define I2C_ADDR3_ADDR_Pos               (1)                                               /*!< I2C_T::ADDR3: ADDR Position               */
N#define I2C_ADDR3_ADDR_Msk               (0x7ful << I2C_ADDR3_ADDR_Pos)                    /*!< I2C_T::ADDR3: ADDR Mask                   */
N
N#define I2C_ADDRMSK0_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK0: ADDRMSK Position         */
N#define I2C_ADDRMSK0_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK0_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK0: ADDRMSK Mask             */
N
N#define I2C_ADDRMSK1_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK1: ADDRMSK Position         */
N#define I2C_ADDRMSK1_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK1_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK1: ADDRMSK Mask             */
N
N#define I2C_ADDRMSK2_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK2: ADDRMSK Position         */
N#define I2C_ADDRMSK2_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK2_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK2: ADDRMSK Mask             */
N
N#define I2C_ADDRMSK3_ADDRMSK_Pos         (1)                                               /*!< I2C_T::ADDRMSK3: ADDRMSK Position         */
N#define I2C_ADDRMSK3_ADDRMSK_Msk         (0x7ful << I2C_ADDRMSK3_ADDRMSK_Pos)              /*!< I2C_T::ADDRMSK3: ADDRMSK Mask             */
N
N#define I2C_CTL1_WKEN_Pos                (0)                                               /*!< I2C_T::CTL1: WKEN Position                */
N#define I2C_CTL1_WKEN_Msk                (0x1ul << I2C_CTL1_WKEN_Pos)                      /*!< I2C_T::CTL1: WKEN Mask                    */
N
N#define I2C_CTL1_TWOLVFIFO_Pos           (1)                                               /*!< I2C_T::CTL1: TWOLVFIFO Position           */
N#define I2C_CTL1_TWOLVFIFO_Msk           (0x1ul << I2C_CTL1_TWOLVFIFO_Pos)                 /*!< I2C_T::CTL1: TWOLVFIFO Mask               */
N
N#define I2C_CTL1_NSTRETCH_Pos            (2)                                               /*!< I2C_T::CTL1: NSTRETCH Position            */
N#define I2C_CTL1_NSTRETCH_Msk            (0x1ul << I2C_CTL1_NSTRETCH_Pos)                  /*!< I2C_T::CTL1: NSTRETCH Mask                */
N
N#define I2C_CTL1_OVIEN_Pos               (3)                                               /*!< I2C_T::CTL1: OVIEN Position               */
N#define I2C_CTL1_OVIEN_Msk               (0x1ul << I2C_CTL1_OVIEN_Pos)                     /*!< I2C_T::CTL1: OVIEN Mask                   */
N
N#define I2C_CTL1_URIEN_Pos               (4)                                               /*!< I2C_T::CTL1: URIEN Position               */
N#define I2C_CTL1_URIEN_Msk               (0x1ul << I2C_CTL1_URIEN_Pos)                     /*!< I2C_T::CTL1: URIEN Mask                   */
N
N#define I2C_STATUS1_WKIF_Pos             (0)                                               /*!< I2C_T::STATUS1: WKIF Position             */
N#define I2C_STATUS1_WKIF_Msk             (0x1ul << I2C_STATUS1_WKIF_Pos)                   /*!< I2C_T::STATUS1: WKIF Mask                 */
N
N#define I2C_STATUS1_FULL_Pos             (1)                                               /*!< I2C_T::STATUS1: FULL Position             */
N#define I2C_STATUS1_FULL_Msk             (0x1ul << I2C_STATUS1_FULL_Pos)                   /*!< I2C_T::STATUS1: FULL Mask                 */
N
N#define I2C_STATUS1_EMPTY_Pos            (2)                                               /*!< I2C_T::STATUS1: EMPTY Position            */
N#define I2C_STATUS1_EMPTY_Msk            (0x1ul << I2C_STATUS1_EMPTY_Pos)                  /*!< I2C_T::STATUS1: EMPTY Mask                */
N
N#define I2C_STATUS1_OVIF_Pos             (3)                                               /*!< I2C_T::STATUS1: OVIF Position             */
N#define I2C_STATUS1_OVIF_Msk             (0x1ul << I2C_STATUS1_OVIF_Pos)                   /*!< I2C_T::STATUS1: OVIF Mask                 */
N
N#define I2C_STATUS1_URIF_Pos             (4)                                               /*!< I2C_T::STATUS1: URIF Position             */
N#define I2C_STATUS1_URIF_Msk             (0x1ul << I2C_STATUS1_URIF_Pos)                   /*!< I2C_T::STATUS1: URIF Mask                 */
N
N/**@}*/ /* I2C_CONST */
N/**@}*/ /* end of I2C register group */
N
N
N/*---------------------- INT Controller -------------------------*/
N/**
N    @addtogroup INT Interrupt Controller (INT)
N    Memory Mapped Structure for INT Controller
N@{ */
N
Ntypedef struct {
N
N
N    /**
N     * IRQ0_SRC
N     * ===================================================================================================
N     * Offset: 0x00  IRQ0 (BOD) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BOD_INT   |IRQ0 Source Identity
N     * |        |          |0 = IRQ0 source is not from BOD interrupt (BOD_INT).
N     * |        |          |1 = IRQ0 source is from BOD interrupt (BOD_INT).
N    */
N    __I  uint32_t IRQ0_SRC;
X    volatile const  uint32_t IRQ0_SRC;
N
N    /**
N     * IRQ1_SRC
N     * ===================================================================================================
N     * Offset: 0x04  IRQ1 (WDT) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WDT_INT   |IRQ1 Source Identity
N     * |        |          |0 = IRQ1 source is not from watchdog interrupt (WDT _INT).
N     * |        |          |1 = IRQ1 source is from watchdog interrupt (WDT_INT).
N     * |[1]     |WWDT_INT  |IRQ1 Source Identity
N     * |        |          |0 = IRQ1 source is not from window watchdog interrupt (WWDT _INT).
N     * |        |          |1 = IRQ1 source is from window watchdog interrupt (WWDT_INT).
N    */
N    __I  uint32_t IRQ1_SRC;
X    volatile const  uint32_t IRQ1_SRC;
N
N    /**
N     * IRQ2_SRC
N     * ===================================================================================================
N     * Offset: 0x08  IRQ2 (EINT0) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |EINT0     |IRQ2 Source Identity
N     * |        |          |0 = IRQ2 source is not from external signal interrupt 0 from P3.2 (EINT0).
N     * |        |          |1 = IRQ2 source is from external signal interrupt 0 from P3.2 (EINT0).
N    */
N    __I  uint32_t IRQ2_SRC;
X    volatile const  uint32_t IRQ2_SRC;
N
N    /**
N     * IRQ3_SRC
N     * ===================================================================================================
N     * Offset: 0x0C  IRQ3 (EINT1) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |EINT1     |IRQ3 Source Identity
N     * |        |          |0 = IRQ3 source is not from external signal interrupt 1 from P5.2 (EINT1).
N     * |        |          |1 = IRQ3 source is from external signal interrupt 1 from P5.2 (EINT1).
N    */
N    __I  uint32_t IRQ3_SRC;
X    volatile const  uint32_t IRQ3_SRC;
N
N    /**
N     * IRQ4_SRC
N     * ===================================================================================================
N     * Offset: 0x10  IRQ4 (GP0/1) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GP0_INT   |IRQ4 Source Identity
N     * |        |          |0 = IRQ4 source is not from GP0 interrupt (GP0_INT).
N     * |        |          |1 = IRQ4 source is from GP0 interrupt (GP0_INT).
N     * |[1]     |GP1_INT   |IRQ4 Source Identity
N     * |        |          |0 = IRQ4 source is not from GP1 interrupt (GP1_INT).
N     * |        |          |1 = IRQ4 source is from GP1 interrupt (GP1_INT).
N    */
N    __I  uint32_t IRQ4_SRC;
X    volatile const  uint32_t IRQ4_SRC;
N
N    /**
N     * IRQ5_SRC
N     * ===================================================================================================
N     * Offset: 0x14  IRQ5 (GP2/3/4) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GP2_INT   |IRQ5 Source Identity
N     * |        |          |0 = IRQ5 source is not from GP2 interrupt (GP2_INT).
N     * |        |          |1 = IRQ5 source is from GP2 interrupt (GP2_INT).
N     * |[1]     |GP3_INT   |IRQ5 Source Identity
N     * |        |          |0 = IRQ5 source is not from GP3 interrupt (GP3_INT).
N     * |        |          |1 = IRQ5 source is from GP3 interrupt (GP3_INT).
N     * |[2]     |GP4_INT   |IRQ5 Source Identity
N     * |        |          |0 = IRQ5 source is not from GP4 interrupt (GP4_INT).
N     * |        |          |1 = IRQ5 source is from GP4 interrupt (GP4_INT).
N    */
N    __I  uint32_t IRQ5_SRC;
X    volatile const  uint32_t IRQ5_SRC;
N
N    /**
N     * IRQ6_SRC
N     * ===================================================================================================
N     * Offset: 0x18  IRQ6 (PWM) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PWM_INT   |IRQ6 Source Identity
N     * |        |          |0 = IRQ6 source is not from PWM interrupt (PWM_INT).
N     * |        |          |1 = IRQ6 source is from PWM interrupt (PWM_INT).
N    */
N    __I  uint32_t IRQ6_SRC;
X    volatile const  uint32_t IRQ6_SRC;
N
N    /**
N     * IRQ7_SRC
N     * ===================================================================================================
N     * Offset: 0x1C  IRQ7 (BRAKE) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BRAKE_INT |IRQ7 Source Identity
N     * |        |          |0 = IRQ7 source is not from Brake interrupt (BRAKE_INT).
N     * |        |          |1 = IRQ7 source is from Brake interrupt (BRAKE_INT).
N    */
N    __I  uint32_t IRQ7_SRC;
X    volatile const  uint32_t IRQ7_SRC;
N
N    /**
N     * IRQ8_SRC
N     * ===================================================================================================
N     * Offset: 0x20  IRQ8 (TMR0) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TMR0_INT  |IRQ8 Source Identity
N     * |        |          |0 = IRQ8 source is not from Timer0 interrupt (TMR0_INT).
N     * |        |          |1 = IRQ8 source is from Timer0 interrupt (TMR0_INT).
N    */
N    __I  uint32_t IRQ8_SRC;
X    volatile const  uint32_t IRQ8_SRC;
N
N    /**
N     * IRQ9_SRC
N     * ===================================================================================================
N     * Offset: 0x24  IRQ9 (TMR1) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TMR1_INT  |IRQ9 Source Identity
N     * |        |          |0 = IRQ9 source is not from Timer1 interrupt (TMR1_INT).
N     * |        |          |1 = IRQ9 source is from Timer1 interrupt (TMR1_INT).
N    */
N    __I  uint32_t IRQ9_SRC;
X    volatile const  uint32_t IRQ9_SRC;
N
N    /// @cond HIDDEN_SYMBOLS
N    uint32_t RESERVE0[2];
N    /// @endcond //HIDDEN_SYMBOLS
N
N    /**
N     * IRQ12_SRC
N     * ===================================================================================================
N     * Offset: 0x30  IRQ12 (UART0) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |UART0_INT |IRQ12 Source Identity
N     * |        |          |0 = IRQ12 source is not from UART0 interrupt (UART0_INT).
N     * |        |          |1 = IRQ12 source is from UART0 interrupt (UART0_INT).
N    */
N    __I  uint32_t IRQ12_SRC;
X    volatile const  uint32_t IRQ12_SRC;
N
N    /**
N     * IRQ13_SRC
N     * ===================================================================================================
N     * Offset: 0x34  IRQ13 (UART1) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |UART1_INT |IRQ13 Source Identity
N     * |        |          |0 = IRQ13 source is not from UART1 interrupt (UART1_INT).
N     * |        |          |1 = IRQ13 source is from UART1 interrupt (UART1_INT).
N    */
N    __I  uint32_t IRQ13_SRC;
X    volatile const  uint32_t IRQ13_SRC;
N
N    /**
N     * IRQ14_SRC
N     * ===================================================================================================
N     * Offset: 0x38  IRQ14 (SPI) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SPI_INT   |IRQ14 Source Identity
N     * |        |          |0 = IRQ14 source is not from SPI interrupt (SPI_INT).
N     * |        |          |1 = IRQ14 source is from SPI interrupt (SPI_INT).
N    */
N    __I  uint32_t IRQ14_SRC;
X    volatile const  uint32_t IRQ14_SRC;
N
N    /// @cond HIDDEN_SYMBOLS
N    uint32_t RESERVE1[1];
N    /// @endcond //HIDDEN_SYMBOLS
N
N    /**
N     * IRQ16_SRC
N     * ===================================================================================================
N     * Offset: 0x40  IRQ16 (GP5) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GP5_INT   |IRQ16 Source Identity
N     * |        |          |0 = IRQ16 source is not from GP5 interrupt (GP5_INT).
N     * |        |          |1 = IRQ16 source is from GP5 interrupt (GP5_INT).
N    */
N    __I  uint32_t IRQ16_SRC;
X    volatile const  uint32_t IRQ16_SRC;
N
N    /**
N     * IRQ17_SRC
N     * ===================================================================================================
N     * Offset: 0x44  IRQ17 (HIRC trim) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |HIRC_TRIM_INT|IRQ17 Source Identity
N     * |        |          |0 = IRQ17 source is not from HIRC trim interrupt (HIRC_TRIM_INT).
N     * |        |          |1 = IRQ17 source is from HIRC trim interrupt (HIRC_TRIM_INT).
N    */
N    __I  uint32_t IRQ17_SRC;
X    volatile const  uint32_t IRQ17_SRC;
N
N    /**
N     * IRQ18_SRC
N     * ===================================================================================================
N     * Offset: 0x48  IRQ18 (I2C0) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |I2C0_INT  |IRQ18 Source Identity
N     * |        |          |0 = IRQ18 source is not from I2C0 interrupt (I2C0_INT).
N     * |        |          |1 = IRQ18 source is from I2C0 interrupt (I2C0_INT).
N    */
N    __I  uint32_t IRQ18_SRC;
X    volatile const  uint32_t IRQ18_SRC;
N
N    /**
N     * IRQ19_SRC
N     * ===================================================================================================
N     * Offset: 0x4C  IRQ19 (I2C1) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |I2C1_INT  |IRQ19 Source Identity
N     * |        |          |0 = IRQ19 source is not from I2C1 interrupt (I2C1_INT).
N     * |        |          |1 = IRQ19 source is from I2C1 interrupt (I2C1_INT).
N    */
N    __I  uint32_t IRQ19_SRC;
X    volatile const  uint32_t IRQ19_SRC;
N
N    /// @cond HIDDEN_SYMBOLS
N    uint32_t RESERVE2[5];
N    /// @endcond //HIDDEN_SYMBOLS
N
N    /**
N     * IRQ25_SRC
N     * ===================================================================================================
N     * Offset: 0x64  IRQ25 (ACMP) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ACMP_INT  |IRQ25 Source Identity
N     * |        |          |0 = IRQ25 source is not from ACMP interrupt (ACMP_INT).
N     * |        |          |1 = IRQ25 source is from ACMP interrupt (ACMP_INT).
N    */
N    __I  uint32_t IRQ25_SRC;
X    volatile const  uint32_t IRQ25_SRC;
N
N    /// @cond HIDDEN_SYMBOLS
N    uint32_t RESERVE3[2];
N    /// @endcond //HIDDEN_SYMBOLS
N
N    /**
N     * IRQ28_SRC
N     * ===================================================================================================
N     * Offset: 0x70  IRQ28 (PWRWU) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PWRWU_INT |IRQ28 Source Identity
N     * |        |          |0 = IRQ28 source is not from PWRWU interrupt (PWRWU_INT).
N     * |        |          |1 = IRQ28 source is from PWREU interrupt (PWRWU_INT).
N    */
N    __I  uint32_t IRQ28_SRC;
X    volatile const  uint32_t IRQ28_SRC;
N
N    /**
N     * IRQ29_SRC
N     * ===================================================================================================
N     * Offset: 0x74  IRQ29 (ADC) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ADC_INT   |IRQ29 Source Identity
N     * |        |          |0 = IRQ29 source is not from ADC interrupt (ADC_INT).
N     * |        |          |1 = IRQ29 source is from ADC interrupt (ADC_INT).
N    */
N    __I  uint32_t IRQ29_SRC;
X    volatile const  uint32_t IRQ29_SRC;
N
N    /**
N     * CON
N     * ===================================================================================================
N     * Offset: 0x80  NMI Source Interrupt Select Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4:0]   |NMI_SEL   |NMI Interrupt Source Select Bit
N     * |        |          |The NMI interrupt to Cortex-M0 can be selected from one of the peripheral interrupt by setting NMI_SEL.
N     * |[8]     |NMI_SEL_EN|NMI Interrupt Enable Bit (Write Protected)
N     * |        |          |0 = NMI interrupt Disabled.
N     * |        |          |1 = NMI interrupt Enabled.
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write 0x59, 0x16, and 0x88 to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register SYS_REGLCTL at address SYS_BA+0x10.
N    */
N    __IO uint32_t CON;
X    volatile uint32_t CON;
N
N    /**
N     * IRQ
N     * ===================================================================================================
N     * Offset: 0x84  MCU IRQ Number Identity Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |MCU_IRQ   |MCU IRQ Source Bits
N     * |        |          |The MCU_IRQ collects all the interrupts from the peripherals and generates the synchronous interrupt to Cortex-M0 core.
N     * |        |          |There are two modes to generate interrupt to Cortex-M0 - the normal mode and test mod.
N     * |        |          |The MCU_IRQ collects all interrupts from each peripheral and synchronizes them then interrupts the Cortex-M0.
N     * |        |          |When the MCU_IRQ[n] is 0, setting MCU_IRQ[n] to 1 will generate an interrupt to Cortex-M0 NVIC[n].
N     * |        |          |When the MCU_IRQ[n] is 1 (mean an interrupt is assert), setting 1 to the MCU_bit[n] will clear the interrupt and setting MCU_IRQ[n] 0 has no effect.
N    */
N    __IO uint32_t IRQ;
X    volatile uint32_t IRQ;
N
N} INTR_T;
N
N/**
N    @addtogroup INT_CONST INT Bit Field Definition
N    Constant Definitions for INT Controller
N@{ */
N
N#define INT_IRQ0_SRC_BOD_INT_Pos                (0)                                               /*!< INT_T::IRQ0_SRC: BOD_INT Position         */
N#define INT_IRQ0_SRC_BOD_INT_Msk                (0x1ul << INT_IRQ0_SRC_BOD_INT_Pos)               /*!< INT_T::IRQ0_SRC: BOD_INT Mask             */
N
N#define INT_IRQ1_SRC_WDT_INT_Pos                (0)                                               /*!< INT_T::IRQ1_SRC: WDT_INT Position         */
N#define INT_IRQ1_SRC_WDT_INT_Msk                (0x1ul << INT_IRQ1_SRC_WDT_INT_Pos)               /*!< INT_T::IRQ1_SRC: WDT_INT Mask             */
N
N#define INT_IRQ1_SRC_WWDT_INT_Pos               (1)                                               /*!< INT_T::IRQ1_SRC: WWDT_INT Position        */
N#define INT_IRQ1_SRC_WWDT_INT_Msk               (0x1ul << INT_IRQ1_SRC_WWDT_INT_Pos)              /*!< INT_T::IRQ1_SRC: WWDT_INT Mask            */
N
N#define INT_IRQ2_SRC_EINT0_Pos                  (0)                                               /*!< INT_T::IRQ2_SRC: EINT0 Position           */
N#define INT_IRQ2_SRC_EINT0_Msk                  (0x1ul << INT_IRQ2_SRC_EINT0_Pos)                 /*!< INT_T::IRQ2_SRC: EINT0 Mask               */
N
N#define INT_IRQ3_SRC_EINT1_Pos                  (0)                                               /*!< INT_T::IRQ3_SRC: EINT1 Position           */
N#define INT_IRQ3_SRC_EINT1_Msk                  (0x1ul << INT_IRQ_SRC3_EINT1_Pos)                 /*!< INT_T::IRQ3_SRC: EINT1 Mask               */
N
N#define INT_IRQ4_SRC_GP0_INT_Pos                (0)                                               /*!< INT_T::IRQ4_SRC: GP0_INT Position         */
N#define INT_IRQ4_SRC_GP0_INT_Msk                (0x1ul << INT_IRQ4_SRC_GP0_INT_Pos)               /*!< INT_T::IRQ4_SRC: GP0_INT Mask             */
N
N#define INT_IRQ4_SRC_GP1_INT_Pos                (1)                                               /*!< INT_T::IRQ4_SRC: GP1_INT Position         */
N#define INT_IRQ4_SRC_GP1_INT_Msk                (0x1ul << INT_IRQ4_SRC_GP1_INT_Pos)               /*!< INT_T::IRQ4_SRC: GP1_INT Mask             */
N
N#define INT_IRQ5_SRC_GP2_INT_Pos                (0)                                               /*!< INT_T::IRQ5_SRC: GP2_INT Position         */
N#define INT_IRQ5_SRC_GP2_INT_Msk                (0x1ul << INT_IRQ5_SRC_GP2_INT_Pos)               /*!< INT_T::IRQ5_SRC: GP2_INT Mask             */
N
N#define INT_IRQ5_SRC_GP3_INT_Pos                (1)                                               /*!< INT_T::IRQ5_SRC: GP3_INT Position         */
N#define INT_IRQ5_SRC_GP3_INT_Msk                (0x1ul << INT_IRQ5_SRC_GP3_INT_Pos)               /*!< INT_T::IRQ5_SRC: GP3_INT Mask             */
N
N#define INT_IRQ5_SRC_GP4_INT_Pos                (2)                                               /*!< INT_T::IRQ5_SRC: GP4_INT Position         */
N#define INT_IRQ5_SRC_GP4_INT_Msk                (0x1ul << INT_IRQ5_SRC_GP4_INT_Pos)               /*!< INT_T::IRQ5_SRC: GP4_INT Mask             */
N
N#define INT_IRQ6_SRC_PWM_INT_Pos                (0)                                               /*!< INT_T::IRQ6_SRC: PWM_INT Position         */
N#define INT_IRQ6_SRC_PWM_INT_Msk                (0x1ul << INT_IRQ6_SRC_PWM_INT_Pos)               /*!< INT_T::IRQ6_SRC: PWM_INT Mask             */
N
N#define INT_IRQ7_SRC_BRAKE_INT_Pos              (0)                                               /*!< INT_T::IRQ7_SRC: BRAKE_INT Position       */
N#define INT_IRQ7_SRC_BRAKE_INT_Msk              (0x1ul << INT_IRQ_SRC_BRAKE_INT_Pos)              /*!< INT_T::IRQ7_SRC: BRAKE_INT Mask           */
N
N#define INT_IRQ8_SRC_TMR0_INT_Pos               (0)                                               /*!< INT_T::IRQ8_SRC: TMR0_INT Position        */
N#define INT_IRQ8_SRC_TMR0_INT_Msk               (0x1ul << INT_IRQ8_SRC_TMR0_INT_Pos)              /*!< INT_T::IRQ8_SRC: TMR0_INT Mask            */
N
N#define INT_IRQ9_SRC_TMR1_INT_Pos               (0)                                               /*!< INT_T::IRQ9_SRC: TMR1_INT Position        */
N#define INT_IRQ9_SRC_TMR1_INT_Msk               (0x1ul << INT_IRQ9_SRC_TMR1_INT_Pos)              /*!< INT_T::IRQ9_SRC: TMR1_INT Mask            */
N
N#define INT_IRQ12_SRC_UART0_INT_Pos             (0)                                               /*!< INT_T::IRQ12_SRC: UART0_INT Position      */
N#define INT_IRQ12_SRC_UART0_INT_Msk             (0x1ul << INT_IRQ12_SRC_UART0_INT_Pos)            /*!< INT_T::IRQ12_SRC: UART0_INT Mask          */
N
N#define INT_IRQ13_SRC_UART1_INT_Pos             (0)                                               /*!< INT_T::IRQ13_SRC: UART1_INT Position      */
N#define INT_IRQ13_SRC_UART1_INT_Msk             (0x1ul << INT_IRQ13_SRC_UART1_INT_Pos)            /*!< INT_T::IRQ13_SRC: UART1_INT Mask          */
N
N#define INT_IRQ14_SRC_SPI_INT_Pos               (0)                                               /*!< INT_T::IRQ14_SRC: SPI_INT Position        */
N#define INT_IRQ14_SRC_SPI_INT_Msk               (0x1ul << INT_IRQ14_SRC_SPI_INT_Pos)              /*!< INT_T::IRQ14_SRC: SPI_INT Mask            */
N
N#define INT_IRQ16_SRC_GP5_INT_Pos               (0)                                               /*!< INT_T::IRQ16_SRC: GP5_INT Position        */
N#define INT_IRQ16_SRC_GP5_INT_Msk               (0x1ul << INT_IRQ16_SRC_GP5_INT_Pos)              /*!< INT_T::IRQ16_SRC: GP5_INT Mask            */
N
N#define INT_IRQ17_SRC_HIRC_TRIM_INT_Pos         (0)                                               /*!< INT_T::IRQ17_SRC: HIRC_TRIM_INT Position  */
N#define INT_IRQ17_SRC_HIRC_TRIM_INT_Msk         (0x1ul << INT_IRQ17_SRC_HIRC_TRIM_INT_Pos)        /*!< INT_T::IRQ17_SRC: HIRC_TRIM_INT Mask      */
N
N#define INT_IRQ18_SRC_I2C0_INT_Pos              (0)                                               /*!< INT_T::IRQ18_SRC: I2C0_INT Position       */
N#define INT_IRQ18_SRC_I2C0_INT_Msk              (0x1ul << INT_IRQ18_SRC_I2C0_INT_Pos)             /*!< INT_T::IRQ18_SRC: I2C0_INT Mask           */
N
N#define INT_IRQ19_SRC_I2C1_INT_Pos              (0)                                               /*!< INT_T::IRQ19_SRC: I2C1_INT Position       */
N#define INT_IRQ19_SRC_I2C1_INT_Msk              (0x1ul << INT_IRQ19_SRC_I2C1_INT_Pos)             /*!< INT_T::IRQ19_SRC: I2C1_INT Mask           */
N
N#define INT_IRQ25_SRC_ACMP_INT_Pos              (0)                                               /*!< INT_T::IRQ25_SRC: ACMP_INT Position       */
N#define INT_IRQ25_SRC_ACMP_INT_Msk              (0x1ul << INT_IRQ25_SRC_ACMP_INT_Pos)             /*!< INT_T::IRQ25_SRC: ACMP_INT Mask           */
N
N#define INT_IRQ28_SRC_PWRWU_INT_Pos             (0)                                               /*!< INT_T::IRQ28_SRC: PWRWU_INT Position      */
N#define INT_IRQ28_SRC_PWRWU_INT_Msk             (0x1ul << INT_IRQ28_SRC_PWRWU_INT_Pos)            /*!< INT_T::IRQ28_SRC: PWRWU_INT Mask          */
N
N#define INT_IRQ29_SRC_ADC_INT_Pos               (0)                                               /*!< INT_T::IRQ29_SRC: ADC_INT Position        */
N#define INT_IRQ29_SRC_ADC_INT_Msk               (0x1ul << INT_IRQ29_SRC_ADC_INT_Pos)              /*!< INT_T::IRQ29_SRC: ADC_INT Mask            */
N
N#define INT_CON_NMI_SEL_Pos                     (0)                                               /*!< INT_T::CON: NMI_SEL Position              */
N#define INT_CON_NMI_SEL_Msk                     (0x1ful << INT_CON_NMI_SEL_Pos)                   /*!< INT_T::CON: NMI_SEL Mask                  */
N
N#define INT_CON_NMI_SEL_EN_Pos                  (8)                                               /*!< INT_T::CON: NMI_SEL_EN Position           */
N#define INT_CON_NMI_SEL_EN_Msk                  (0x1ul << INT_CON_NMI_SEL_EN_Pos)                 /*!< INT_T::CON: NMI_SEL_EN Mask               */
N
N#define INT_IRQ_MCU_IRQ_Pos                     (0)                                               /*!< INT_T::IRQ: MCU_IRQ Position              */
N#define INT_IRQ_MCU_IRQ_Msk                     (0xfffffffful << INT_IRQ_MCU_IRQ_Pos)             /*!< INT_T::IRQ: MCU_IRQ Mask                  */
N
N/**@}*/ /* INT_CONST */
N/**@}*/ /* end of INT register group */
N
N
N/*---------------------- Pulse Width Modulation Controller -------------------------*/
N/**
N    @addtogroup PWM Pulse Width Modulation Controller(PWM)
N    Memory Mapped Structure for PWM Controller
N@{ */
N
Ntypedef struct {
N
N
N    /**
N     * CLKPSC
N     * ===================================================================================================
N     * Offset: 0x00  PWM Clock Pre-scale Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |CLKPSC01  |Clock Prescaler 0 For PWM Counter 0 And 1
N     * |        |          |Clock input is divided by (CLKPSC01 + 1) before it is fed to the corresponding PWM counter.
N     * |        |          |If CLKPSC01 = 0, the clock prescaler 0 output clock will be stopped.
N     * |        |          |So the corresponding PWM counter will also be stopped.
N     * |[15:8]  |CLKPSC23  |Clock Prescaler 2 For PWM Counter 2 And 3
N     * |        |          |Clock input is divided by (CLKPSC23 + 1) before it is fed to the corresponding PWM counter.
N     * |        |          |If CLKPSC23 = 0, the clock prescaler 2 output clock will be stopped.
N     * |        |          |So the corresponding PWM counter will also be stopped.
N     * |[23:16] |CLKPSC45  |Clock Prescaler 4 For PWM Counter 4 And 5
N     * |        |          |Clock input is divided by (CLKPSC45 + 1) before it is fed to the corresponding PWM counter.
N     * |        |          |If CLKPSC45 = 0, the clock prescaler 4 output clock will be stopped.
N     * |        |          |So the corresponding PWM counter will also be stopped.
N    */
N    __IO uint32_t CLKPSC;
X    volatile uint32_t CLKPSC;
N
N    /**
N     * CLKDIV
N     * ===================================================================================================
N     * Offset: 0x04  PWM Clock Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |CLKDIV0   |Counter 0 Clock Divider Selection
N     * |        |          |Select clock input for PWM counter.
N     * |        |          |000 = Clock input / (CLKPSC01/2).
N     * |        |          |001 = Clock input / (CLKPSC01/4).
N     * |        |          |010 = Clock input / (CLKPSC01/8).
N     * |        |          |011 = Clock input / (CLKPSC01/16).
N     * |        |          |100 = Clock input / CLKPSC01.
N     * |        |          |Others = Clock input.
N     * |[6:4]   |CLKDIV1   |Counter 1 Clock Divider Selection
N     * |        |          |Select clock input for PWM counter.
N     * |        |          |000 = Clock input / (CLKPSC01/2).
N     * |        |          |001 = Clock input / (CLKPSC01/4).
N     * |        |          |010 = Clock input / (CLKPSC01/8).
N     * |        |          |011 = Clock input / (CLKPSC01/16).
N     * |        |          |100 = Clock input / CLKPSC01.
N     * |        |          |Others = Clock input.
N     * |[10:8]  |CLKDIV2   |Counter 2 Clock Divider Selection
N     * |        |          |Select clock input for PWM counter.
N     * |        |          |000 = Clock input / (CLKPSC23/2).
N     * |        |          |001 = Clock input / (CLKPSC23/4).
N     * |        |          |010 = Clock input / (CLKPSC23/8).
N     * |        |          |011 = Clock input / (CLKPSC23/16).
N     * |        |          |100 = Clock input / CLKPSC23.
N     * |        |          |Others = Clock input.
N     * |[14:12] |CLKDIV3   |Counter 3 Clock Divider Selection
N     * |        |          |Select clock input for PWM counter.
N     * |        |          |000 = Clock input / (CLKPSC23/2).
N     * |        |          |001 = Clock input / (CLKPSC23/4).
N     * |        |          |010 = Clock input / (CLKPSC23/8).
N     * |        |          |011 = Clock input / (CLKPSC23/16).
N     * |        |          |100 = Clock input / CLKPSC23.
N     * |        |          |Others = Clock input.
N     * |[18:16] |CLKDIV4   |Counter 4 Clock Divider Selection
N     * |        |          |Select clock input for PWM counter.
N     * |        |          |000 = Clock input / (CLKPSC45/2).
N     * |        |          |001 = Clock input / (CLKPSC45/4).
N     * |        |          |010 = Clock input / (CLKPSC45/8).
N     * |        |          |011 = Clock input / (CLKPSC45/16).
N     * |        |          |100 = Clock input / CLKPSC45.
N     * |        |          |Others = Clock input.
N     * |[22:20] |CLKDIV5   |Counter 5 Clock Divider Selection
N     * |        |          |Select clock input for PWM counter.
N     * |        |          |000 = Clock input / (CLKPSC45/2).
N     * |        |          |001 = Clock input / (CLKPSC45/4).
N     * |        |          |010 = Clock input / (CLKPSC45/8).
N     * |        |          |011 = Clock input / (CLKPSC45/16).
N     * |        |          |100 = Clock input / CLKPSC45.
N     * |        |          |Others = Clock input.
N    */
N    __IO uint32_t CLKDIV;
X    volatile uint32_t CLKDIV;
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x08  PWM Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CNTEN0    |PWM Counter 0 Enable Start Run
N     * |        |          |0 = Corresponding PWM counter running Stopped.
N     * |        |          |1 = Corresponding PWM counter start run Enabled.
N     * |[1]     |DBGTRIOFF |Disable PWM Output Tri-state Under Debug Mode (Available In DEBUG Mode Only)
N     * |        |          |0 = Safe mode: The counter is frozen and PWM outputs are shut down Safe state for the inverter.
N     * |        |          |The counter can still be re-started from where it stop.
N     * |        |          |1 = Normal mode: The counter continues to operate normally May be dangerous in some cases since a constant duty cycle is applied to the inverter (no more interrupts serviced).
N     * |[2]     |PINV0     |PWM0_CH0 Output Inverter Enable Bit
N     * |        |          |0 = PWM0_CH0 output inverter Disabled.
N     * |        |          |1 = PWM0_CH0 output inverter Enabled.
N     * |[3]     |CNTMODE0  |PWM Counter 0 Auto-reload/One-shot Mode
N     * |        |          |0 = One-shot mode.
N     * |        |          |1 = Auto-reload mode.
N     * |        |          |Note: If there is a rising transition at this bit, it will cause PERIOD0 and CMP0 cleared.
N     * |[4]     |CNTEN1    |PWM Counter 1 Enable/Disable Start Run
N     * |        |          |0 = Corresponding PWM counter running Stopped.
N     * |        |          |1 = Corresponding PWM counter start run Enabled.
N     * |[5]     |HCUPDT    |Half Cycle Update Enable for Center-aligned Type
N     * |        |          |0 = Disable half cycle update PERIOD & CMP.
N     * |        |          |1 = Enable half cycle update PERIOD & CMP.
N     * |[6]     |PINV1     |PWM0_CH1 Output Inverter Enable Bit
N     * |        |          |0 = PWM0_CH1 output inverter Disable.
N     * |        |          |1 = PWM0_CH1 output inverter Enable.
N     * |[7]     |CNTMODE1  |PWM Counter 1 Auto-reload/One-shot Mode
N     * |        |          |0 = One-shot mode.
N     * |        |          |1 = Auto-reload mode.
N     * |        |          |Note: If there is a rising transition at this bit, it will cause PERIOD1 and CMP1 cleared.
N     * |[8]     |CNTEN2    |PWM Counter 2 Enable Start Run
N     * |        |          |0 = Corresponding PWM counter running Stopped.
N     * |        |          |1 = Corresponding PWM counter start run Enabled.
N     * |[10]    |PINV2     |PWM0_CH2 Output Inverter Enable Bit
N     * |        |          |0 = PWM0_CH2 output inverter Disabled.
N     * |        |          |1 = PWM0_CH2 output inverter Enabled.
N     * |[11]    |CNTMODE2  |PWM Counter 2 Auto-reload/One-shot Mode
N     * |        |          |0 = One-shot mode.
N     * |        |          |1 = Auto-reload mode.
N     * |        |          |Note: If there is a rising transition at this bit, it will cause PERIOD2 and CMP2 cleared.
N     * |[12]    |CNTEN3    |PWM Counter 3 Enable Start Run
N     * |        |          |0 = Corresponding PWM counter running Stopped.
N     * |        |          |1 = Corresponding PWM counter start run Enabled.
N     * |[14]    |PINV3     |PWM0_CH 3 Output Inverter Enable Bit
N     * |        |          |0 = PWM0_CH3 output inverter Disabled.
N     * |        |          |1 = PWM0_CH3 output inverter Enabled.
N     * |[15]    |CNTMODE3  |PWM Counter 3 Auto-reload/One-shot Mode
N     * |        |          |0 = One-shot mode.
N     * |        |          |1 = Auto-reload mode.
N     * |        |          |Note: If there is a rising transition at this bit, it will cause PERIOD3 and CMP3 cleared.
N     * |[16]    |CNTEN4    |PWM Counter 4 Enable Start Run
N     * |        |          |0 = Corresponding PWM counter running Stopped.
N     * |        |          |1 = Corresponding PWM counter start run Enabled.
N     * |[18]    |PINV4     |PWM0_CH4 Output Inverter Enable Bit
N     * |        |          |0 = PWM0_CH4 output inverter Disabled.
N     * |        |          |1 = PWM0_CH4 output inverter Enabled.
N     * |[19]    |CNTMODE4  |PWM Counter 4 Auto-reload/One-shot Mode
N     * |        |          |0 = One-shot mode.
N     * |        |          |1 = Auto-reload mode.
N     * |        |          |Note: If there is a rising transition at this bit, it will cause PERIOD4 and CMP4 cleared.
N     * |[20]    |CNTEN5    |PWM Counter 5 Enable Start Run
N     * |        |          |0 = Corresponding PWM counter running Stopped.
N     * |        |          |1 = Corresponding PWM counter start run Enabled.
N     * |[21]    |ASYMEN    |Asymmetric Mode In Center-aligned Type
N     * |        |          |0 = Symmetric mode in center-aligned type.
N     * |        |          |1 = Asymmetric mode in center-aligned type.
N     * |[22]    |PINV5     |PWM0_CH5 Output Inverter Enable Bit
N     * |        |          |0 = PWM0_CH5 output inverter Disabled.
N     * |        |          |1 = PWM0_CH5 output inverter Enabled.
N     * |[23]    |CNTMODE5  |PWM Counter 5 Auto-reload/One-shot Mode
N     * |        |          |0 = One-shot mode.
N     * |        |          |1 = Auto-reload mode.
N     * |        |          |Note: If there is a rising transition at this bit, it will cause PERIOD5 and CMP5 cleared.
N     * |[24]    |DTCNT01   |Dead-time 0 Counter Enable Bit (PWM0_CH0 And PWM0_CH1 Pair For PWMA Group)
N     * |        |          |0 = Dead-time 0 generator Disabled.
N     * |        |          |1 = Dead-time 0 generator Enabled.
N     * |        |          |Note: When the dead-time generator is enabled, the pair of PWM0_CH0 and PWM0_CH1 becomes a complementary pair for PWMA group.
N     * |[25]    |DTCNT23   |Dead-time 2 Counter Enable Bit (PWM0_CH2 And PWM0_CH3 Pair For PWMB Group)
N     * |        |          |0 = Dead-time 2 generator Disabled.
N     * |        |          |1 = Dead-time 2 generator Enabled.
N     * |        |          |Note: When the dead-time generator is enabled, the pair of PWM0_CH2 and PWM0_CH3 becomes a complementary pair for PWMB group.
N     * |[26]    |DTCNT45   |Dead-time 4 Counter Enable Bit (PWM0_CH4 And PWM0_CH5 Pair For PWMC Group)
N     * |        |          |0 = Dead-time 4 generator Disabled.
N     * |        |          |1 = Dead-time 4 generator Enabled.
N     * |        |          |Note: When the dead-time generator is enabled, the pair of PWM0_CH4 and PWM0_CH5 becomes a complementary pair for PWMC group.
N     * |[27]    |CNTCLR    |Clear PWM Counter Control Bit
N     * |        |          |0 = Do not clear PWM counter.
N     * |        |          |1 = All 16-bit PWM counters cleared to 0x0000.
N     * |        |          |Note: It is automatically cleared by hardware.
N     * |[29:28] |MODE      |PWM Operating Mode Select Bit
N     * |        |          |00 = Independent mode.
N     * |        |          |01 = Complementary mode.
N     * |        |          |10 = Synchronized mode.
N     * |        |          |11 = Reserved.
N     * |[30]    |GROUPEN   |Group Function Enable Bit
N     * |        |          |0 = The signals timing of all PWM channels are independent.
N     * |        |          |1 = Unify the signals timing of PWM0_CH0, PWM0_CH2 and PWM0_CH4 in the same phase which is controlled by PWM0_CH0 and also unify the signals timing of PWM0_CH1, PWM0_CH3 and PWM0_CH5 in the same phase which is controlled by PWM0_CH1.
N     * |[31]    |CNTTYPE   |PWM Counter-aligned Type Select Bit
N     * |        |          |0 = Edge-aligned type.
N     * |        |          |1 = Center-aligned type.
N    */
N    __IO uint32_t CTL;
X    volatile uint32_t CTL;
N
N    /**
N     * PERIOD0
N     * ===================================================================================================
N     * Offset: 0x0C  PWM Counter Period Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PERIOD0   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD1   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD2   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD3   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD4   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD5   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N    */
N    __IO uint32_t PERIOD0;
X    volatile uint32_t PERIOD0;
N
N    /**
N     * PERIOD1
N     * ===================================================================================================
N     * Offset: 0x10  PWM Counter Period Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PERIOD0   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD1   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD2   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD3   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD4   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD5   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N    */
N    __IO uint32_t PERIOD1;
X    volatile uint32_t PERIOD1;
N
N    /**
N     * PERIOD2
N     * ===================================================================================================
N     * Offset: 0x14  PWM Counter Period Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PERIOD0   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD1   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD2   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD3   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD4   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD5   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N    */
N    __IO uint32_t PERIOD2;
X    volatile uint32_t PERIOD2;
N
N    /**
N     * PERIOD3
N     * ===================================================================================================
N     * Offset: 0x18  PWM Counter Period Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PERIOD0   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD1   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD2   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD3   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD4   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD5   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N    */
N    __IO uint32_t PERIOD3;
X    volatile uint32_t PERIOD3;
N
N    /**
N     * PERIOD4
N     * ===================================================================================================
N     * Offset: 0x1C  PWM Counter Period Register 4
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PERIOD0   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD1   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD2   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD3   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD4   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD5   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N    */
N    __IO uint32_t PERIOD4;
X    volatile uint32_t PERIOD4;
N
N    /**
N     * PERIOD5
N     * ===================================================================================================
N     * Offset: 0x20  PWM Counter Period Register 5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PERIOD0   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD1   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD2   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD3   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD4   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N     * |[15:0]  |PERIOD5   |PWM Counter Period Value
N     * |        |          |PERIODn determines the PWM counter period.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/( PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*PERIODn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/( PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to PERIODn will take effect in the next PWM cycle.
N    */
N    __IO uint32_t PERIOD5;
X    volatile uint32_t PERIOD5;
N
N    /**
N     * CMPDAT0
N     * ===================================================================================================
N     * Offset: 0x24  PWM Comparator Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMP0      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP1      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP2      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP3      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP4      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP5      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[31:16] |CMPD0     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD1     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD2     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD3     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD4     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD5     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N    */
N    __IO uint32_t CMPDAT0;
X    volatile uint32_t CMPDAT0;
N
N    /**
N     * CMPDAT1
N     * ===================================================================================================
N     * Offset: 0x28  PWM Comparator Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMP0      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP1      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP2      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP3      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP4      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP5      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[31:16] |CMPD0     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD1     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD2     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD3     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD4     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD5     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N    */
N    __IO uint32_t CMPDAT1;
X    volatile uint32_t CMPDAT1;
N
N    /**
N     * CMPDAT2
N     * ===================================================================================================
N     * Offset: 0x2C  PWM Comparator Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMP0      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP1      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP2      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP3      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP4      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP5      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[31:16] |CMPD0     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD1     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD2     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD3     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD4     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD5     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N    */
N    __IO uint32_t CMPDAT2;
X    volatile uint32_t CMPDAT2;
N
N    /**
N     * CMPDAT3
N     * ===================================================================================================
N     * Offset: 0x30  PWM Comparator Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMP0      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP1      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP2      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP3      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP4      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP5      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[31:16] |CMPD0     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD1     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD2     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD3     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD4     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD5     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N    */
N    __IO uint32_t CMPDAT3;
X    volatile uint32_t CMPDAT3;
N
N    /**
N     * CMPDAT4
N     * ===================================================================================================
N     * Offset: 0x34  PWM Comparator Register 4
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMP0      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP1      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP2      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP3      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP4      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP5      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[31:16] |CMPD0     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD1     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD2     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD3     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD4     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD5     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N    */
N    __IO uint32_t CMPDAT4;
X    volatile uint32_t CMPDAT4;
N
N    /**
N     * CMPDAT5
N     * ===================================================================================================
N     * Offset: 0x38  PWM Comparator Register 5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMP0      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP1      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP2      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP3      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP4      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[15:0]  |CMP5      |PWM Comparator Register
N     * |        |          |CMP determines the PWM duty.
N     * |        |          |Edge-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider))/( PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMPn+1)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always high.
N     * |        |          |CMPn < PERIODn: PWM low width = (PERIODn-CMPn) unit; PWM high width = (CMP+1) unit.
N     * |        |          |CMPn = 0: PWM low width = (PERIODn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned type:
N     * |        |          |PWM frequency = HCLK/((CLKPSCnm+1)*(clock divider)) /(2*PERIODn+1); where nm, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (PERIODn - CMPn)/(PERIODn+1).
N     * |        |          |CMPn >= PERIODn: PWM output is always low.
N     * |        |          |CMPn < PERIODn: PWM low width = (CMPn + 1) * 2 unit; PWM high width = (PERIODn - CMPn) * 2 unit.
N     * |        |          |CMPn = 0: PWM low width = 2 unit; PWM high width = (PERIODn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMPn will take effect in the next PWM cycle.
N     * |[31:16] |CMPD0     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD1     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD2     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD3     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD4     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N     * |[31:16] |CMPD5     |PWM Comparator Register For Down Counter In Asymmetric Mode
N     * |        |          |CMPn >= PERIODn: up counter PWM output is always low.
N     * |        |          |CMPDn >= PERIODn: down counter PWM output is always low.
N     * |        |          |Others: PWM output is always high.
N    */
N    __IO uint32_t CMPDAT5;
X    volatile uint32_t CMPDAT5;
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVED0[6];
X    volatile const  uint32_t RESERVED0[6];
N    /// @endcond //HIDDEN_SYMBOLS
N
N
N    /**
N     * INTEN
N     * ===================================================================================================
N     * Offset: 0x54  PWM Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |ZIEN0     |PWM Zero Point Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn zero point interrupt Disabled.
N     * |        |          |1 = PWM0_CHn zero point interrupt Enabled.
N     * |[5:0]   |ZIEN1     |PWM Zero Point Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn zero point interrupt Disabled.
N     * |        |          |1 = PWM0_CHn zero point interrupt Enabled.
N     * |[5:0]   |ZIEN2     |PWM Zero Point Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn zero point interrupt Disabled.
N     * |        |          |1 = PWM0_CHn zero point interrupt Enabled.
N     * |[5:0]   |ZIEN3     |PWM Zero Point Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn zero point interrupt Disabled.
N     * |        |          |1 = PWM0_CHn zero point interrupt Enabled.
N     * |[5:0]   |ZIEN4     |PWM Zero Point Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn zero point interrupt Disabled.
N     * |        |          |1 = PWM0_CHn zero point interrupt Enabled.
N     * |[5:0]   |ZIEN5     |PWM Zero Point Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn zero point interrupt Disabled.
N     * |        |          |1 = PWM0_CHn zero point interrupt Enabled.
N     * |[13:8]  |CMPDIEN0  |PWM Compare Down Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn compare down interrupt Disabled.
N     * |        |          |1 = PWM0_CHn compare down interrupt Enabled.
N     * |[13:8]  |CMPDIEN1  |PWM Compare Down Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn compare down interrupt Disabled.
N     * |        |          |1 = PWM0_CHn compare down interrupt Enabled.
N     * |[13:8]  |CMPDIEN2  |PWM Compare Down Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn compare down interrupt Disabled.
N     * |        |          |1 = PWM0_CHn compare down interrupt Enabled.
N     * |[13:8]  |CMPDIEN3  |PWM Compare Down Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn compare down interrupt Disabled.
N     * |        |          |1 = PWM0_CHn compare down interrupt Enabled.
N     * |[13:8]  |CMPDIEN4  |PWM Compare Down Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn compare down interrupt Disabled.
N     * |        |          |1 = PWM0_CHn compare down interrupt Enabled.
N     * |[13:8]  |CMPDIEN5  |PWM Compare Down Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn compare down interrupt Disabled.
N     * |        |          |1 = PWM0_CHn compare down interrupt Enabled.
N     * |[16]    |BRKIEN    |Fault Brake0 And Fault Brake1 Interrupt Enable Bit
N     * |        |          |0 = BRKIF0 and BRKIF1 trigger PWM interrupt Disabled.
N     * |        |          |1 = BRKIF0 and BRKIF1 trigger PWM interrupt Enabled.
N     * |[17]    |PINTTYPE  |PWM Interrupt Type Selection
N     * |        |          |0 = ZIFn will be set if PWM counter underflows.
N     * |        |          |1 = ZIFn will be set if PWM counter matches PERIODn register.
N     * |        |          |Note: This bit is effective when PWM is in center-aligned type only.
N     * |[23:18] |PIEN0     |PWM Period Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn period interrupt Disabled.
N     * |        |          |1 = PWM0_CHn period interrupt Enabled.
N     * |[23:18] |PIEN1     |PWM Period Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn period interrupt Disabled.
N     * |        |          |1 = PWM0_CHn period interrupt Enabled.
N     * |[23:18] |PIEN2     |PWM Period Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn period interrupt Disabled.
N     * |        |          |1 = PWM0_CHn period interrupt Enabled.
N     * |[23:18] |PIEN3     |PWM Period Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn period interrupt Disabled.
N     * |        |          |1 = PWM0_CHn period interrupt Enabled.
N     * |[23:18] |PIEN4     |PWM Period Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn period interrupt Disabled.
N     * |        |          |1 = PWM0_CHn period interrupt Enabled.
N     * |[23:18] |PIEN5     |PWM Period Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn period interrupt Disabled.
N     * |        |          |1 = PWM0_CHn period interrupt Enabled.
N     * |[29:24] |CMPUIEN0  |PWM Compare Up Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn compare up interrupt Disabled.
N     * |        |          |1 = PWM0_CHn compare up interrupt Enabled.
N     * |[29:24] |CMPUIEN1  |PWM Compare Up Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn compare up interrupt Disabled.
N     * |        |          |1 = PWM0_CHn compare up interrupt Enabled.
N     * |[29:24] |CMPUIEN2  |PWM Compare Up Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn compare up interrupt Disabled.
N     * |        |          |1 = PWM0_CHn compare up interrupt Enabled.
N     * |[29:24] |CMPUIEN3  |PWM Compare Up Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn compare up interrupt Disabled.
N     * |        |          |1 = PWM0_CHn compare up interrupt Enabled.
N     * |[29:24] |CMPUIEN4  |PWM Compare Up Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn compare up interrupt Disabled.
N     * |        |          |1 = PWM0_CHn compare up interrupt Enabled.
N     * |[29:24] |CMPUIEN5  |PWM Compare Up Interrupt Enable Bit
N     * |        |          |0 = PWM0_CHn compare up interrupt Disabled.
N     * |        |          |1 = PWM0_CHn compare up interrupt Enabled.
N    */
N    __IO uint32_t INTEN;
X    volatile uint32_t INTEN;
N
N    /**
N     * INTSTS
N     * ===================================================================================================
N     * Offset: 0x58  PWM Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |ZIF0      |PWM Zero Point Interrupt Flag
N     * |        |          |Flag is set by hardware when PWMn counter down count reaches zero point.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[5:0]   |ZIF1      |PWM Zero Point Interrupt Flag
N     * |        |          |Flag is set by hardware when PWMn counter down count reaches zero point.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[5:0]   |ZIF2      |PWM Zero Point Interrupt Flag
N     * |        |          |Flag is set by hardware when PWMn counter down count reaches zero point.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[5:0]   |ZIF3      |PWM Zero Point Interrupt Flag
N     * |        |          |Flag is set by hardware when PWMn counter down count reaches zero point.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[5:0]   |ZIF4      |PWM Zero Point Interrupt Flag
N     * |        |          |Flag is set by hardware when PWMn counter down count reaches zero point.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[5:0]   |ZIF5      |PWM Zero Point Interrupt Flag
N     * |        |          |Flag is set by hardware when PWMn counter down count reaches zero point.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[13:8]  |CMPDIF0   |PWM Compare Down Interrupt Flag
N     * |        |          |Flag is set by hardware when PWMn counter down count reaches CMPn.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[13:8]  |CMPDIF1   |PWM Compare Down Interrupt Flag
N     * |        |          |Flag is set by hardware when PWMn counter down count reaches CMPn.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[13:8]  |CMPDIF2   |PWM Compare Down Interrupt Flag
N     * |        |          |Flag is set by hardware when PWMn counter down count reaches CMPn.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[13:8]  |CMPDIF3   |PWM Compare Down Interrupt Flag
N     * |        |          |Flag is set by hardware when PWMn counter down count reaches CMPn.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[13:8]  |CMPDIF4   |PWM Compare Down Interrupt Flag
N     * |        |          |Flag is set by hardware when PWMn counter down count reaches CMPn.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[13:8]  |CMPDIF5   |PWM Compare Down Interrupt Flag
N     * |        |          |Flag is set by hardware when PWMn counter down count reaches CMPn.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[16]    |BRKIF0    |PWM Brake0 Flag
N     * |        |          |0 = PWM Brake does not recognize a falling signal at BKP0.
N     * |        |          |1 = When PWM Brake detects a falling signal at pin BKP0; this flag will be set to high.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[17]    |BRKIF1    |PWM Brake1 Flag
N     * |        |          |0 = PWM Brake does not recognize a falling signal at BKP1.
N     * |        |          |1 = When PWM Brake detects a falling signal at pin BKP1; this flag will be set to high.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[23:18] |PIF0      |PWM Period Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM0_CHn counter reaches PERIODn.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[23:18] |PIF1      |PWM Period Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM0_CHn counter reaches PERIODn.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[23:18] |PIF2      |PWM Period Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM0_CHn counter reaches PERIODn.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[23:18] |PIF3      |PWM Period Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM0_CHn counter reaches PERIODn.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[23:18] |PIF4      |PWM Period Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM0_CHn counter reaches PERIODn.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[23:18] |PIF5      |PWM Period Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM0_CHn counter reaches PERIODn.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[29:24] |CMPUIF0   |PWM Compare Up Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM0_CHn counter up count reaches CMPn.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[29:24] |CMPUIF1   |PWM Compare Up Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM0_CHn counter up count reaches CMPn.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[29:24] |CMPUIF2   |PWM Compare Up Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM0_CHn counter up count reaches CMPn.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[29:24] |CMPUIF3   |PWM Compare Up Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM0_CHn counter up count reaches CMPn.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[29:24] |CMPUIF4   |PWM Compare Up Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM0_CHn counter up count reaches CMPn.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[29:24] |CMPUIF5   |PWM Compare Up Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM0_CHn counter up count reaches CMPn.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N    */
N    __IO uint32_t INTSTS;
X    volatile uint32_t INTSTS;
N
N    /**
N     * POEN
N     * ===================================================================================================
N     * Offset: 0x5C  PWM Output Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |POEN0     |PWM Output Enable Bits
N     * |        |          |0 = PWM channel n output to pin Disabled.
N     * |        |          |1 = PWM channel n output to pin Enabled.
N     * |        |          |Note: The corresponding GPIO pin must be switched to PWM function.
N     * |[5:0]   |POEN1     |PWM Output Enable Bits
N     * |        |          |0 = PWM channel n output to pin Disabled.
N     * |        |          |1 = PWM channel n output to pin Enabled.
N     * |        |          |Note: The corresponding GPIO pin must be switched to PWM function.
N     * |[5:0]   |POEN2     |PWM Output Enable Bits
N     * |        |          |0 = PWM channel n output to pin Disabled.
N     * |        |          |1 = PWM channel n output to pin Enabled.
N     * |        |          |Note: The corresponding GPIO pin must be switched to PWM function.
N     * |[5:0]   |POEN3     |PWM Output Enable Bits
N     * |        |          |0 = PWM channel n output to pin Disabled.
N     * |        |          |1 = PWM channel n output to pin Enabled.
N     * |        |          |Note: The corresponding GPIO pin must be switched to PWM function.
N     * |[5:0]   |POEN4     |PWM Output Enable Bits
N     * |        |          |0 = PWM channel n output to pin Disabled.
N     * |        |          |1 = PWM channel n output to pin Enabled.
N     * |        |          |Note: The corresponding GPIO pin must be switched to PWM function.
N     * |[5:0]   |POEN5     |PWM Output Enable Bits
N     * |        |          |0 = PWM channel n output to pin Disabled.
N     * |        |          |1 = PWM channel n output to pin Enabled.
N     * |        |          |Note: The corresponding GPIO pin must be switched to PWM function.
N    */
N    __IO uint32_t POEN;
X    volatile uint32_t POEN;
N
N    /**
N     * BRKCTL
N     * ===================================================================================================
N     * Offset: 0x60  PWM Fault Brake Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BRK0EN    |Enable BKP0 Pin Trigger Fault Brake Function 0
N     * |        |          |0 = Disabling BKP0 pin can trigger brake function 0 (EINT0 or CPO1).
N     * |        |          |1 = Enabling a falling at BKP0 pin can trigger brake function 0.
N     * |[1]     |BRK1EN    |Enable BKP1 Pin Trigger Fault Brake Function 1
N     * |        |          |0 = Disabling BKP1 pin can trigger brake function 1 (EINT1 or CPO0).
N     * |        |          |1 = Enabling a falling at BKP1 pin can trigger brake function 1.
N     * |[2]     |BRK0SEL   |BKP1 Fault Brake Function Source Select Bit
N     * |        |          |0 = EINT1 as one brake source in BKP1.
N     * |        |          |1 = CPO0 as one brake source in BKP1.
N     * |[3]     |BRK1SEL   |BKP0 Fault Brake Function Source Select Bit
N     * |        |          |0 = EINT0 as one brake source in BKP0.
N     * |        |          |1 = CPO1 as one brake source in BKP0.
N     * |[7]     |BRKSTS    |PWM Fault Brake Event Status Flag
N     * |        |          |0 = PWM output initial state when fault brake conditions asserted.
N     * |        |          |1 = PWM output fault brake state when fault brake conditions asserted.
N     * |        |          |Note: This bit can be cleared by software writing 1 and must be cleared before restarting the PWM counter.
N     * |[8]     |BRKACT    |PWM Brake Action Type
N     * |        |          |0 = PWM counter stop when brake is asserted.
N     * |        |          |1 = PWM counter keep going when brake is asserted.
N     * |[9]     |SWBRK     |Software Brake
N     * |        |          |0 = Disable PWM Software brake and back to normal PWM function.
N     * |        |          |1 = Assert PWM Brake immediately.
N     * |[29:24] |BKOD0     |PWM Brake Output Data Select Bits
N     * |        |          |0 = PWM channel n output low when fault brake conditions asserted.
N     * |        |          |1 = PWM channel n output high when fault brake conditions asserted.
N     * |[29:24] |BKOD1     |PWM Brake Output Data Select Bits
N     * |        |          |0 = PWM channel n output low when fault brake conditions asserted.
N     * |        |          |1 = PWM channel n output high when fault brake conditions asserted.
N     * |[29:24] |BKOD2     |PWM Brake Output Data Select Bits
N     * |        |          |0 = PWM channel n output low when fault brake conditions asserted.
N     * |        |          |1 = PWM channel n output high when fault brake conditions asserted.
N     * |[29:24] |BKOD3     |PWM Brake Output Data Select Bits
N     * |        |          |0 = PWM channel n output low when fault brake conditions asserted.
N     * |        |          |1 = PWM channel n output high when fault brake conditions asserted.
N     * |[29:24] |BKOD4     |PWM Brake Output Data Select Bits
N     * |        |          |0 = PWM channel n output low when fault brake conditions asserted.
N     * |        |          |1 = PWM channel n output high when fault brake conditions asserted.
N     * |[29:24] |BKOD5     |PWM Brake Output Data Select Bits
N     * |        |          |0 = PWM channel n output low when fault brake conditions asserted.
N     * |        |          |1 = PWM channel n output high when fault brake conditions asserted.
N     * |[30]    |D6BKOD    |Channel 6 Brake Output Data Select Bit
N     * |        |          |0 = Channel 6 output low when fault brake conditions asserted.
N     * |        |          |1 = Channel 6 output high when fault brake conditions asserted.
N     * |[31]    |D7BKOD    |Channel 7 Brake Output Data Select Bit
N     * |        |          |0 = Channel 7 output low when fault brake conditions asserted.
N     * |        |          |1 = Channel 7 output high when fault brake conditions asserted.
N    */
N    __IO uint32_t BRKCTL;
X    volatile uint32_t BRKCTL;
N
N    /**
N     * DTCTL
N     * ===================================================================================================
N     * Offset: 0x64  PWM Dead-time Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |DTI01     |Dead-time Interval Register For Pair Of Channel0 And Channel1 (PWM0_CH0 And PWM0_CH1 Pair)
N     * |        |          |These 8 bits determine dead-time length.
N     * |        |          |The unit time of dead-time length is received from corresponding PWM_CLKDIV bits.
N     * |[15:8]  |DTI23     |Dead-time Interval Register For Pair Of Channel2 And Channel3 (PWM0_CH2 And PWM0_CH3 Pair)
N     * |        |          |These 8 bits determine dead-time length.
N     * |        |          |The unit time of dead-time length is received from corresponding PWM_CLKDIV bits.
N     * |[23:16] |DTI45     |Dead-time Interval Register For Pair Of Channel4 And Channel5 (PWM0_CH4 And PWM0_CH5 Pair)
N     * |        |          |These 8 bits determine dead-time length.
N     * |        |          |The unit time of dead-time length is received from corresponding PWM_CLKDIV bits.
N    */
N    __IO uint32_t DTCTL;
X    volatile uint32_t DTCTL;
N
N    /**
N     * ADCTCTL0
N     * ===================================================================================================
N     * Offset: 0x68  PWM Trigger Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CUTRGEN0  |Channel 0 Compare Up Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel0's counter matching CMP0 in up-count direction
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center-aligned type.
N     * |        |          |When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.
N     * |[1]     |CPTRGEN0  |Channel 0 Center Point Trigger ADC Enable Bit
N     * |        |          |Enable PWM Trigger ADC Function While channel0's Counter Matching PERIOD0
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center-aligned type.
N     * |        |          |When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.
N     * |[2]     |CDTRGEN0  |Channel 0 Compare Down Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel0's counter matching CMP0 in down-count direction
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is valid for both center-aligned type and edged-aligned type.
N     * |[3]     |ZPTRGEN0  |Channel 0 Zero Point Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel0's counter matching 0
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is valid for both center-aligned type and edged-aligned type.
N     * |[8]     |CUTRGEN1  |Channel 1 Compare Up Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel1's counter matching CMP1 in up-count direction
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center-aligned type.
N     * |        |          |When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.
N     * |[9]     |CPTRGEN1  |Channel 1 Center Point Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel1's counter matching PERIOD1
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center-aligned type.
N     * |        |          |When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.
N     * |[10]    |CDTRGEN1  |Channel 1 Compare Down Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel1's counter matching CMP1 in down-count direction
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is valid for both center-aligned type and edged-aligned type.
N     * |[11]    |ZPTRGEN1  |Channel 1 Zero Point Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function While channel1's Counter Matching 0
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is valid for both center-aligned type and edged-aligned type.
N     * |[16]    |CUTRGEN2  |Channel 2 Compare Up Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel2's counter matching CMP2 in up-count direction
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center-aligned type.
N     * |        |          |When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.
N     * |[17]    |CPTRGEN2  |Channel 2 Center Point Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel2's counter matching PERIOD2
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center-aligned type.
N     * |        |          |When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.
N     * |[18]    |CDTRGEN2  |Channel 2 Compare Down Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel2's counter matching CMP2 in down-count direction
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is valid for both center-aligned type and edged-aligned type.
N     * |[19]    |ZPTRGEN2  |Channel 2 Zero Point Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel2's counter matching 0
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is valid for both center-aligned type and edged-aligned type.
N     * |[24]    |CUTRGEN3  |Channel 3 Compare Up Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel3's counter matching CMP3 in up-count direction
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center-aligned type.
N     * |        |          |When PWM is in edged aligned type, setting this bit is meaningless and will not take any effect.
N     * |[25]    |CPTRGEN3  |Channel 3 Center Point Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel3's counter matching PERIOD3
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center-aligned type.
N     * |        |          |When PWM is in edged aligned type, setting this bit is meaningless and will not take any effect.
N     * |[26]    |CDTRGEN3  |Channel 3 Compare Down Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel3's counter matching CMP3 in down-count direction
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is valid for both center-aligned type and edged aligned type.
N     * |[27]    |ZPTRGEN3  |Channel 3 Zero Point Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel3's counter matching 0
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is valid for both center-aligned type and edged aligned type.
N    */
N    __IO uint32_t ADCTCTL0;
X    volatile uint32_t ADCTCTL0;
N
N    /**
N     * ADCTCTL1
N     * ===================================================================================================
N     * Offset: 0x6C  PWM Trigger Control Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CUTRGEN4  |Channel 4 Compare Up Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel4's counter matching CMP4 in up-count direction
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center-aligned type.
N     * |        |          |When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.
N     * |[1]     |CPTRGEN4  |Channel 4 Center Point Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel4's counter matching PERIOD4
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center-aligned type.
N     * |        |          |When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.
N     * |[2]     |CDTRGEN4  |Channel 4 Compare Down Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel4's counter matching CMP4 in down-count direction
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is valid for both center-aligned type and edged-aligned type.
N     * |[3]     |ZPTRGEN4  |Channel 4 Zero Point Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel4's counter matching 0
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is valid for both center-aligned type and edged-aligned type.
N     * |[8]     |CUTRGEN5  |Channel 5 Compare Up Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel5's counter matching CMP5 in up-count direction
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center-aligned type.
N     * |        |          |When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.
N     * |[9]     |CPTRGEN5  |Channel 5 Center Point Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel5's counter matching PERIOD5
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center-aligned type.
N     * |        |          |When PWM is in edged-aligned type, setting this bit is meaningless and will not take any effect.
N     * |[10]    |CDTRGEN5  |Channel 5 Compare Down Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel5's counter matching CMP5 in down-count direction
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is valid for both center-aligned type and edged-aligned type.
N     * |[11]    |ZPTRGEN5  |Channel 5 Zero Point Trigger ADC Enable Bit
N     * |        |          |Enable PWM trigger ADC function while channel5's counter matching 0
N     * |        |          |0 = PWM condition trigger ADC function Disabled.
N     * |        |          |1 = PWM condition trigger ADC function Enabled.
N     * |        |          |Note: This bit is valid for both center-aligned type and edged-aligned type.
N    */
N    __IO uint32_t ADCTCTL1;
X    volatile uint32_t ADCTCTL1;
N
N    /**
N     * ADCTSTS0
N     * ===================================================================================================
N     * Offset: 0x70  PWM Trigger Status Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CUTRGF0   |Channel 0 Compare Up Trigger ADC Flag
N     * |        |          |When the channel0's counter is counting up to CMP0, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[1]     |CPTRGF0   |Channel 0 Center Point Trigger ADC Flag
N     * |        |          |When the channel0's counter is counting to PERIOD0, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[2]     |CDTRGF0   |Channel 0 Compare Down Trigger ADC Flag
N     * |        |          |When the channel0's counter is counting down to CMP0, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[3]     |ZPTRGF0   |Channel 0 Zero Point Trigger ADC Flag
N     * |        |          |When the channel0's counter is counting to zero point, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[8]     |CUTRGF1   |Channel 1 Compare Up Trigger ADC Flag
N     * |        |          |When the channel1's counter is counting up to CMP1, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[9]     |CPTRGF1   |Channel 1 Center Point Trigger ADC Flag
N     * |        |          |When the channel1's counter is counting to PERIOD1, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[10]    |CDTRGF1   |Channel 1 Compare Down Trigger ADC Flag
N     * |        |          |When the channel1's counter is counting down to CMP1, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[11]    |ZPTRGF1   |Channel 1 Zero Point Trigger ADC Flag
N     * |        |          |When the channel1's counter is counting to zero point, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[16]    |CUTRGF2   |Channel 2 Compare Up Trigger ADC Flag
N     * |        |          |When the channel2's counter is counting up to CMP2, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[17]    |CPTRGF2   |Channel 2 Center Point Trigger ADC Flag
N     * |        |          |When the channel2's counter is counting to PERIOD2, this bit will be set for trigger ADC. Note:
N     * |        |          |This bit can be cleared by software writing 1.
N     * |[18]    |CDTRGF2   |Channel 2 Compare Down Trigger ADC Flag
N     * |        |          |When the channel2's counter is counting down to CMP2, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[19]    |ZPTRGF2   |Channel 2 Zero Point Trigger ADC Enable Bit
N     * |        |          |When the channel2's counter is counting to zero point, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[24]    |CUTRGF3   |Channel 3 Compare Up Trigger ADC Flag
N     * |        |          |When the channel3's counter is counting up to CMP3, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[25]    |CPTRGF3   |Channel 3 Center Point Trigger ADC Flag
N     * |        |          |When the channel3's counter is counting to PERIOD3, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[26]    |CDTRGF3   |Channel 3 Compare Down Trigger ADC Flag
N     * |        |          |When the channel3's counter is counting down to CMP3, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[27]    |ZPTRGF3   |Channel 3 Zero Point Trigger ADC Flag
N     * |        |          |When the channel3's counter is counting to zero point, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N    */
N    __IO uint32_t ADCTSTS0;
X    volatile uint32_t ADCTSTS0;
N
N    /**
N     * ADCTSTS1
N     * ===================================================================================================
N     * Offset: 0x74  PWM Trigger Status Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CUTRGF4   |Channel 4 Compare Up Trigger ADC Flag
N     * |        |          |When the channel4's counter is counting up to CMP4, this bit will be set for trigger ADC. Note:
N     * |        |          |This bit can be cleared by software writing 1.
N     * |[1]     |CPTRGF4   |Channel 4 Center Point Trigger ADC Flag
N     * |        |          |When the channel4's counter is counting to PERIOD4, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[2]     |CDTRGF4   |Channel 4 Compare Down Trigger ADC Flag
N     * |        |          |When the channel4's counter is counting down to CMP4, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[3]     |ZPTRGF4   |Channel 4 Zero Point Trigger ADC Flag
N     * |        |          |When the channel4's counter is counting to zero point, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[8]     |CUTRGF5   |Channel 5 Compare Up Trigger ADC Flag
N     * |        |          |When the channel5's counter is counting up to CMP5, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[9]     |CPTRGF5   |Channel 5 Center Point Trigger ADC Flag
N     * |        |          |When the channel5's counter is counting to PERIOD5, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[10]    |CDTRGF5   |Channel 5 Compare Down Trigger ADC Flag
N     * |        |          |When the channel5's counter is counting down to CMP5, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N     * |[11]    |ZPTRGF5   |Channel 5 Zero Point Trigger ADC Flag
N     * |        |          |When the channel5's counter is counting to zero point, this bit will be set for trigger ADC.
N     * |        |          |Note: This bit can be cleared by software writing 1.
N    */
N    __IO uint32_t ADCTSTS1;
X    volatile uint32_t ADCTSTS1;
N
N    /**
N     * PHCHG
N     * ===================================================================================================
N     * Offset: 0x78  PWM Phase Changed Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |MSKDAT0   |PWM0_CHn Mask Data
N     * |        |          |When MSKENn is 0, channel n's output level is MSKDATn.
N     * |        |          |0 = PWM0_CHn output low level.
N     * |        |          |1 = PWM0_CHn output high level.
N     * |[5:0]   |MSKDAT1   |PWM0_CHn Mask Data
N     * |        |          |When MSKENn is 0, channel n's output level is MSKDATn.
N     * |        |          |0 = PWM0_CHn output low level.
N     * |        |          |1 = PWM0_CHn output high level.
N     * |[5:0]   |MSKDAT2   |PWM0_CHn Mask Data
N     * |        |          |When MSKENn is 0, channel n's output level is MSKDATn.
N     * |        |          |0 = PWM0_CHn output low level.
N     * |        |          |1 = PWM0_CHn output high level.
N     * |[5:0]   |MSKDAT3   |PWM0_CHn Mask Data
N     * |        |          |When MSKENn is 0, channel n's output level is MSKDATn.
N     * |        |          |0 = PWM0_CHn output low level.
N     * |        |          |1 = PWM0_CHn output high level.
N     * |[5:0]   |MSKDAT4   |PWM0_CHn Mask Data
N     * |        |          |When MSKENn is 0, channel n's output level is MSKDATn.
N     * |        |          |0 = PWM0_CHn output low level.
N     * |        |          |1 = PWM0_CHn output high level.
N     * |[5:0]   |MSKDAT5   |PWM0_CHn Mask Data
N     * |        |          |When MSKENn is 0, channel n's output level is MSKDATn.
N     * |        |          |0 = PWM0_CHn output low level.
N     * |        |          |1 = PWM0_CHn output high level.
N     * |[6]     |MSKDAT6   |PWM0_CH6 (GPIO P0.1) Mask Data
N     * |        |          |When MASKEND6 Is 1, channel 6's output level is MSKDAT6.
N     * |        |          |0 = PWM0_CH6 output low level.
N     * |        |          |1 = PWM0_CH6 output high level.
N     * |[7]     |MSKDAT7   |PWM0_CH7 (GPIO P0.0) Mask Data
N     * |        |          |When MASKEND7 Is 1, channel 7's output level is MSKDAT7.
N     * |        |          |0 = PWM0_CH7 output low level.
N     * |        |          |1 = PWM0_CH7 output high level.
N     * |[13:8]  |MSKEN0    |PWMn Output Mask Enable Bits
N     * |        |          |0 = Output MSKDATn specified in bit n of PWM_PHCHG register.
N     * |        |          |1 = Output the original channel n waveform.
N     * |[13:8]  |MSKEN1    |PWMn Output Mask Enable Bits
N     * |        |          |0 = Output MSKDATn specified in bit n of PWM_PHCHG register.
N     * |        |          |1 = Output the original channel n waveform.
N     * |[13:8]  |MSKEN2    |PWMn Output Mask Enable Bits
N     * |        |          |0 = Output MSKDATn specified in bit n of PWM_PHCHG register.
N     * |        |          |1 = Output the original channel n waveform.
N     * |[13:8]  |MSKEN3    |PWMn Output Mask Enable Bits
N     * |        |          |0 = Output MSKDATn specified in bit n of PWM_PHCHG register.
N     * |        |          |1 = Output the original channel n waveform.
N     * |[13:8]  |MSKEN4    |PWMn Output Mask Enable Bits
N     * |        |          |0 = Output MSKDATn specified in bit n of PWM_PHCHG register.
N     * |        |          |1 = Output the original channel n waveform.
N     * |[13:8]  |MSKEN5    |PWMn Output Mask Enable Bits
N     * |        |          |0 = Output MSKDATn specified in bit n of PWM_PHCHG register.
N     * |        |          |1 = Output the original channel n waveform.
N     * |[14]    |AUTOCLR0  |Hardware Auto Clear ACMP0TEN
N     * |        |          |0 = Hardware will auto clear ACMP0TEN when ACMP0 trigger PWM.
N     * |        |          |1 = Hardware will not auto clear ACMP0TEN when ACMP0 trigger PWM.
N     * |[15]    |AUTOCLR1  |Hardware Auto Clear ACMP1TEN
N     * |        |          |0 = Hardware will auto clear ACMP1TEN when ACMP1 trigger PWM.
N     * |        |          |1 = Hardware will not auto clear ACMP1TEN when ACMP1 trigger PWM.
N     * |[16]    |AOFFEN01  |ACMP1 Trigger Channel 0 One Cycle Output Off Enable Bit
N     * |        |          |Setting this bit will force PWM channel 0 to output low lasting for at most one period cycle as long as ACMP1 trigger It; This feature is usually in step motor application.
N     * |        |          |0 = PWM0_CH0 one period cycle output low Disabled.
N     * |        |          |1 = PWM0_CH0 one period cycle output low Enabled.
N     * |        |          |Note: This function is only available for PWM0_CH0~PWM0_CH3.
N     * |[17]    |AOFFEN11  |ACMP1 Trigger Channel 1 One Cycle Output Off Enable Bit
N     * |        |          |Setting this bit will force PWM channel 1 to output low lasting for at most one period cycle as long as ACMP1 trigger It; This feature is usually in step motor application.
N     * |        |          |0 = PWM0_CH1 one period cycle output low Disabled.
N     * |        |          |1 = PWM0_CH1 one period cycle output low Enabled.
N     * |        |          |Note: This function is only available for PWM0_CH0~PWM0_CH3.
N     * |[18]    |AOFFEN21  |ACMP1 Trigger Channel 2 One Cycle Output Off Enable Bit
N     * |        |          |Setting this bit will force PWM channel 2 to output low lasting for at most one period cycle as long as ACMP1 trigger It; This feature is usually in step motor application.
N     * |        |          |0 = PWM0_CH2 one period cycle output low Disabled.
N     * |        |          |1 = PWM0_CH2 one period cycle output low Enabled.
N     * |        |          |Note: This function is only available for PWM0_CH0~PWM0_CH 3.
N     * |[19]    |AOFFEN31  |ACMP1 Trigger Channel 3 One Cycle Output Off Enable Bit
N     * |        |          |Setting this bit will force PWM channel 3 to output low lasting for at most one period cycle as long as ACMP1 trigger It; This feature is usually in step motor application.
N     * |        |          |0 = PWM0_CH3 one period cycle output low Disabled.
N     * |        |          |1 = PWM0_CH3 one period cycle output low Enabled.
N     * |        |          |Note: This function is only available for PWM0_CH0~PWM0_CH3.
N     * |[21:20] |A1POSSEL  |ACMP1 Positive Input Source Select Bits
N     * |        |          |00 = Select P3.1 as the input of ACMP1.
N     * |        |          |01 = Select P3.2 as the input of ACMP1.
N     * |        |          |10 = Select P3.3 as the input of ACMP1.
N     * |        |          |11 = Select P3.4 as the input of ACMP1.
N     * |[22]    |TMR1TEN   |TIMER1 Trigger PWM Function Enable Bit
N     * |        |          |When this bit is set, TIMER1 time-out event will update PWM_PHCHG with PHCHG_NXT register.
N     * |        |          |0 = TIMER1 trigger PWM function Disabled.
N     * |        |          |1 = TIMER1 trigger PWM function Enabled.
N     * |[23]    |ACMP1TEN  |ACMP1 Trigger Function Enable Bit
N     * |        |          |0 = ACMP1 trigger PWM function Disabled.
N     * |        |          |1 = ACMP1 trigger PWM function Enabled.
N     * |        |          |Note: This bit will be auto cleared when ACMP1 trigger PWM if AUTOCLR1 is set.
N     * |[24]    |AOFFEN00  |ACMP0 Trigger Channel 0 One Cycle Output Off Enable Bit
N     * |        |          |Setting this bit will force PWM channel 0 to output low lasting for at most one period cycle as long as ACMP0 trigger It; This feature is usually in step motor application.
N     * |        |          |0 = PWM0_CH0 one period cycle output low Disabled.
N     * |        |          |1 = PWM0_CH0 one period cycle output low Enabled.
N     * |        |          |Note: This function is only available for PWM0_CH0~PWM0_CH3.
N     * |[25]    |AOFFEN10  |ACMP0 Trigger Channel 1 One Cycle Output Off Enable Bit
N     * |        |          |Setting this bit will force PWM channel 1 to output low lasting for at most one period cycle as long as ACMP0 trigger It; This feature is usually in step motor application.
N     * |        |          |0 = PWM0_CH1 one period cycle output low Disabled.
N     * |        |          |1 = PWM0_CH1 one period cycle output low Enabled.
N     * |        |          |Note: This function is only available for PWM0_CH0~PWM0_CH3.
N     * |[26]    |AOFFEN20  |ACMP0 Trigger Channel 2 One Cycle Output Off Enable Bit
N     * |        |          |Setting this bit will force PWM channel 2 to output low lasting for at most one period cycle as long as ACMP0 trigger It; This feature is usually in step motor application.
N     * |        |          |0 = PWM0_CH2 one period cycle output low Disabled.
N     * |        |          |1 = PWM0_CH2 one period cycle output low Enabled.
N     * |        |          |Note: This function is only available for PWM0_CH0~PWM0_CH3.
N     * |[27]    |AOFFEN30  |ACMP0 Trigger Channel 3 One Cycle Output Off Enable Bit
N     * |        |          |Setting this bit will force PWM channel 3 to output low lasting for at most one period cycle as long as ACMP0 trigger It; This feature is usually in step motor application.
N     * |        |          |0 = PWM0_CH3 one period cycle output low Disabled.
N     * |        |          |1 = PWM0_CH3 one period cycle output low Enabled.
N     * |        |          |Note: This function is only available for PWM0_CH0~ PWM0_CH3.
N     * |[29:28] |A0POSSEL  |ACMP0 Positive Input Source Select Bits
N     * |        |          |00 = Select P1.5 as the input of ACMP0.
N     * |        |          |01 = Select P1.0 as the input of ACMP0.
N     * |        |          |10 = Select P1.2 as the input of ACMP0.
N     * |        |          |11 = Select P1.3 as the input of ACMP0.
N     * |[30]    |TMR0TEN   |TIMER0 Trigger PWM Function Enable Bit
N     * |        |          |When this bit is set, TIMER0 time-out event will update PWM_PHCHG with PHCHG_NXT register.
N     * |        |          |0 = TIMER0 trigger PWM function Disabled.
N     * |        |          |1 = TIMER0 trigger PWM function Enabled.
N     * |[31]    |ACMP0TEN  |ACMP0 Trigger PWM Function Enable Bit
N     * |        |          |0 = ACMP0 trigger PWM function Disabled.
N     * |        |          |1 = ACMP0 trigger PWM function Enabled.
N     * |        |          |Note: This bit will be auto cleared when ACMP0 trigger PWM if AUTOCLR0 is set.
N    */
N    __IO uint32_t PHCHG;
X    volatile uint32_t PHCHG;
N
N    /**
N     * PHCHGNXT
N     * ===================================================================================================
N     * Offset: 0x7C  PWM Next Phase Change Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |MSKDAT0   |PWM0_CHn Mask Data
N     * |        |          |When MSKENn is 0, channel n's output level is MSKDATn.
N     * |        |          |0 = PWM0_CHn output low level.
N     * |        |          |1 = PWM0_CHn output high level.
N     * |[5:0]   |MSKDAT1   |PWM0_CHn Mask Data
N     * |        |          |When MSKENn is 0, channel n's output level is MSKDATn.
N     * |        |          |0 = PWM0_CHn output low level.
N     * |        |          |1 = PWM0_CHn output high level.
N     * |[5:0]   |MSKDAT2   |PWM0_CHn Mask Data
N     * |        |          |When MSKENn is 0, channel n's output level is MSKDATn.
N     * |        |          |0 = PWM0_CHn output low level.
N     * |        |          |1 = PWM0_CHn output high level.
N     * |[5:0]   |MSKDAT3   |PWM0_CHn Mask Data
N     * |        |          |When MSKENn is 0, channel n's output level is MSKDATn.
N     * |        |          |0 = PWM0_CHn output low level.
N     * |        |          |1 = PWM0_CHn output high level.
N     * |[5:0]   |MSKDAT4   |PWM0_CHn Mask Data
N     * |        |          |When MSKENn is 0, channel n's output level is MSKDATn.
N     * |        |          |0 = PWM0_CHn output low level.
N     * |        |          |1 = PWM0_CHn output high level.
N     * |[5:0]   |MSKDAT5   |PWM0_CHn Mask Data
N     * |        |          |When MSKENn is 0, channel n's output level is MSKDATn.
N     * |        |          |0 = PWM0_CHn output low level.
N     * |        |          |1 = PWM0_CHn output high level.
N     * |[6]     |MSKDAT6   |PWM0_CH6 (GPIO P0.1) Mask Data
N     * |        |          |When MASKEND6 Is 1, channel 6's output level is MSKDAT6.
N     * |        |          |0 = PWM0_CH6 output low level.
N     * |        |          |1 = PWM0_CH6 output high level.
N     * |[7]     |MSKDAT7   |PWM0_CH7 (GPIO P0.0) Mask Data
N     * |        |          |When MASKEND7 Is 1, channel 7's output level is MSKDAT7.
N     * |        |          |0 = PWM0_CH7 output low level.
N     * |        |          |1 = PWM0_CH7 output high level.
N     * |[13:8]  |MSKEN0    |PWM Output Mask Enable Bits
N     * |        |          |0 = Output MSKDATn specified in bit n of PWM_PHCHG register.
N     * |        |          |1 = Output the original channel n waveform.
N     * |[13:8]  |MSKEN1    |PWM Output Mask Enable Bits
N     * |        |          |0 = Output MSKDATn specified in bit n of PWM_PHCHG register.
N     * |        |          |1 = Output the original channel n waveform.
N     * |[13:8]  |MSKEN2    |PWM Output Mask Enable Bits
N     * |        |          |0 = Output MSKDATn specified in bit n of PWM_PHCHG register.
N     * |        |          |1 = Output the original channel n waveform.
N     * |[13:8]  |MSKEN3    |PWM Output Mask Enable Bits
N     * |        |          |0 = Output MSKDATn specified in bit n of PWM_PHCHG register.
N     * |        |          |1 = Output the original channel n waveform.
N     * |[13:8]  |MSKEN4    |PWM Output Mask Enable Bits
N     * |        |          |0 = Output MSKDATn specified in bit n of PWM_PHCHG register.
N     * |        |          |1 = Output the original channel n waveform.
N     * |[13:8]  |MSKEN5    |PWM Output Mask Enable Bits
N     * |        |          |0 = Output MSKDATn specified in bit n of PWM_PHCHG register.
N     * |        |          |1 = Output the original channel n waveform.
N     * |[14]    |AUTOCLR0  |Hardware Auto Clear ACMP0TEN
N     * |        |          |0 = Hardware will auto clear ACMP0TEN when ACMP0 trigger PWM.
N     * |        |          |1 = Hardware will not auto clear ACMP0TEN when ACMP0 trigger PWM.
N     * |[15]    |AUTOCLR1  |Hardware Auto Clear ACMP1TEN
N     * |        |          |0 = Hardware will auto clear ACMP1TEN when ACMP1 trigger PWM.
N     * |        |          |1 = Hardware will not auto clear ACMP1TEN when ACMP1 trigger PWM.
N     * |[16]    |AOFFEN01  |ACMP1 Trigger Channel 0 One Cycle Output Off Enable Bit
N     * |        |          |Setting this bit will force PWM channel 0 to output low lasting for at most one period cycle as long as ACMP1 trigger It; This feature is usually in step motor application.
N     * |        |          |0 = PWM0_CH0 one period cycle output low Disabled.
N     * |        |          |1 = PWM0_CH0 one period cycle output low Enabled.
N     * |        |          |Note: This function is only available for PWM0_CH0~PWM0_CH3.
N     * |[17]    |AOFFEN11  |ACMP1 Trigger Channel 1 One Cycle Output Off Enable Bit
N     * |        |          |Setting this bit will force PWM channel 1 to output low lasting for at most one period cycle as long as ACMP1 trigger It; This feature is usually in step motor application.
N     * |        |          |0 = PWM0_CH1 one period cycle output low Disabled.
N     * |        |          |1 = PWM0_CH1 one period cycle output low Enabled.
N     * |        |          |Note: This function is only available for PWM0_CH0~PWM0_CH3.
N     * |[18]    |AOFFEN21  |ACMP1 Trigger Channel 2 One Cycle Output Off Enable Bit
N     * |        |          |Setting this bit will force PWM channel 2 to output low lasting for at most one period cycle as long as ACMP1 trigger It; This feature is usually in step motor application.
N     * |        |          |0 = PWM0_CH2 one period cycle output low Disabled.
N     * |        |          |1 = PWM0_CH2 one period cycle output low Enabled.
N     * |        |          |Note: This function is only available for PWM0_CH0~PWM0_CH3.
N     * |[19]    |AOFFEN31  |ACMP1 Trigger Channel 3 One Cycle Output Off Enable Bit
N     * |        |          |Setting this bit will force PWM channel 3 to output low lasting for at most one period cycle as long as ACMP1 trigger It; This feature is usually in step motor application.
N     * |        |          |0 = PWM0_CH3 one period cycle output low Disabled.
N     * |        |          |1 = PWM0_CH3 one period cycle output low Enabled.
N     * |        |          |Note: This function is only available for PWM0_CH0~PWM0_CH3.
N     * |[21:20] |A1POSSEL  |ACMP1 Positive Input Source Select Bits
N     * |        |          |00 = Select P3.1 as the input of ACMP1.
N     * |        |          |01 = Select P3.2 as the input of ACMP1.
N     * |        |          |10 = Select P3.3 as the input of ACMP1.
N     * |        |          |11 = Select P3.4 as the input of ACMP1.
N     * |[22]    |TMR1TEN   |TMR1 Trigger PWM Function Enable Bit
N     * |        |          |When this bit is set, TMR1 time-out event will update PWM_PHCHG with PHCHG_NXT register.
N     * |        |          |0 = TMR1 trigger PWM function Disabled.
N     * |        |          |1 = TMR1 trigger PWM function Enabled.
N     * |[23]    |ACMP1TEN  |ACMP1 Trigger Function Enable Bit
N     * |        |          |0 = ACMP1 trigger PWM function Disabled.
N     * |        |          |1 = ACMP1 trigger PWM function Enabled.
N     * |        |          |Note: This bit will be auto cleared when ACMP1 trigger PWM if AUTOCLR1 is set.
N     * |[24]    |AOFFEN00  |ACMP0 Trigger Channel 0 One Cycle Output Off Enable Bit
N     * |        |          |Setting this bit will force PWM channel 0 to output low lasting for at most one period cycle as long as ACMP0 trigger It; This feature is usually in step motor application.
N     * |        |          |0 = PWM0_CH0 one period cycle output low Disabled.
N     * |        |          |1 = PWM0_CH0 one period cycle output low Enabled.
N     * |        |          |Note: This function is only available for PWM0_CH0~PWM0_CH3.
N     * |[25]    |AOFFEN10  |ACMP0 Trigger Channel 1 One Cycle Output Off Enable Bit
N     * |        |          |Setting this bit will force PWM channel 1 to output low lasting for at most one period cycle as long as ACMP0 trigger It; This feature is usually in step motor application.
N     * |        |          |0 = PWM0_CH1 one period cycle output low Disabled.
N     * |        |          |1 = PWM0_CH1 one period cycle output low Enabled.
N     * |        |          |Note: This function is only available for PWM0_CH0~PWM0_CH3.
N     * |[26]    |AOFFEN20  |ACMP0 Trigger Channel 2 One Cycle Output Off Enable Bit
N     * |        |          |Setting this bit will force PWM channel 2 to output low lasting for at most one period cycle as long as ACMP0 trigger It; This feature is usually in step motor application.
N     * |        |          |0 = PWM0_CH2 one period cycle output low Disabled.
N     * |        |          |1 = PWM0_CH2 one period cycle output low Enabled.
N     * |        |          |Note: This function is only available for PWM0_CH0~PWM0_CH3.
N     * |[27]    |AOFFEN30  |ACMP0 Trigger Channel 3 One Cycle Output Off Enable Bit
N     * |        |          |Setting this bit will force PWM channel 3 to output low lasting for at most one period cycle as long as ACMP0 trigger It; This feature is usually in step motor application.
N     * |        |          |0 = PWM0_CH3 one period cycle output low Disabled.
N     * |        |          |1 = PWM0_CH3 one period cycle output low Enabled.
N     * |        |          |Note: This function is only available for PWM0_CH0~PWM0_CH3.
N     * |[29:28] |A0POSSEL  |ACMP0 Positive Input Source Select Bits
N     * |        |          |00 = Select P1.5 as the input of ACMP0.
N     * |        |          |01 = Select P1.0 as the input of ACMP0.
N     * |        |          |10 = Select P1.2 as the input of ACMP0.
N     * |        |          |11 = Select P1.3 as the input of ACMP0.
N     * |[30]    |TMR0TEN   |TMR0 Trigger PWM Function Enable Bit
N     * |        |          |When this bit is set, TMR0 time-out event will update PWM_PHCHG with PHCHG_NXT register.
N     * |        |          |0 = TMR0 trigger PWM function Disabled.
N     * |        |          |1 = TMR0 trigger PWM function Enabled.
N     * |[31]    |ACMP0TEN  |ACMP0 Trigger Function Enable Bit
N     * |        |          |0 = ACMP0 trigger PWM function Disabled.
N     * |        |          |1 = ACMP0 trigger PWM function Enabled.
N     * |        |          |Note: This bit will be auto cleared when ACMP0 trigger PWM if AUTOCLR0 is set.
N    */
N    __IO uint32_t PHCHGNXT;
X    volatile uint32_t PHCHGNXT;
N
N    /**
N     * PHCHGMSK
N     * ===================================================================================================
N     * Offset: 0x80  PWM Phase Change Mask Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[6]     |MASKEND6  |PWM0_CH6 (GPIO P0.1) Output Mask Enable Bit
N     * |        |          |0 = Output the original GPIO P0.1.
N     * |        |          |1 = Output MSKDAT6 specified in bit 6 of PWM_PHCHG register.
N     * |[7]     |MASKEND7  |PWM0_CH7 (GPIO P0.0) Output Mask Enable Bit
N     * |        |          |0 = Output the original GPIO P0.0.
N     * |        |          |1 = Output MSKDAT7 specified in bit 7 of PWM_PHCHG register.
N     * |[8]     |POSCTL0   |Positive Input Control For ACMP0
N     * |        |          |0 = The input of ACMP is controlled by CMP0CR.
N     * |        |          |1 = The input of ACMP is controlled by CMP0SEL of PWM_PHCHG register.
N     * |        |          |Note: Register CMP0CR is described in Comparator Controller chapter.
N     * |[9]     |POSCTL1   |Positive Input Control For ACMP1
N     * |        |          |0 = The input of ACMP is controlled by CMP1CR.
N     * |        |          |1 = The input of ACMP is controlled by CMP1SEL of PWM_PHCHG register.
N     * |        |          |Note: Register CMP1CR is described in Comparator Controller chapter.
N    */
N    __IO uint32_t PHCHGMSK;
X    volatile uint32_t PHCHGMSK;
N
N    /**
N     * IFA
N     * ===================================================================================================
N     * Offset: 0x84  PWM Period Interrupt Accumulation Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |IFAEN     |Interrupt Accumulation Function Enable Bit
N     * |        |          |0 = Interrupt accumulation function Disabled.
N     * |        |          |1 = Interrupt accumulation function Enabled.
N     * |[7:4]   |IFCNT     |Interrupt Accumulation Counter
N     * |        |          |When IFAEN is set, IFCNT will decrease when every ZIFn flag is set and when IFCNT reach to zero, the PWMn interrupt will occurred and IFCNT will reload itself.
N    */
N    __IO uint32_t IFA;
X    volatile uint32_t IFA;
N
N    /**
N     * PCACTL
N     * ===================================================================================================
N     * Offset: 0x88  PWM Precise Center-Aligned Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PCAEN     |PWM Precise Center-aligned Type Enable Bit
N     * |        |          |0 = Precise center-aligned type Disabled.
N     * |        |          |1 = Precise center-aligned type Enabled.
N    */
N    __IO uint32_t PCACTL;
X    volatile uint32_t PCACTL;
N
N    /**
N     * MSKALIGN
N     * ===================================================================================================
N     * Offset: 0x8C  PWM Phase Change Mask Aligned Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |MSKDAT0   |PWM0_CHn Mask Data
N     * |        |          |When MSKENn is 0, channel n's output level is MSKDATn.
N     * |        |          |0 = PWM0_CHn output low level.
N     * |        |          |1 = PWM0_CHn output high level.
N     * |[5:0]   |MSKDAT1   |PWM0_CHn Mask Data
N     * |        |          |When MSKENn is 0, channel n's output level is MSKDATn.
N     * |        |          |0 = PWM0_CHn output low level.
N     * |        |          |1 = PWM0_CHn output high level.
N     * |[5:0]   |MSKDAT2   |PWM0_CHn Mask Data
N     * |        |          |When MSKENn is 0, channel n's output level is MSKDATn.
N     * |        |          |0 = PWM0_CHn output low level.
N     * |        |          |1 = PWM0_CHn output high level.
N     * |[5:0]   |MSKDAT3   |PWM0_CHn Mask Data
N     * |        |          |When MSKENn is 0, channel n's output level is MSKDATn.
N     * |        |          |0 = PWM0_CHn output low level.
N     * |        |          |1 = PWM0_CHn output high level.
N     * |[5:0]   |MSKDAT4   |PWM0_CHn Mask Data
N     * |        |          |When MSKENn is 0, channel n's output level is MSKDATn.
N     * |        |          |0 = PWM0_CHn output low level.
N     * |        |          |1 = PWM0_CHn output high level.
N     * |[5:0]   |MSKDAT5   |PWM0_CHn Mask Data
N     * |        |          |When MSKENn is 0, channel n's output level is MSKDATn.
N     * |        |          |0 = PWM0_CHn output low level.
N     * |        |          |1 = PWM0_CHn output high level.
N     * |[13:8]  |MSKEN0    |PWM Output Mask Enable Bits
N     * |        |          |0 = Output MSKDATn specified in bit n of PWM_PHCHG register.
N     * |        |          |1 = Output the original channel n waveform.
N     * |[13:8]  |MSKEN1    |PWM Output Mask Enable Bits
N     * |        |          |0 = Output MSKDATn specified in bit n of PWM_PHCHG register.
N     * |        |          |1 = Output the original channel n waveform.
N     * |[13:8]  |MSKEN2    |PWM Output Mask Enable Bits
N     * |        |          |0 = Output MSKDATn specified in bit n of PWM_PHCHG register.
N     * |        |          |1 = Output the original channel n waveform.
N     * |[13:8]  |MSKEN3    |PWM Output Mask Enable Bits
N     * |        |          |0 = Output MSKDATn specified in bit n of PWM_PHCHG register.
N     * |        |          |1 = Output the original channel n waveform.
N     * |[13:8]  |MSKEN4    |PWM Output Mask Enable Bits
N     * |        |          |0 = Output MSKDATn specified in bit n of PWM_PHCHG register.
N     * |        |          |1 = Output the original channel n waveform.
N     * |[13:8]  |MSKEN5    |PWM Output Mask Enable Bits
N     * |        |          |0 = Output MSKDATn specified in bit n of PWM_PHCHG register.
N     * |        |          |1 = Output the original channel n waveform.
N     * |[21:16] |ALIGNn    |PWM0_CHn Output Mask Aligned Enable Bit
N     * |        |          |0 = PWM0_CHn output will mask immediately when mask function enabled.
N     * |        |          |1 = PWM0_CHn output will mask when output aligned to PWM period.
N    */
N    __IO uint32_t MSKALIGN;
X    volatile uint32_t MSKALIGN;
N
N} PWM_T;
N
N/**
N    @addtogroup PWM_CONST PWM Bit Field Definition
N    Constant Definitions for PWM Controller
N@{ */
N
N#define PWM_CLKPSC_CLKPSC01_Pos          (0)                                               /*!< PWM_T::CLKPSC: CLKPSC01 Position          */
N#define PWM_CLKPSC_CLKPSC01_Msk          (0xfful << PWM_CLKPSC_CLKPSC01_Pos)               /*!< PWM_T::CLKPSC: CLKPSC01 Mask              */
N
N#define PWM_CLKPSC_CLKPSC23_Pos          (8)                                               /*!< PWM_T::CLKPSC: CLKPSC23 Position          */
N#define PWM_CLKPSC_CLKPSC23_Msk          (0xfful << PWM_CLKPSC_CLKPSC23_Pos)               /*!< PWM_T::CLKPSC: CLKPSC23 Mask              */
N
N#define PWM_CLKPSC_CLKPSC45_Pos          (16)                                              /*!< PWM_T::CLKPSC: CLKPSC45 Position          */
N#define PWM_CLKPSC_CLKPSC45_Msk          (0xfful << PWM_CLKPSC_CLKPSC45_Pos)               /*!< PWM_T::CLKPSC: CLKPSC45 Mask              */
N
N#define PWM_CLKDIV_CLKDIV0_Pos           (0)                                               /*!< PWM_T::CLKDIV: CLKDIV0 Position           */
N#define PWM_CLKDIV_CLKDIV0_Msk           (0x7ul << PWM_CLKDIV_CLKDIV0_Pos)                 /*!< PWM_T::CLKDIV: CLKDIV0 Mask               */
N
N#define PWM_CLKDIV_CLKDIV1_Pos           (4)                                               /*!< PWM_T::CLKDIV: CLKDIV1 Position           */
N#define PWM_CLKDIV_CLKDIV1_Msk           (0x7ul << PWM_CLKDIV_CLKDIV1_Pos)                 /*!< PWM_T::CLKDIV: CLKDIV1 Mask               */
N
N#define PWM_CLKDIV_CLKDIV2_Pos           (8)                                               /*!< PWM_T::CLKDIV: CLKDIV2 Position           */
N#define PWM_CLKDIV_CLKDIV2_Msk           (0x7ul << PWM_CLKDIV_CLKDIV2_Pos)                 /*!< PWM_T::CLKDIV: CLKDIV2 Mask               */
N
N#define PWM_CLKDIV_CLKDIV3_Pos           (12)                                              /*!< PWM_T::CLKDIV: CLKDIV3 Position           */
N#define PWM_CLKDIV_CLKDIV3_Msk           (0x7ul << PWM_CLKDIV_CLKDIV3_Pos)                 /*!< PWM_T::CLKDIV: CLKDIV3 Mask               */
N
N#define PWM_CLKDIV_CLKDIV4_Pos           (16)                                              /*!< PWM_T::CLKDIV: CLKDIV4 Position           */
N#define PWM_CLKDIV_CLKDIV4_Msk           (0x7ul << PWM_CLKDIV_CLKDIV4_Pos)                 /*!< PWM_T::CLKDIV: CLKDIV4 Mask               */
N
N#define PWM_CLKDIV_CLKDIV5_Pos           (20)                                              /*!< PWM_T::CLKDIV: CLKDIV5 Position           */
N#define PWM_CLKDIV_CLKDIV5_Msk           (0x7ul << PWM_CLKDIV_CLKDIV5_Pos)                 /*!< PWM_T::CLKDIV: CLKDIV5 Mask               */
N
N#define PWM_CTL_CNTEN0_Pos               (0)                                               /*!< PWM_T::CTL: CNTEN0 Position               */
N#define PWM_CTL_CNTEN0_Msk               (0x1ul << PWM_CTL_CNTEN0_Pos)                     /*!< PWM_T::CTL: CNTEN0 Mask                   */
N
N#define PWM_CTL_DBGTRIOFF_Pos            (1)                                               /*!< PWM_T::CTL: DBGTRIOFF Position            */
N#define PWM_CTL_DBGTRIOFF_Msk            (0x1ul << PWM_CTL_DBGTRIOFF_Pos)                  /*!< PWM_T::CTL: DBGTRIOFF Mask                */
N
N#define PWM_CTL_PINV0_Pos                (2)                                               /*!< PWM_T::CTL: PINV0 Position                */
N#define PWM_CTL_PINV0_Msk                (0x1ul << PWM_CTL_PINV0_Pos)                      /*!< PWM_T::CTL: PINV0 Mask                    */
N
N#define PWM_CTL_CNTMODE0_Pos             (3)                                               /*!< PWM_T::CTL: CNTMODE0 Position             */
N#define PWM_CTL_CNTMODE0_Msk             (0x1ul << PWM_CTL_CNTMODE0_Pos)                   /*!< PWM_T::CTL: CNTMODE0 Mask                 */
N
N#define PWM_CTL_CNTEN1_Pos               (4)                                               /*!< PWM_T::CTL: CNTEN1 Position               */
N#define PWM_CTL_CNTEN1_Msk               (0x1ul << PWM_CTL_CNTEN1_Pos)                     /*!< PWM_T::CTL: CNTEN1 Mask                   */
N
N#define PWM_CTL_HCUPDT_Pos               (5)                                               /*!< PWM_T::CTL: HCUPDT Position               */
N#define PWM_CTL_HCUPDT_Msk               (0x1ul << PWM_CTL_HCUPDT_Pos)                     /*!< PWM_T::CTL: HCUPDT Mask                   */
N
N#define PWM_CTL_PINV1_Pos                (6)                                               /*!< PWM_T::CTL: PINV1 Position                */
N#define PWM_CTL_PINV1_Msk                (0x1ul << PWM_CTL_PINV1_Pos)                      /*!< PWM_T::CTL: PINV1 Mask                    */
N
N#define PWM_CTL_CNTMODE1_Pos             (7)                                               /*!< PWM_T::CTL: CNTMODE1 Position             */
N#define PWM_CTL_CNTMODE1_Msk             (0x1ul << PWM_CTL_CNTMODE1_Pos)                   /*!< PWM_T::CTL: CNTMODE1 Mask                 */
N
N#define PWM_CTL_CNTEN2_Pos               (8)                                               /*!< PWM_T::CTL: CNTEN2 Position               */
N#define PWM_CTL_CNTEN2_Msk               (0x1ul << PWM_CTL_CNTEN2_Pos)                     /*!< PWM_T::CTL: CNTEN2 Mask                   */
N
N#define PWM_CTL_PINV2_Pos                (10)                                              /*!< PWM_T::CTL: PINV2 Position                */
N#define PWM_CTL_PINV2_Msk                (0x1ul << PWM_CTL_PINV2_Pos)                      /*!< PWM_T::CTL: PINV2 Mask                    */
N
N#define PWM_CTL_CNTMODE2_Pos             (11)                                              /*!< PWM_T::CTL: CNTMODE2 Position             */
N#define PWM_CTL_CNTMODE2_Msk             (0x1ul << PWM_CTL_CNTMODE2_Pos)                   /*!< PWM_T::CTL: CNTMODE2 Mask                 */
N
N#define PWM_CTL_CNTEN3_Pos               (12)                                              /*!< PWM_T::CTL: CNTEN3 Position               */
N#define PWM_CTL_CNTEN3_Msk               (0x1ul << PWM_CTL_CNTEN3_Pos)                     /*!< PWM_T::CTL: CNTEN3 Mask                   */
N
N#define PWM_CTL_PINV3_Pos                (14)                                              /*!< PWM_T::CTL: PINV3 Position                */
N#define PWM_CTL_PINV3_Msk                (0x1ul << PWM_CTL_PINV3_Pos)                      /*!< PWM_T::CTL: PINV3 Mask                    */
N
N#define PWM_CTL_CNTMODE3_Pos             (15)                                              /*!< PWM_T::CTL: CNTMODE3 Position             */
N#define PWM_CTL_CNTMODE3_Msk             (0x1ul << PWM_CTL_CNTMODE3_Pos)                   /*!< PWM_T::CTL: CNTMODE3 Mask                 */
N
N#define PWM_CTL_CNTEN4_Pos               (16)                                              /*!< PWM_T::CTL: CNTEN4 Position               */
N#define PWM_CTL_CNTEN4_Msk               (0x1ul << PWM_CTL_CNTEN4_Pos)                     /*!< PWM_T::CTL: CNTEN4 Mask                   */
N
N#define PWM_CTL_PINV4_Pos                (18)                                              /*!< PWM_T::CTL: PINV4 Position                */
N#define PWM_CTL_PINV4_Msk                (0x1ul << PWM_CTL_PINV4_Pos)                      /*!< PWM_T::CTL: PINV4 Mask                    */
N
N#define PWM_CTL_CNTMODE4_Pos             (19)                                              /*!< PWM_T::CTL: CNTMODE4 Position             */
N#define PWM_CTL_CNTMODE4_Msk             (0x1ul << PWM_CTL_CNTMODE4_Pos)                   /*!< PWM_T::CTL: CNTMODE4 Mask                 */
N
N#define PWM_CTL_CNTEN5_Pos               (20)                                              /*!< PWM_T::CTL: CNTEN5 Position               */
N#define PWM_CTL_CNTEN5_Msk               (0x1ul << PWM_CTL_CNTEN5_Pos)                     /*!< PWM_T::CTL: CNTEN5 Mask                   */
N
N#define PWM_CTL_ASYMEN_Pos               (21)                                              /*!< PWM_T::CTL: ASYMEN Position               */
N#define PWM_CTL_ASYMEN_Msk               (0x1ul << PWM_CTL_ASYMEN_Pos)                     /*!< PWM_T::CTL: ASYMEN Mask                   */
N
N#define PWM_CTL_PINV5_Pos                (22)                                              /*!< PWM_T::CTL: PINV5 Position                */
N#define PWM_CTL_PINV5_Msk                (0x1ul << PWM_CTL_PINV5_Pos)                      /*!< PWM_T::CTL: PINV5 Mask                    */
N
N#define PWM_CTL_CNTMODE5_Pos             (23)                                              /*!< PWM_T::CTL: CNTMODE5 Position             */
N#define PWM_CTL_CNTMODE5_Msk             (0x1ul << PWM_CTL_CNTMODE5_Pos)                   /*!< PWM_T::CTL: CNTMODE5 Mask                 */
N
N#define PWM_CTL_DTCNT01_Pos              (24)                                              /*!< PWM_T::CTL: DTCNT01 Position              */
N#define PWM_CTL_DTCNT01_Msk              (0x1ul << PWM_CTL_DTCNT01_Pos)                    /*!< PWM_T::CTL: DTCNT01 Mask                  */
N
N#define PWM_CTL_DTCNT23_Pos              (25)                                              /*!< PWM_T::CTL: DTCNT23 Position              */
N#define PWM_CTL_DTCNT23_Msk              (0x1ul << PWM_CTL_DTCNT23_Pos)                    /*!< PWM_T::CTL: DTCNT23 Mask                  */
N
N#define PWM_CTL_DTCNT45_Pos              (26)                                              /*!< PWM_T::CTL: DTCNT45 Position              */
N#define PWM_CTL_DTCNT45_Msk              (0x1ul << PWM_CTL_DTCNT45_Pos)                    /*!< PWM_T::CTL: DTCNT45 Mask                  */
N
N#define PWM_CTL_CNTCLR_Pos               (27)                                              /*!< PWM_T::CTL: CNTCLR Position               */
N#define PWM_CTL_CNTCLR_Msk               (0x1ul << PWM_CTL_CNTCLR_Pos)                     /*!< PWM_T::CTL: CNTCLR Mask                   */
N
N#define PWM_CTL_MODE_Pos                 (28)                                              /*!< PWM_T::CTL: MODE Position                 */
N#define PWM_CTL_MODE_Msk                 (0x3ul << PWM_CTL_MODE_Pos)                       /*!< PWM_T::CTL: MODE Mask                     */
N
N#define PWM_CTL_GROUPEN_Pos              (30)                                              /*!< PWM_T::CTL: GROUPEN Position              */
N#define PWM_CTL_GROUPEN_Msk              (0x1ul << PWM_CTL_GROUPEN_Pos)                    /*!< PWM_T::CTL: GROUPEN Mask                  */
N
N#define PWM_CTL_CNTTYPE_Pos              (31)                                              /*!< PWM_T::CTL: CNTTYPE Position              */
N#define PWM_CTL_CNTTYPE_Msk              (0x1ul << PWM_CTL_CNTTYPE_Pos)                    /*!< PWM_T::CTL: CNTTYPE Mask                  */
N
N#define PWM_PERIOD0_PERIOD0_Pos          (0)                                               /*!< PWM_T::PERIOD0: PERIOD0 Position          */
N#define PWM_PERIOD0_PERIOD0_Msk          (0xfffful << PWM_PERIOD0_PERIOD0_Pos)             /*!< PWM_T::PERIOD0: PERIOD0 Mask              */
N
N#define PWM_PERIOD0_PERIOD1_Pos          (0)                                               /*!< PWM_T::PERIOD0: PERIOD1 Position          */
N#define PWM_PERIOD0_PERIOD1_Msk          (0xfffful << PWM_PERIOD0_PERIOD1_Pos)             /*!< PWM_T::PERIOD0: PERIOD1 Mask              */
N
N#define PWM_PERIOD0_PERIOD2_Pos          (0)                                               /*!< PWM_T::PERIOD0: PERIOD2 Position          */
N#define PWM_PERIOD0_PERIOD2_Msk          (0xfffful << PWM_PERIOD0_PERIOD2_Pos)             /*!< PWM_T::PERIOD0: PERIOD2 Mask              */
N
N#define PWM_PERIOD0_PERIOD3_Pos          (0)                                               /*!< PWM_T::PERIOD0: PERIOD3 Position          */
N#define PWM_PERIOD0_PERIOD3_Msk          (0xfffful << PWM_PERIOD0_PERIOD3_Pos)             /*!< PWM_T::PERIOD0: PERIOD3 Mask              */
N
N#define PWM_PERIOD0_PERIOD4_Pos          (0)                                               /*!< PWM_T::PERIOD0: PERIOD4 Position          */
N#define PWM_PERIOD0_PERIOD4_Msk          (0xfffful << PWM_PERIOD0_PERIOD4_Pos)             /*!< PWM_T::PERIOD0: PERIOD4 Mask              */
N
N#define PWM_PERIOD0_PERIOD5_Pos          (0)                                               /*!< PWM_T::PERIOD0: PERIOD5 Position          */
N#define PWM_PERIOD0_PERIOD5_Msk          (0xfffful << PWM_PERIOD0_PERIOD5_Pos)             /*!< PWM_T::PERIOD0: PERIOD5 Mask              */
N
N#define PWM_PERIOD1_PERIOD0_Pos          (0)                                               /*!< PWM_T::PERIOD1: PERIOD0 Position          */
N#define PWM_PERIOD1_PERIOD0_Msk          (0xfffful << PWM_PERIOD1_PERIOD0_Pos)             /*!< PWM_T::PERIOD1: PERIOD0 Mask              */
N
N#define PWM_PERIOD1_PERIOD1_Pos          (0)                                               /*!< PWM_T::PERIOD1: PERIOD1 Position          */
N#define PWM_PERIOD1_PERIOD1_Msk          (0xfffful << PWM_PERIOD1_PERIOD1_Pos)             /*!< PWM_T::PERIOD1: PERIOD1 Mask              */
N
N#define PWM_PERIOD1_PERIOD2_Pos          (0)                                               /*!< PWM_T::PERIOD1: PERIOD2 Position          */
N#define PWM_PERIOD1_PERIOD2_Msk          (0xfffful << PWM_PERIOD1_PERIOD2_Pos)             /*!< PWM_T::PERIOD1: PERIOD2 Mask              */
N
N#define PWM_PERIOD1_PERIOD3_Pos          (0)                                               /*!< PWM_T::PERIOD1: PERIOD3 Position          */
N#define PWM_PERIOD1_PERIOD3_Msk          (0xfffful << PWM_PERIOD1_PERIOD3_Pos)             /*!< PWM_T::PERIOD1: PERIOD3 Mask              */
N
N#define PWM_PERIOD1_PERIOD4_Pos          (0)                                               /*!< PWM_T::PERIOD1: PERIOD4 Position          */
N#define PWM_PERIOD1_PERIOD4_Msk          (0xfffful << PWM_PERIOD1_PERIOD4_Pos)             /*!< PWM_T::PERIOD1: PERIOD4 Mask              */
N
N#define PWM_PERIOD1_PERIOD5_Pos          (0)                                               /*!< PWM_T::PERIOD1: PERIOD5 Position          */
N#define PWM_PERIOD1_PERIOD5_Msk          (0xfffful << PWM_PERIOD1_PERIOD5_Pos)             /*!< PWM_T::PERIOD1: PERIOD5 Mask              */
N
N#define PWM_PERIOD2_PERIOD0_Pos          (0)                                               /*!< PWM_T::PERIOD2: PERIOD0 Position          */
N#define PWM_PERIOD2_PERIOD0_Msk          (0xfffful << PWM_PERIOD2_PERIOD0_Pos)             /*!< PWM_T::PERIOD2: PERIOD0 Mask              */
N
N#define PWM_PERIOD2_PERIOD1_Pos          (0)                                               /*!< PWM_T::PERIOD2: PERIOD1 Position          */
N#define PWM_PERIOD2_PERIOD1_Msk          (0xfffful << PWM_PERIOD2_PERIOD1_Pos)             /*!< PWM_T::PERIOD2: PERIOD1 Mask              */
N
N#define PWM_PERIOD2_PERIOD2_Pos          (0)                                               /*!< PWM_T::PERIOD2: PERIOD2 Position          */
N#define PWM_PERIOD2_PERIOD2_Msk          (0xfffful << PWM_PERIOD2_PERIOD2_Pos)             /*!< PWM_T::PERIOD2: PERIOD2 Mask              */
N
N#define PWM_PERIOD2_PERIOD3_Pos          (0)                                               /*!< PWM_T::PERIOD2: PERIOD3 Position          */
N#define PWM_PERIOD2_PERIOD3_Msk          (0xfffful << PWM_PERIOD2_PERIOD3_Pos)             /*!< PWM_T::PERIOD2: PERIOD3 Mask              */
N
N#define PWM_PERIOD2_PERIOD4_Pos          (0)                                               /*!< PWM_T::PERIOD2: PERIOD4 Position          */
N#define PWM_PERIOD2_PERIOD4_Msk          (0xfffful << PWM_PERIOD2_PERIOD4_Pos)             /*!< PWM_T::PERIOD2: PERIOD4 Mask              */
N
N#define PWM_PERIOD2_PERIOD5_Pos          (0)                                               /*!< PWM_T::PERIOD2: PERIOD5 Position          */
N#define PWM_PERIOD2_PERIOD5_Msk          (0xfffful << PWM_PERIOD2_PERIOD5_Pos)             /*!< PWM_T::PERIOD2: PERIOD5 Mask              */
N
N#define PWM_PERIOD3_PERIOD0_Pos          (0)                                               /*!< PWM_T::PERIOD3: PERIOD0 Position          */
N#define PWM_PERIOD3_PERIOD0_Msk          (0xfffful << PWM_PERIOD3_PERIOD0_Pos)             /*!< PWM_T::PERIOD3: PERIOD0 Mask              */
N
N#define PWM_PERIOD3_PERIOD1_Pos          (0)                                               /*!< PWM_T::PERIOD3: PERIOD1 Position          */
N#define PWM_PERIOD3_PERIOD1_Msk          (0xfffful << PWM_PERIOD3_PERIOD1_Pos)             /*!< PWM_T::PERIOD3: PERIOD1 Mask              */
N
N#define PWM_PERIOD3_PERIOD2_Pos          (0)                                               /*!< PWM_T::PERIOD3: PERIOD2 Position          */
N#define PWM_PERIOD3_PERIOD2_Msk          (0xfffful << PWM_PERIOD3_PERIOD2_Pos)             /*!< PWM_T::PERIOD3: PERIOD2 Mask              */
N
N#define PWM_PERIOD3_PERIOD3_Pos          (0)                                               /*!< PWM_T::PERIOD3: PERIOD3 Position          */
N#define PWM_PERIOD3_PERIOD3_Msk          (0xfffful << PWM_PERIOD3_PERIOD3_Pos)             /*!< PWM_T::PERIOD3: PERIOD3 Mask              */
N
N#define PWM_PERIOD3_PERIOD4_Pos          (0)                                               /*!< PWM_T::PERIOD3: PERIOD4 Position          */
N#define PWM_PERIOD3_PERIOD4_Msk          (0xfffful << PWM_PERIOD3_PERIOD4_Pos)             /*!< PWM_T::PERIOD3: PERIOD4 Mask              */
N
N#define PWM_PERIOD3_PERIOD5_Pos          (0)                                               /*!< PWM_T::PERIOD3: PERIOD5 Position          */
N#define PWM_PERIOD3_PERIOD5_Msk          (0xfffful << PWM_PERIOD3_PERIOD5_Pos)             /*!< PWM_T::PERIOD3: PERIOD5 Mask              */
N
N#define PWM_PERIOD4_PERIOD0_Pos          (0)                                               /*!< PWM_T::PERIOD4: PERIOD0 Position          */
N#define PWM_PERIOD4_PERIOD0_Msk          (0xfffful << PWM_PERIOD4_PERIOD0_Pos)             /*!< PWM_T::PERIOD4: PERIOD0 Mask              */
N
N#define PWM_PERIOD4_PERIOD1_Pos          (0)                                               /*!< PWM_T::PERIOD4: PERIOD1 Position          */
N#define PWM_PERIOD4_PERIOD1_Msk          (0xfffful << PWM_PERIOD4_PERIOD1_Pos)             /*!< PWM_T::PERIOD4: PERIOD1 Mask              */
N
N#define PWM_PERIOD4_PERIOD2_Pos          (0)                                               /*!< PWM_T::PERIOD4: PERIOD2 Position          */
N#define PWM_PERIOD4_PERIOD2_Msk          (0xfffful << PWM_PERIOD4_PERIOD2_Pos)             /*!< PWM_T::PERIOD4: PERIOD2 Mask              */
N
N#define PWM_PERIOD4_PERIOD3_Pos          (0)                                               /*!< PWM_T::PERIOD4: PERIOD3 Position          */
N#define PWM_PERIOD4_PERIOD3_Msk          (0xfffful << PWM_PERIOD4_PERIOD3_Pos)             /*!< PWM_T::PERIOD4: PERIOD3 Mask              */
N
N#define PWM_PERIOD4_PERIOD4_Pos          (0)                                               /*!< PWM_T::PERIOD4: PERIOD4 Position          */
N#define PWM_PERIOD4_PERIOD4_Msk          (0xfffful << PWM_PERIOD4_PERIOD4_Pos)             /*!< PWM_T::PERIOD4: PERIOD4 Mask              */
N
N#define PWM_PERIOD4_PERIOD5_Pos          (0)                                               /*!< PWM_T::PERIOD4: PERIOD5 Position          */
N#define PWM_PERIOD4_PERIOD5_Msk          (0xfffful << PWM_PERIOD4_PERIOD5_Pos)             /*!< PWM_T::PERIOD4: PERIOD5 Mask              */
N
N#define PWM_PERIOD5_PERIOD0_Pos          (0)                                               /*!< PWM_T::PERIOD5: PERIOD0 Position          */
N#define PWM_PERIOD5_PERIOD0_Msk          (0xfffful << PWM_PERIOD5_PERIOD0_Pos)             /*!< PWM_T::PERIOD5: PERIOD0 Mask              */
N
N#define PWM_PERIOD5_PERIOD1_Pos          (0)                                               /*!< PWM_T::PERIOD5: PERIOD1 Position          */
N#define PWM_PERIOD5_PERIOD1_Msk          (0xfffful << PWM_PERIOD5_PERIOD1_Pos)             /*!< PWM_T::PERIOD5: PERIOD1 Mask              */
N
N#define PWM_PERIOD5_PERIOD2_Pos          (0)                                               /*!< PWM_T::PERIOD5: PERIOD2 Position          */
N#define PWM_PERIOD5_PERIOD2_Msk          (0xfffful << PWM_PERIOD5_PERIOD2_Pos)             /*!< PWM_T::PERIOD5: PERIOD2 Mask              */
N
N#define PWM_PERIOD5_PERIOD3_Pos          (0)                                               /*!< PWM_T::PERIOD5: PERIOD3 Position          */
N#define PWM_PERIOD5_PERIOD3_Msk          (0xfffful << PWM_PERIOD5_PERIOD3_Pos)             /*!< PWM_T::PERIOD5: PERIOD3 Mask              */
N
N#define PWM_PERIOD5_PERIOD4_Pos          (0)                                               /*!< PWM_T::PERIOD5: PERIOD4 Position          */
N#define PWM_PERIOD5_PERIOD4_Msk          (0xfffful << PWM_PERIOD5_PERIOD4_Pos)             /*!< PWM_T::PERIOD5: PERIOD4 Mask              */
N
N#define PWM_PERIOD5_PERIOD5_Pos          (0)                                               /*!< PWM_T::PERIOD5: PERIOD5 Position          */
N#define PWM_PERIOD5_PERIOD5_Msk          (0xfffful << PWM_PERIOD5_PERIOD5_Pos)             /*!< PWM_T::PERIOD5: PERIOD5 Mask              */
N
N#define PWM_CMPDAT0_CMP0_Pos             (0)                                               /*!< PWM_T::CMPDAT0: CMP0 Position             */
N#define PWM_CMPDAT0_CMP0_Msk             (0xfffful << PWM_CMPDAT0_CMP0_Pos)                /*!< PWM_T::CMPDAT0: CMP0 Mask                 */
N
N#define PWM_CMPDAT0_CMP1_Pos             (0)                                               /*!< PWM_T::CMPDAT0: CMP1 Position             */
N#define PWM_CMPDAT0_CMP1_Msk             (0xfffful << PWM_CMPDAT0_CMP1_Pos)                /*!< PWM_T::CMPDAT0: CMP1 Mask                 */
N
N#define PWM_CMPDAT0_CMP2_Pos             (0)                                               /*!< PWM_T::CMPDAT0: CMP2 Position             */
N#define PWM_CMPDAT0_CMP2_Msk             (0xfffful << PWM_CMPDAT0_CMP2_Pos)                /*!< PWM_T::CMPDAT0: CMP2 Mask                 */
N
N#define PWM_CMPDAT0_CMP3_Pos             (0)                                               /*!< PWM_T::CMPDAT0: CMP3 Position             */
N#define PWM_CMPDAT0_CMP3_Msk             (0xfffful << PWM_CMPDAT0_CMP3_Pos)                /*!< PWM_T::CMPDAT0: CMP3 Mask                 */
N
N#define PWM_CMPDAT0_CMP4_Pos             (0)                                               /*!< PWM_T::CMPDAT0: CMP4 Position             */
N#define PWM_CMPDAT0_CMP4_Msk             (0xfffful << PWM_CMPDAT0_CMP4_Pos)                /*!< PWM_T::CMPDAT0: CMP4 Mask                 */
N
N#define PWM_CMPDAT0_CMP5_Pos             (0)                                               /*!< PWM_T::CMPDAT0: CMP5 Position             */
N#define PWM_CMPDAT0_CMP5_Msk             (0xfffful << PWM_CMPDAT0_CMP5_Pos)                /*!< PWM_T::CMPDAT0: CMP5 Mask                 */
N
N#define PWM_CMPDAT0_CMPD0_Pos            (16)                                              /*!< PWM_T::CMPDAT0: CMPD0 Position            */
N#define PWM_CMPDAT0_CMPD0_Msk            (0xfffful << PWM_CMPDAT0_CMPD0_Pos)               /*!< PWM_T::CMPDAT0: CMPD0 Mask                */
N
N#define PWM_CMPDAT0_CMPD1_Pos            (16)                                              /*!< PWM_T::CMPDAT0: CMPD1 Position            */
N#define PWM_CMPDAT0_CMPD1_Msk            (0xfffful << PWM_CMPDAT0_CMPD1_Pos)               /*!< PWM_T::CMPDAT0: CMPD1 Mask                */
N
N#define PWM_CMPDAT0_CMPD2_Pos            (16)                                              /*!< PWM_T::CMPDAT0: CMPD2 Position            */
N#define PWM_CMPDAT0_CMPD2_Msk            (0xfffful << PWM_CMPDAT0_CMPD2_Pos)               /*!< PWM_T::CMPDAT0: CMPD2 Mask                */
N
N#define PWM_CMPDAT0_CMPD3_Pos            (16)                                              /*!< PWM_T::CMPDAT0: CMPD3 Position            */
N#define PWM_CMPDAT0_CMPD3_Msk            (0xfffful << PWM_CMPDAT0_CMPD3_Pos)               /*!< PWM_T::CMPDAT0: CMPD3 Mask                */
N
N#define PWM_CMPDAT0_CMPD4_Pos            (16)                                              /*!< PWM_T::CMPDAT0: CMPD4 Position            */
N#define PWM_CMPDAT0_CMPD4_Msk            (0xfffful << PWM_CMPDAT0_CMPD4_Pos)               /*!< PWM_T::CMPDAT0: CMPD4 Mask                */
N
N#define PWM_CMPDAT0_CMPD5_Pos            (16)                                              /*!< PWM_T::CMPDAT0: CMPD5 Position            */
N#define PWM_CMPDAT0_CMPD5_Msk            (0xfffful << PWM_CMPDAT0_CMPD5_Pos)               /*!< PWM_T::CMPDAT0: CMPD5 Mask                */
N
N#define PWM_CMPDAT1_CMP0_Pos             (0)                                               /*!< PWM_T::CMPDAT1: CMP0 Position             */
N#define PWM_CMPDAT1_CMP0_Msk             (0xfffful << PWM_CMPDAT1_CMP0_Pos)                /*!< PWM_T::CMPDAT1: CMP0 Mask                 */
N
N#define PWM_CMPDAT1_CMP1_Pos             (0)                                               /*!< PWM_T::CMPDAT1: CMP1 Position             */
N#define PWM_CMPDAT1_CMP1_Msk             (0xfffful << PWM_CMPDAT1_CMP1_Pos)                /*!< PWM_T::CMPDAT1: CMP1 Mask                 */
N
N#define PWM_CMPDAT1_CMP2_Pos             (0)                                               /*!< PWM_T::CMPDAT1: CMP2 Position             */
N#define PWM_CMPDAT1_CMP2_Msk             (0xfffful << PWM_CMPDAT1_CMP2_Pos)                /*!< PWM_T::CMPDAT1: CMP2 Mask                 */
N
N#define PWM_CMPDAT1_CMP3_Pos             (0)                                               /*!< PWM_T::CMPDAT1: CMP3 Position             */
N#define PWM_CMPDAT1_CMP3_Msk             (0xfffful << PWM_CMPDAT1_CMP3_Pos)                /*!< PWM_T::CMPDAT1: CMP3 Mask                 */
N
N#define PWM_CMPDAT1_CMP4_Pos             (0)                                               /*!< PWM_T::CMPDAT1: CMP4 Position             */
N#define PWM_CMPDAT1_CMP4_Msk             (0xfffful << PWM_CMPDAT1_CMP4_Pos)                /*!< PWM_T::CMPDAT1: CMP4 Mask                 */
N
N#define PWM_CMPDAT1_CMP5_Pos             (0)                                               /*!< PWM_T::CMPDAT1: CMP5 Position             */
N#define PWM_CMPDAT1_CMP5_Msk             (0xfffful << PWM_CMPDAT1_CMP5_Pos)                /*!< PWM_T::CMPDAT1: CMP5 Mask                 */
N
N#define PWM_CMPDAT1_CMPD0_Pos            (16)                                              /*!< PWM_T::CMPDAT1: CMPD0 Position            */
N#define PWM_CMPDAT1_CMPD0_Msk            (0xfffful << PWM_CMPDAT1_CMPD0_Pos)               /*!< PWM_T::CMPDAT1: CMPD0 Mask                */
N
N#define PWM_CMPDAT1_CMPD1_Pos            (16)                                              /*!< PWM_T::CMPDAT1: CMPD1 Position            */
N#define PWM_CMPDAT1_CMPD1_Msk            (0xfffful << PWM_CMPDAT1_CMPD1_Pos)               /*!< PWM_T::CMPDAT1: CMPD1 Mask                */
N
N#define PWM_CMPDAT1_CMPD2_Pos            (16)                                              /*!< PWM_T::CMPDAT1: CMPD2 Position            */
N#define PWM_CMPDAT1_CMPD2_Msk            (0xfffful << PWM_CMPDAT1_CMPD2_Pos)               /*!< PWM_T::CMPDAT1: CMPD2 Mask                */
N
N#define PWM_CMPDAT1_CMPD3_Pos            (16)                                              /*!< PWM_T::CMPDAT1: CMPD3 Position            */
N#define PWM_CMPDAT1_CMPD3_Msk            (0xfffful << PWM_CMPDAT1_CMPD3_Pos)               /*!< PWM_T::CMPDAT1: CMPD3 Mask                */
N
N#define PWM_CMPDAT1_CMPD4_Pos            (16)                                              /*!< PWM_T::CMPDAT1: CMPD4 Position            */
N#define PWM_CMPDAT1_CMPD4_Msk            (0xfffful << PWM_CMPDAT1_CMPD4_Pos)               /*!< PWM_T::CMPDAT1: CMPD4 Mask                */
N
N#define PWM_CMPDAT1_CMPD5_Pos            (16)                                              /*!< PWM_T::CMPDAT1: CMPD5 Position            */
N#define PWM_CMPDAT1_CMPD5_Msk            (0xfffful << PWM_CMPDAT1_CMPD5_Pos)               /*!< PWM_T::CMPDAT1: CMPD5 Mask                */
N
N#define PWM_CMPDAT2_CMP0_Pos             (0)                                               /*!< PWM_T::CMPDAT2: CMP0 Position             */
N#define PWM_CMPDAT2_CMP0_Msk             (0xfffful << PWM_CMPDAT2_CMP0_Pos)                /*!< PWM_T::CMPDAT2: CMP0 Mask                 */
N
N#define PWM_CMPDAT2_CMP1_Pos             (0)                                               /*!< PWM_T::CMPDAT2: CMP1 Position             */
N#define PWM_CMPDAT2_CMP1_Msk             (0xfffful << PWM_CMPDAT2_CMP1_Pos)                /*!< PWM_T::CMPDAT2: CMP1 Mask                 */
N
N#define PWM_CMPDAT2_CMP2_Pos             (0)                                               /*!< PWM_T::CMPDAT2: CMP2 Position             */
N#define PWM_CMPDAT2_CMP2_Msk             (0xfffful << PWM_CMPDAT2_CMP2_Pos)                /*!< PWM_T::CMPDAT2: CMP2 Mask                 */
N
N#define PWM_CMPDAT2_CMP3_Pos             (0)                                               /*!< PWM_T::CMPDAT2: CMP3 Position             */
N#define PWM_CMPDAT2_CMP3_Msk             (0xfffful << PWM_CMPDAT2_CMP3_Pos)                /*!< PWM_T::CMPDAT2: CMP3 Mask                 */
N
N#define PWM_CMPDAT2_CMP4_Pos             (0)                                               /*!< PWM_T::CMPDAT2: CMP4 Position             */
N#define PWM_CMPDAT2_CMP4_Msk             (0xfffful << PWM_CMPDAT2_CMP4_Pos)                /*!< PWM_T::CMPDAT2: CMP4 Mask                 */
N
N#define PWM_CMPDAT2_CMP5_Pos             (0)                                               /*!< PWM_T::CMPDAT2: CMP5 Position             */
N#define PWM_CMPDAT2_CMP5_Msk             (0xfffful << PWM_CMPDAT2_CMP5_Pos)                /*!< PWM_T::CMPDAT2: CMP5 Mask                 */
N
N#define PWM_CMPDAT2_CMPD0_Pos            (16)                                              /*!< PWM_T::CMPDAT2: CMPD0 Position            */
N#define PWM_CMPDAT2_CMPD0_Msk            (0xfffful << PWM_CMPDAT2_CMPD0_Pos)               /*!< PWM_T::CMPDAT2: CMPD0 Mask                */
N
N#define PWM_CMPDAT2_CMPD1_Pos            (16)                                              /*!< PWM_T::CMPDAT2: CMPD1 Position            */
N#define PWM_CMPDAT2_CMPD1_Msk            (0xfffful << PWM_CMPDAT2_CMPD1_Pos)               /*!< PWM_T::CMPDAT2: CMPD1 Mask                */
N
N#define PWM_CMPDAT2_CMPD2_Pos            (16)                                              /*!< PWM_T::CMPDAT2: CMPD2 Position            */
N#define PWM_CMPDAT2_CMPD2_Msk            (0xfffful << PWM_CMPDAT2_CMPD2_Pos)               /*!< PWM_T::CMPDAT2: CMPD2 Mask                */
N
N#define PWM_CMPDAT2_CMPD3_Pos            (16)                                              /*!< PWM_T::CMPDAT2: CMPD3 Position            */
N#define PWM_CMPDAT2_CMPD3_Msk            (0xfffful << PWM_CMPDAT2_CMPD3_Pos)               /*!< PWM_T::CMPDAT2: CMPD3 Mask                */
N
N#define PWM_CMPDAT2_CMPD4_Pos            (16)                                              /*!< PWM_T::CMPDAT2: CMPD4 Position            */
N#define PWM_CMPDAT2_CMPD4_Msk            (0xfffful << PWM_CMPDAT2_CMPD4_Pos)               /*!< PWM_T::CMPDAT2: CMPD4 Mask                */
N
N#define PWM_CMPDAT2_CMPD5_Pos            (16)                                              /*!< PWM_T::CMPDAT2: CMPD5 Position            */
N#define PWM_CMPDAT2_CMPD5_Msk            (0xfffful << PWM_CMPDAT2_CMPD5_Pos)               /*!< PWM_T::CMPDAT2: CMPD5 Mask                */
N
N#define PWM_CMPDAT3_CMP0_Pos             (0)                                               /*!< PWM_T::CMPDAT3: CMP0 Position             */
N#define PWM_CMPDAT3_CMP0_Msk             (0xfffful << PWM_CMPDAT3_CMP0_Pos)                /*!< PWM_T::CMPDAT3: CMP0 Mask                 */
N
N#define PWM_CMPDAT3_CMP1_Pos             (0)                                               /*!< PWM_T::CMPDAT3: CMP1 Position             */
N#define PWM_CMPDAT3_CMP1_Msk             (0xfffful << PWM_CMPDAT3_CMP1_Pos)                /*!< PWM_T::CMPDAT3: CMP1 Mask                 */
N
N#define PWM_CMPDAT3_CMP2_Pos             (0)                                               /*!< PWM_T::CMPDAT3: CMP2 Position             */
N#define PWM_CMPDAT3_CMP2_Msk             (0xfffful << PWM_CMPDAT3_CMP2_Pos)                /*!< PWM_T::CMPDAT3: CMP2 Mask                 */
N
N#define PWM_CMPDAT3_CMP3_Pos             (0)                                               /*!< PWM_T::CMPDAT3: CMP3 Position             */
N#define PWM_CMPDAT3_CMP3_Msk             (0xfffful << PWM_CMPDAT3_CMP3_Pos)                /*!< PWM_T::CMPDAT3: CMP3 Mask                 */
N
N#define PWM_CMPDAT3_CMP4_Pos             (0)                                               /*!< PWM_T::CMPDAT3: CMP4 Position             */
N#define PWM_CMPDAT3_CMP4_Msk             (0xfffful << PWM_CMPDAT3_CMP4_Pos)                /*!< PWM_T::CMPDAT3: CMP4 Mask                 */
N
N#define PWM_CMPDAT3_CMP5_Pos             (0)                                               /*!< PWM_T::CMPDAT3: CMP5 Position             */
N#define PWM_CMPDAT3_CMP5_Msk             (0xfffful << PWM_CMPDAT3_CMP5_Pos)                /*!< PWM_T::CMPDAT3: CMP5 Mask                 */
N
N#define PWM_CMPDAT3_CMPD0_Pos            (16)                                              /*!< PWM_T::CMPDAT3: CMPD0 Position            */
N#define PWM_CMPDAT3_CMPD0_Msk            (0xfffful << PWM_CMPDAT3_CMPD0_Pos)               /*!< PWM_T::CMPDAT3: CMPD0 Mask                */
N
N#define PWM_CMPDAT3_CMPD1_Pos            (16)                                              /*!< PWM_T::CMPDAT3: CMPD1 Position            */
N#define PWM_CMPDAT3_CMPD1_Msk            (0xfffful << PWM_CMPDAT3_CMPD1_Pos)               /*!< PWM_T::CMPDAT3: CMPD1 Mask                */
N
N#define PWM_CMPDAT3_CMPD2_Pos            (16)                                              /*!< PWM_T::CMPDAT3: CMPD2 Position            */
N#define PWM_CMPDAT3_CMPD2_Msk            (0xfffful << PWM_CMPDAT3_CMPD2_Pos)               /*!< PWM_T::CMPDAT3: CMPD2 Mask                */
N
N#define PWM_CMPDAT3_CMPD3_Pos            (16)                                              /*!< PWM_T::CMPDAT3: CMPD3 Position            */
N#define PWM_CMPDAT3_CMPD3_Msk            (0xfffful << PWM_CMPDAT3_CMPD3_Pos)               /*!< PWM_T::CMPDAT3: CMPD3 Mask                */
N
N#define PWM_CMPDAT3_CMPD4_Pos            (16)                                              /*!< PWM_T::CMPDAT3: CMPD4 Position            */
N#define PWM_CMPDAT3_CMPD4_Msk            (0xfffful << PWM_CMPDAT3_CMPD4_Pos)               /*!< PWM_T::CMPDAT3: CMPD4 Mask                */
N
N#define PWM_CMPDAT3_CMPD5_Pos            (16)                                              /*!< PWM_T::CMPDAT3: CMPD5 Position            */
N#define PWM_CMPDAT3_CMPD5_Msk            (0xfffful << PWM_CMPDAT3_CMPD5_Pos)               /*!< PWM_T::CMPDAT3: CMPD5 Mask                */
N
N#define PWM_CMPDAT4_CMP0_Pos             (0)                                               /*!< PWM_T::CMPDAT4: CMP0 Position             */
N#define PWM_CMPDAT4_CMP0_Msk             (0xfffful << PWM_CMPDAT4_CMP0_Pos)                /*!< PWM_T::CMPDAT4: CMP0 Mask                 */
N
N#define PWM_CMPDAT4_CMP1_Pos             (0)                                               /*!< PWM_T::CMPDAT4: CMP1 Position             */
N#define PWM_CMPDAT4_CMP1_Msk             (0xfffful << PWM_CMPDAT4_CMP1_Pos)                /*!< PWM_T::CMPDAT4: CMP1 Mask                 */
N
N#define PWM_CMPDAT4_CMP2_Pos             (0)                                               /*!< PWM_T::CMPDAT4: CMP2 Position             */
N#define PWM_CMPDAT4_CMP2_Msk             (0xfffful << PWM_CMPDAT4_CMP2_Pos)                /*!< PWM_T::CMPDAT4: CMP2 Mask                 */
N
N#define PWM_CMPDAT4_CMP3_Pos             (0)                                               /*!< PWM_T::CMPDAT4: CMP3 Position             */
N#define PWM_CMPDAT4_CMP3_Msk             (0xfffful << PWM_CMPDAT4_CMP3_Pos)                /*!< PWM_T::CMPDAT4: CMP3 Mask                 */
N
N#define PWM_CMPDAT4_CMP4_Pos             (0)                                               /*!< PWM_T::CMPDAT4: CMP4 Position             */
N#define PWM_CMPDAT4_CMP4_Msk             (0xfffful << PWM_CMPDAT4_CMP4_Pos)                /*!< PWM_T::CMPDAT4: CMP4 Mask                 */
N
N#define PWM_CMPDAT4_CMP5_Pos             (0)                                               /*!< PWM_T::CMPDAT4: CMP5 Position             */
N#define PWM_CMPDAT4_CMP5_Msk             (0xfffful << PWM_CMPDAT4_CMP5_Pos)                /*!< PWM_T::CMPDAT4: CMP5 Mask                 */
N
N#define PWM_CMPDAT4_CMPD0_Pos            (16)                                              /*!< PWM_T::CMPDAT4: CMPD0 Position            */
N#define PWM_CMPDAT4_CMPD0_Msk            (0xfffful << PWM_CMPDAT4_CMPD0_Pos)               /*!< PWM_T::CMPDAT4: CMPD0 Mask                */
N
N#define PWM_CMPDAT4_CMPD1_Pos            (16)                                              /*!< PWM_T::CMPDAT4: CMPD1 Position            */
N#define PWM_CMPDAT4_CMPD1_Msk            (0xfffful << PWM_CMPDAT4_CMPD1_Pos)               /*!< PWM_T::CMPDAT4: CMPD1 Mask                */
N
N#define PWM_CMPDAT4_CMPD2_Pos            (16)                                              /*!< PWM_T::CMPDAT4: CMPD2 Position            */
N#define PWM_CMPDAT4_CMPD2_Msk            (0xfffful << PWM_CMPDAT4_CMPD2_Pos)               /*!< PWM_T::CMPDAT4: CMPD2 Mask                */
N
N#define PWM_CMPDAT4_CMPD3_Pos            (16)                                              /*!< PWM_T::CMPDAT4: CMPD3 Position            */
N#define PWM_CMPDAT4_CMPD3_Msk            (0xfffful << PWM_CMPDAT4_CMPD3_Pos)               /*!< PWM_T::CMPDAT4: CMPD3 Mask                */
N
N#define PWM_CMPDAT4_CMPD4_Pos            (16)                                              /*!< PWM_T::CMPDAT4: CMPD4 Position            */
N#define PWM_CMPDAT4_CMPD4_Msk            (0xfffful << PWM_CMPDAT4_CMPD4_Pos)               /*!< PWM_T::CMPDAT4: CMPD4 Mask                */
N
N#define PWM_CMPDAT4_CMPD5_Pos            (16)                                              /*!< PWM_T::CMPDAT4: CMPD5 Position            */
N#define PWM_CMPDAT4_CMPD5_Msk            (0xfffful << PWM_CMPDAT4_CMPD5_Pos)               /*!< PWM_T::CMPDAT4: CMPD5 Mask                */
N
N#define PWM_CMPDAT5_CMP0_Pos             (0)                                               /*!< PWM_T::CMPDAT5: CMP0 Position             */
N#define PWM_CMPDAT5_CMP0_Msk             (0xfffful << PWM_CMPDAT5_CMP0_Pos)                /*!< PWM_T::CMPDAT5: CMP0 Mask                 */
N
N#define PWM_CMPDAT5_CMP1_Pos             (0)                                               /*!< PWM_T::CMPDAT5: CMP1 Position             */
N#define PWM_CMPDAT5_CMP1_Msk             (0xfffful << PWM_CMPDAT5_CMP1_Pos)                /*!< PWM_T::CMPDAT5: CMP1 Mask                 */
N
N#define PWM_CMPDAT5_CMP2_Pos             (0)                                               /*!< PWM_T::CMPDAT5: CMP2 Position             */
N#define PWM_CMPDAT5_CMP2_Msk             (0xfffful << PWM_CMPDAT5_CMP2_Pos)                /*!< PWM_T::CMPDAT5: CMP2 Mask                 */
N
N#define PWM_CMPDAT5_CMP3_Pos             (0)                                               /*!< PWM_T::CMPDAT5: CMP3 Position             */
N#define PWM_CMPDAT5_CMP3_Msk             (0xfffful << PWM_CMPDAT5_CMP3_Pos)                /*!< PWM_T::CMPDAT5: CMP3 Mask                 */
N
N#define PWM_CMPDAT5_CMP4_Pos             (0)                                               /*!< PWM_T::CMPDAT5: CMP4 Position             */
N#define PWM_CMPDAT5_CMP4_Msk             (0xfffful << PWM_CMPDAT5_CMP4_Pos)                /*!< PWM_T::CMPDAT5: CMP4 Mask                 */
N
N#define PWM_CMPDAT5_CMP5_Pos             (0)                                               /*!< PWM_T::CMPDAT5: CMP5 Position             */
N#define PWM_CMPDAT5_CMP5_Msk             (0xfffful << PWM_CMPDAT5_CMP5_Pos)                /*!< PWM_T::CMPDAT5: CMP5 Mask                 */
N
N#define PWM_CMPDAT5_CMPD0_Pos            (16)                                              /*!< PWM_T::CMPDAT5: CMPD0 Position            */
N#define PWM_CMPDAT5_CMPD0_Msk            (0xfffful << PWM_CMPDAT5_CMPD0_Pos)               /*!< PWM_T::CMPDAT5: CMPD0 Mask                */
N
N#define PWM_CMPDAT5_CMPD1_Pos            (16)                                              /*!< PWM_T::CMPDAT5: CMPD1 Position            */
N#define PWM_CMPDAT5_CMPD1_Msk            (0xfffful << PWM_CMPDAT5_CMPD1_Pos)               /*!< PWM_T::CMPDAT5: CMPD1 Mask                */
N
N#define PWM_CMPDAT5_CMPD2_Pos            (16)                                              /*!< PWM_T::CMPDAT5: CMPD2 Position            */
N#define PWM_CMPDAT5_CMPD2_Msk            (0xfffful << PWM_CMPDAT5_CMPD2_Pos)               /*!< PWM_T::CMPDAT5: CMPD2 Mask                */
N
N#define PWM_CMPDAT5_CMPD3_Pos            (16)                                              /*!< PWM_T::CMPDAT5: CMPD3 Position            */
N#define PWM_CMPDAT5_CMPD3_Msk            (0xfffful << PWM_CMPDAT5_CMPD3_Pos)               /*!< PWM_T::CMPDAT5: CMPD3 Mask                */
N
N#define PWM_CMPDAT5_CMPD4_Pos            (16)                                              /*!< PWM_T::CMPDAT5: CMPD4 Position            */
N#define PWM_CMPDAT5_CMPD4_Msk            (0xfffful << PWM_CMPDAT5_CMPD4_Pos)               /*!< PWM_T::CMPDAT5: CMPD4 Mask                */
N
N#define PWM_CMPDAT5_CMPD5_Pos            (16)                                              /*!< PWM_T::CMPDAT5: CMPD5 Position            */
N#define PWM_CMPDAT5_CMPD5_Msk            (0xfffful << PWM_CMPDAT5_CMPD5_Pos)               /*!< PWM_T::CMPDAT5: CMPD5 Mask                */
N
N#define PWM_INTEN_ZIEN0_Pos              (0)                                               /*!< PWM_T::INTEN: ZIEN0 Position              */
N#define PWM_INTEN_ZIEN0_Msk              (0x1ul << PWM_INTEN_ZIEN0_Pos)                    /*!< PWM_T::INTEN: ZIEN0 Mask                  */
N
N#define PWM_INTEN_ZIEN1_Pos              (1)                                               /*!< PWM_T::INTEN: ZIEN1 Position              */
N#define PWM_INTEN_ZIEN1_Msk              (0x1ul << PWM_INTEN_ZIEN1_Pos)                    /*!< PWM_T::INTEN: ZIEN1 Mask                  */
N
N#define PWM_INTEN_ZIEN2_Pos              (2)                                               /*!< PWM_T::INTEN: ZIEN2 Position              */
N#define PWM_INTEN_ZIEN2_Msk              (0x1ul << PWM_INTEN_ZIEN2_Pos)                    /*!< PWM_T::INTEN: ZIEN2 Mask                  */
N
N#define PWM_INTEN_ZIEN3_Pos              (3)                                               /*!< PWM_T::INTEN: ZIEN3 Position              */
N#define PWM_INTEN_ZIEN3_Msk              (0x1ul << PWM_INTEN_ZIEN3_Pos)                    /*!< PWM_T::INTEN: ZIEN3 Mask                  */
N
N#define PWM_INTEN_ZIEN4_Pos              (4)                                               /*!< PWM_T::INTEN: ZIEN4 Position              */
N#define PWM_INTEN_ZIEN4_Msk              (0x1ul << PWM_INTEN_ZIEN4_Pos)                    /*!< PWM_T::INTEN: ZIEN4 Mask                  */
N
N#define PWM_INTEN_ZIEN5_Pos              (5)                                               /*!< PWM_T::INTEN: ZIEN5 Position              */
N#define PWM_INTEN_ZIEN5_Msk              (0x1ul << PWM_INTEN_ZIEN5_Pos)                    /*!< PWM_T::INTEN: ZIEN5 Mask                  */
N
N#define PWM_INTEN_CMPDIEN0_Pos           (8)                                               /*!< PWM_T::INTEN: CMPDIEN0 Position           */
N#define PWM_INTEN_CMPDIEN0_Msk           (0x1ul << PWM_INTEN_CMPDIEN0_Pos)                 /*!< PWM_T::INTEN: CMPDIEN0 Mask               */
N
N#define PWM_INTEN_CMPDIEN1_Pos           (9)                                               /*!< PWM_T::INTEN: CMPDIEN1 Position           */
N#define PWM_INTEN_CMPDIEN1_Msk           (0x1ul << PWM_INTEN_CMPDIEN1_Pos)                 /*!< PWM_T::INTEN: CMPDIEN1 Mask               */
N
N#define PWM_INTEN_CMPDIEN2_Pos           (10)                                              /*!< PWM_T::INTEN: CMPDIEN2 Position           */
N#define PWM_INTEN_CMPDIEN2_Msk           (0x1ul << PWM_INTEN_CMPDIEN2_Pos)                 /*!< PWM_T::INTEN: CMPDIEN2 Mask               */
N
N#define PWM_INTEN_CMPDIEN3_Pos           (11)                                              /*!< PWM_T::INTEN: CMPDIEN3 Position           */
N#define PWM_INTEN_CMPDIEN3_Msk           (0x1ul << PWM_INTEN_CMPDIEN3_Pos)                 /*!< PWM_T::INTEN: CMPDIEN3 Mask               */
N
N#define PWM_INTEN_CMPDIEN4_Pos           (12)                                              /*!< PWM_T::INTEN: CMPDIEN4 Position           */
N#define PWM_INTEN_CMPDIEN4_Msk           (0x1ul << PWM_INTEN_CMPDIEN4_Pos)                 /*!< PWM_T::INTEN: CMPDIEN4 Mask               */
N
N#define PWM_INTEN_CMPDIEN5_Pos           (13)                                              /*!< PWM_T::INTEN: CMPDIEN5 Position           */
N#define PWM_INTEN_CMPDIEN5_Msk           (0x1ul << PWM_INTEN_CMPDIEN5_Pos)                 /*!< PWM_T::INTEN: CMPDIEN5 Mask               */
N
N#define PWM_INTEN_BRKIEN_Pos             (16)                                              /*!< PWM_T::INTEN: BRKIEN Position             */
N#define PWM_INTEN_BRKIEN_Msk             (0x1ul << PWM_INTEN_BRKIEN_Pos)                   /*!< PWM_T::INTEN: BRKIEN Mask                 */
N
N#define PWM_INTEN_PINTTYPE_Pos           (17)                                              /*!< PWM_T::INTEN: PINTTYPE Position           */
N#define PWM_INTEN_PINTTYPE_Msk           (0x1ul << PWM_INTEN_PINTTYPE_Pos)                 /*!< PWM_T::INTEN: PINTTYPE Mask               */
N
N#define PWM_INTEN_PIEN0_Pos              (18)                                              /*!< PWM_T::INTEN: PIEN0 Position              */
N#define PWM_INTEN_PIEN0_Msk              (0x1ul << PWM_INTEN_PIEN0_Pos)                    /*!< PWM_T::INTEN: PIEN0 Mask                  */
N
N#define PWM_INTEN_PIEN1_Pos              (19)                                              /*!< PWM_T::INTEN: PIEN1 Position              */
N#define PWM_INTEN_PIEN1_Msk              (0x1ul << PWM_INTEN_PIEN1_Pos)                    /*!< PWM_T::INTEN: PIEN1 Mask                  */
N
N#define PWM_INTEN_PIEN2_Pos              (20)                                              /*!< PWM_T::INTEN: PIEN2 Position              */
N#define PWM_INTEN_PIEN2_Msk              (0x1ul << PWM_INTEN_PIEN2_Pos)                    /*!< PWM_T::INTEN: PIEN2 Mask                  */
N
N#define PWM_INTEN_PIEN3_Pos              (21)                                              /*!< PWM_T::INTEN: PIEN3 Position              */
N#define PWM_INTEN_PIEN3_Msk              (0x1ul << PWM_INTEN_PIEN3_Pos)                    /*!< PWM_T::INTEN: PIEN3 Mask                  */
N
N#define PWM_INTEN_PIEN4_Pos              (22)                                              /*!< PWM_T::INTEN: PIEN4 Position              */
N#define PWM_INTEN_PIEN4_Msk              (0x1ul << PWM_INTEN_PIEN4_Pos)                    /*!< PWM_T::INTEN: PIEN4 Mask                  */
N
N#define PWM_INTEN_PIEN5_Pos              (23)                                              /*!< PWM_T::INTEN: PIEN5 Position              */
N#define PWM_INTEN_PIEN5_Msk              (0x1ul << PWM_INTEN_PIEN5_Pos)                    /*!< PWM_T::INTEN: PIEN5 Mask                  */
N
N#define PWM_INTEN_CMPUIEN0_Pos           (24)                                              /*!< PWM_T::INTEN: CMPUIEN0 Position           */
N#define PWM_INTEN_CMPUIEN0_Msk           (0x1ul << PWM_INTEN_CMPUIEN0_Pos)                 /*!< PWM_T::INTEN: CMPUIEN0 Mask               */
N
N#define PWM_INTEN_CMPUIEN1_Pos           (25)                                              /*!< PWM_T::INTEN: CMPUIEN1 Position           */
N#define PWM_INTEN_CMPUIEN1_Msk           (0x1ul << PWM_INTEN_CMPUIEN1_Pos)                 /*!< PWM_T::INTEN: CMPUIEN1 Mask               */
N
N#define PWM_INTEN_CMPUIEN2_Pos           (26)                                              /*!< PWM_T::INTEN: CMPUIEN2 Position           */
N#define PWM_INTEN_CMPUIEN2_Msk           (0x1ul << PWM_INTEN_CMPUIEN2_Pos)                 /*!< PWM_T::INTEN: CMPUIEN2 Mask               */
N
N#define PWM_INTEN_CMPUIEN3_Pos           (27)                                              /*!< PWM_T::INTEN: CMPUIEN3 Position           */
N#define PWM_INTEN_CMPUIEN3_Msk           (0x1ul << PWM_INTEN_CMPUIEN3_Pos)                 /*!< PWM_T::INTEN: CMPUIEN3 Mask               */
N
N#define PWM_INTEN_CMPUIEN4_Pos           (28)                                              /*!< PWM_T::INTEN: CMPUIEN4 Position           */
N#define PWM_INTEN_CMPUIEN4_Msk           (0x1ul << PWM_INTEN_CMPUIEN4_Pos)                 /*!< PWM_T::INTEN: CMPUIEN4 Mask               */
N
N#define PWM_INTEN_CMPUIEN5_Pos           (29)                                              /*!< PWM_T::INTEN: CMPUIEN5 Position           */
N#define PWM_INTEN_CMPUIEN5_Msk           (0x1ul << PWM_INTEN_CMPUIEN5_Pos)                 /*!< PWM_T::INTEN: CMPUIEN5 Mask               */
N
N#define PWM_INTSTS_ZIF0_Pos              (0)                                               /*!< PWM_T::INTSTS: ZIF0 Position              */
N#define PWM_INTSTS_ZIF0_Msk              (0x1ul << PWM_INTSTS_ZIF0_Pos)                    /*!< PWM_T::INTSTS: ZIF0 Mask                  */
N
N#define PWM_INTSTS_ZIF1_Pos              (1)                                               /*!< PWM_T::INTSTS: ZIF1 Position              */
N#define PWM_INTSTS_ZIF1_Msk              (0x1ul << PWM_INTSTS_ZIF1_Pos)                    /*!< PWM_T::INTSTS: ZIF1 Mask                  */
N
N#define PWM_INTSTS_ZIF2_Pos              (2)                                               /*!< PWM_T::INTSTS: ZIF2 Position              */
N#define PWM_INTSTS_ZIF2_Msk              (0x1ul << PWM_INTSTS_ZIF2_Pos)                    /*!< PWM_T::INTSTS: ZIF2 Mask                  */
N
N#define PWM_INTSTS_ZIF3_Pos              (3)                                               /*!< PWM_T::INTSTS: ZIF3 Position              */
N#define PWM_INTSTS_ZIF3_Msk              (0x1ul << PWM_INTSTS_ZIF3_Pos)                    /*!< PWM_T::INTSTS: ZIF3 Mask                  */
N
N#define PWM_INTSTS_ZIF4_Pos              (4)                                               /*!< PWM_T::INTSTS: ZIF4 Position              */
N#define PWM_INTSTS_ZIF4_Msk              (0x1ul << PWM_INTSTS_ZIF4_Pos)                    /*!< PWM_T::INTSTS: ZIF4 Mask                  */
N
N#define PWM_INTSTS_ZIF5_Pos              (5)                                               /*!< PWM_T::INTSTS: ZIF5 Position              */
N#define PWM_INTSTS_ZIF5_Msk              (0x1ul << PWM_INTSTS_ZIF5_Pos)                    /*!< PWM_T::INTSTS: ZIF5 Mask                  */
N
N#define PWM_INTSTS_CMPDIF0_Pos           (8)                                               /*!< PWM_T::INTSTS: CMPDIF0 Position           */
N#define PWM_INTSTS_CMPDIF0_Msk           (0x1ul << PWM_INTSTS_CMPDIF0_Pos)                 /*!< PWM_T::INTSTS: CMPDIF0 Mask               */
N
N#define PWM_INTSTS_CMPDIF1_Pos           (9)                                               /*!< PWM_T::INTSTS: CMPDIF1 Position           */
N#define PWM_INTSTS_CMPDIF1_Msk           (0x1ul << PWM_INTSTS_CMPDIF1_Pos)                 /*!< PWM_T::INTSTS: CMPDIF1 Mask               */
N
N#define PWM_INTSTS_CMPDIF2_Pos           (10)                                              /*!< PWM_T::INTSTS: CMPDIF2 Position           */
N#define PWM_INTSTS_CMPDIF2_Msk           (0x1ul << PWM_INTSTS_CMPDIF2_Pos)                 /*!< PWM_T::INTSTS: CMPDIF2 Mask               */
N
N#define PWM_INTSTS_CMPDIF3_Pos           (11)                                              /*!< PWM_T::INTSTS: CMPDIF3 Position           */
N#define PWM_INTSTS_CMPDIF3_Msk           (0x1ul << PWM_INTSTS_CMPDIF3_Pos)                 /*!< PWM_T::INTSTS: CMPDIF3 Mask               */
N
N#define PWM_INTSTS_CMPDIF4_Pos           (12)                                              /*!< PWM_T::INTSTS: CMPDIF4 Position           */
N#define PWM_INTSTS_CMPDIF4_Msk           (0x1ul << PWM_INTSTS_CMPDIF4_Pos)                 /*!< PWM_T::INTSTS: CMPDIF4 Mask               */
N
N#define PWM_INTSTS_CMPDIF5_Pos           (13)                                              /*!< PWM_T::INTSTS: CMPDIF5 Position           */
N#define PWM_INTSTS_CMPDIF5_Msk           (0x1ul << PWM_INTSTS_CMPDIF5_Pos)                 /*!< PWM_T::INTSTS: CMPDIF5 Mask               */
N
N#define PWM_INTSTS_BRKIF0_Pos            (16)                                              /*!< PWM_T::INTSTS: BRKIF0 Position            */
N#define PWM_INTSTS_BRKIF0_Msk            (0x1ul << PWM_INTSTS_BRKIF0_Pos)                  /*!< PWM_T::INTSTS: BRKIF0 Mask                */
N
N#define PWM_INTSTS_BRKIF1_Pos            (17)                                              /*!< PWM_T::INTSTS: BRKIF1 Position            */
N#define PWM_INTSTS_BRKIF1_Msk            (0x1ul << PWM_INTSTS_BRKIF1_Pos)                  /*!< PWM_T::INTSTS: BRKIF1 Mask                */
N
N#define PWM_INTSTS_PIF0_Pos              (18)                                              /*!< PWM_T::INTSTS: PIF0 Position              */
N#define PWM_INTSTS_PIF0_Msk              (0x1ul << PWM_INTSTS_PIF0_Pos)                    /*!< PWM_T::INTSTS: PIF0 Mask                  */
N
N#define PWM_INTSTS_PIF1_Pos              (19)                                              /*!< PWM_T::INTSTS: PIF1 Position              */
N#define PWM_INTSTS_PIF1_Msk              (0x1ul << PWM_INTSTS_PIF1_Pos)                    /*!< PWM_T::INTSTS: PIF1 Mask                  */
N
N#define PWM_INTSTS_PIF2_Pos              (20)                                              /*!< PWM_T::INTSTS: PIF2 Position              */
N#define PWM_INTSTS_PIF2_Msk              (0x1ul << PWM_INTSTS_PIF2_Pos)                    /*!< PWM_T::INTSTS: PIF2 Mask                  */
N
N#define PWM_INTSTS_PIF3_Pos              (21)                                              /*!< PWM_T::INTSTS: PIF3 Position              */
N#define PWM_INTSTS_PIF3_Msk              (0x1ul << PWM_INTSTS_PIF3_Pos)                    /*!< PWM_T::INTSTS: PIF3 Mask                  */
N
N#define PWM_INTSTS_PIF4_Pos              (22)                                              /*!< PWM_T::INTSTS: PIF4 Position              */
N#define PWM_INTSTS_PIF4_Msk              (0x1ul << PWM_INTSTS_PIF4_Pos)                    /*!< PWM_T::INTSTS: PIF4 Mask                  */
N
N#define PWM_INTSTS_PIF5_Pos              (23)                                              /*!< PWM_T::INTSTS: PIF5 Position              */
N#define PWM_INTSTS_PIF5_Msk              (0x1ul << PWM_INTSTS_PIF5_Pos)                    /*!< PWM_T::INTSTS: PIF5 Mask                  */
N
N#define PWM_INTSTS_CMPUIF0_Pos           (24)                                              /*!< PWM_T::INTSTS: CMPUIF0 Position           */
N#define PWM_INTSTS_CMPUIF0_Msk           (0x1ul << PWM_INTSTS_CMPUIF0_Pos)                 /*!< PWM_T::INTSTS: CMPUIF0 Mask               */
N
N#define PWM_INTSTS_CMPUIF1_Pos           (25)                                              /*!< PWM_T::INTSTS: CMPUIF1 Position           */
N#define PWM_INTSTS_CMPUIF1_Msk           (0x1ul << PWM_INTSTS_CMPUIF1_Pos)                 /*!< PWM_T::INTSTS: CMPUIF1 Mask               */
N
N#define PWM_INTSTS_CMPUIF2_Pos           (26)                                              /*!< PWM_T::INTSTS: CMPUIF2 Position           */
N#define PWM_INTSTS_CMPUIF2_Msk           (0x1ul << PWM_INTSTS_CMPUIF2_Pos)                 /*!< PWM_T::INTSTS: CMPUIF2 Mask               */
N
N#define PWM_INTSTS_CMPUIF3_Pos           (27)                                              /*!< PWM_T::INTSTS: CMPUIF3 Position           */
N#define PWM_INTSTS_CMPUIF3_Msk           (0x1ul << PWM_INTSTS_CMPUIF3_Pos)                 /*!< PWM_T::INTSTS: CMPUIF3 Mask               */
N
N#define PWM_INTSTS_CMPUIF4_Pos           (28)                                              /*!< PWM_T::INTSTS: CMPUIF4 Position           */
N#define PWM_INTSTS_CMPUIF4_Msk           (0x1ul << PWM_INTSTS_CMPUIF4_Pos)                 /*!< PWM_T::INTSTS: CMPUIF4 Mask               */
N
N#define PWM_INTSTS_CMPUIF5_Pos           (29)                                              /*!< PWM_T::INTSTS: CMPUIF5 Position           */
N#define PWM_INTSTS_CMPUIF5_Msk           (0x1ul << PWM_INTSTS_CMPUIF5_Pos)                 /*!< PWM_T::INTSTS: CMPUIF5 Mask               */
N
N#define PWM_POEN_POEN0_Pos               (0)                                               /*!< PWM_T::POEN: POEN0 Position               */
N#define PWM_POEN_POEN0_Msk               (0x1ul << PWM_POEN_POEN0_Pos)                     /*!< PWM_T::POEN: POEN0 Mask                   */
N
N#define PWM_POEN_POEN1_Pos               (1)                                               /*!< PWM_T::POEN: POEN1 Position               */
N#define PWM_POEN_POEN1_Msk               (0x1ul << PWM_POEN_POEN1_Pos)                     /*!< PWM_T::POEN: POEN1 Mask                   */
N
N#define PWM_POEN_POEN2_Pos               (2)                                               /*!< PWM_T::POEN: POEN2 Position               */
N#define PWM_POEN_POEN2_Msk               (0x1ul << PWM_POEN_POEN2_Pos)                     /*!< PWM_T::POEN: POEN2 Mask                   */
N
N#define PWM_POEN_POEN3_Pos               (3)                                               /*!< PWM_T::POEN: POEN3 Position               */
N#define PWM_POEN_POEN3_Msk               (0x1ul << PWM_POEN_POEN3_Pos)                     /*!< PWM_T::POEN: POEN3 Mask                   */
N
N#define PWM_POEN_POEN4_Pos               (4)                                               /*!< PWM_T::POEN: POEN4 Position               */
N#define PWM_POEN_POEN4_Msk               (0x1ul << PWM_POEN_POEN4_Pos)                     /*!< PWM_T::POEN: POEN4 Mask                   */
N
N#define PWM_POEN_POEN5_Pos               (5)                                               /*!< PWM_T::POEN: POEN5 Position               */
N#define PWM_POEN_POEN5_Msk               (0x1ul << PWM_POEN_POEN5_Pos)                     /*!< PWM_T::POEN: POEN5 Mask                   */
N
N#define PWM_BRKCTL_BRK0EN_Pos            (0)                                               /*!< PWM_T::BRKCTL: BRK0EN Position            */
N#define PWM_BRKCTL_BRK0EN_Msk            (0x1ul << PWM_BRKCTL_BRK0EN_Pos)                  /*!< PWM_T::BRKCTL: BRK0EN Mask                */
N
N#define PWM_BRKCTL_BRK1EN_Pos            (1)                                               /*!< PWM_T::BRKCTL: BRK1EN Position            */
N#define PWM_BRKCTL_BRK1EN_Msk            (0x1ul << PWM_BRKCTL_BRK1EN_Pos)                  /*!< PWM_T::BRKCTL: BRK1EN Mask                */
N
N#define PWM_BRKCTL_BRK0SEL_Pos           (2)                                               /*!< PWM_T::BRKCTL: BRK0SEL Position           */
N#define PWM_BRKCTL_BRK0SEL_Msk           (0x1ul << PWM_BRKCTL_BRK0SEL_Pos)                 /*!< PWM_T::BRKCTL: BRK0SEL Mask               */
N
N#define PWM_BRKCTL_BRK1SEL_Pos           (3)                                               /*!< PWM_T::BRKCTL: BRK1SEL Position           */
N#define PWM_BRKCTL_BRK1SEL_Msk           (0x1ul << PWM_BRKCTL_BRK1SEL_Pos)                 /*!< PWM_T::BRKCTL: BRK1SEL Mask               */
N
N#define PWM_BRKCTL_BRKSTS_Pos            (7)                                               /*!< PWM_T::BRKCTL: BRKSTS Position            */
N#define PWM_BRKCTL_BRKSTS_Msk            (0x1ul << PWM_BRKCTL_BRKSTS_Pos)                  /*!< PWM_T::BRKCTL: BRKSTS Mask                */
N
N#define PWM_BRKCTL_BRKACT_Pos            (8)                                               /*!< PWM_T::BRKCTL: BRKACT Position            */
N#define PWM_BRKCTL_BRKACT_Msk            (0x1ul << PWM_BRKCTL_BRKACT_Pos)                  /*!< PWM_T::BRKCTL: BRKACT Mask                */
N
N#define PWM_BRKCTL_SWBRK_Pos             (9)                                               /*!< PWM_T::BRKCTL: SWBRK Position             */
N#define PWM_BRKCTL_SWBRK_Msk             (0x1ul << PWM_BRKCTL_SWBRK_Pos)                   /*!< PWM_T::BRKCTL: SWBRK Mask                 */
N
N#define PWM_BRKCTL_BKOD0_Pos             (24)                                              /*!< PWM_T::BRKCTL: BKOD0 Position             */
N#define PWM_BRKCTL_BKOD0_Msk             (0x1ul << PWM_BRKCTL_BKOD0_Pos)                   /*!< PWM_T::BRKCTL: BKOD0 Mask                 */
N
N#define PWM_BRKCTL_BKOD1_Pos             (25)                                              /*!< PWM_T::BRKCTL: BKOD1 Position             */
N#define PWM_BRKCTL_BKOD1_Msk             (0x1ul << PWM_BRKCTL_BKOD1_Pos)                   /*!< PWM_T::BRKCTL: BKOD1 Mask                 */
N
N#define PWM_BRKCTL_BKOD2_Pos             (26)                                              /*!< PWM_T::BRKCTL: BKOD2 Position             */
N#define PWM_BRKCTL_BKOD2_Msk             (0x1ul << PWM_BRKCTL_BKOD2_Pos)                   /*!< PWM_T::BRKCTL: BKOD2 Mask                 */
N
N#define PWM_BRKCTL_BKOD3_Pos             (27)                                              /*!< PWM_T::BRKCTL: BKOD3 Position             */
N#define PWM_BRKCTL_BKOD3_Msk             (0x1ul << PWM_BRKCTL_BKOD3_Pos)                   /*!< PWM_T::BRKCTL: BKOD3 Mask                 */
N
N#define PWM_BRKCTL_BKOD4_Pos             (28)                                              /*!< PWM_T::BRKCTL: BKOD4 Position             */
N#define PWM_BRKCTL_BKOD4_Msk             (0x1ul << PWM_BRKCTL_BKOD4_Pos)                   /*!< PWM_T::BRKCTL: BKOD4 Mask                 */
N
N#define PWM_BRKCTL_BKOD5_Pos             (29)                                              /*!< PWM_T::BRKCTL: BKOD5 Position             */
N#define PWM_BRKCTL_BKOD5_Msk             (0x1ul << PWM_BRKCTL_BKOD5_Pos)                   /*!< PWM_T::BRKCTL: BKOD5 Mask                 */
N
N#define PWM_BRKCTL_D6BKOD_Pos            (30)                                              /*!< PWM_T::BRKCTL: D6BKOD Position            */
N#define PWM_BRKCTL_D6BKOD_Msk            (0x1ul << PWM_BRKCTL_D6BKOD_Pos)                  /*!< PWM_T::BRKCTL: D6BKOD Mask                */
N
N#define PWM_BRKCTL_D7BKOD_Pos            (31)                                              /*!< PWM_T::BRKCTL: D7BKOD Position            */
N#define PWM_BRKCTL_D7BKOD_Msk            (0x1ul << PWM_BRKCTL_D7BKOD_Pos)                  /*!< PWM_T::BRKCTL: D7BKOD Mask                */
N
N#define PWM_DTCTL_DTI01_Pos              (0)                                               /*!< PWM_T::DTCTL: DTI01 Position              */
N#define PWM_DTCTL_DTI01_Msk              (0xfful << PWM_DTCTL_DTI01_Pos)                   /*!< PWM_T::DTCTL: DTI01 Mask                  */
N
N#define PWM_DTCTL_DTI23_Pos              (8)                                               /*!< PWM_T::DTCTL: DTI23 Position              */
N#define PWM_DTCTL_DTI23_Msk              (0xfful << PWM_DTCTL_DTI23_Pos)                   /*!< PWM_T::DTCTL: DTI23 Mask                  */
N
N#define PWM_DTCTL_DTI45_Pos              (16)                                              /*!< PWM_T::DTCTL: DTI45 Position              */
N#define PWM_DTCTL_DTI45_Msk              (0xfful << PWM_DTCTL_DTI45_Pos)                   /*!< PWM_T::DTCTL: DTI45 Mask                  */
N
N#define PWM_ADCTCTL0_CUTRGEN0_Pos        (0)                                               /*!< PWM_T::ADCTCTL0: CUTRGEN0 Position        */
N#define PWM_ADCTCTL0_CUTRGEN0_Msk        (0x1ul << PWM_ADCTCTL0_CUTRGEN0_Pos)              /*!< PWM_T::ADCTCTL0: CUTRGEN0 Mask            */
N
N#define PWM_ADCTCTL0_CPTRGEN0_Pos        (1)                                               /*!< PWM_T::ADCTCTL0: CPTRGEN0 Position        */
N#define PWM_ADCTCTL0_CPTRGEN0_Msk        (0x1ul << PWM_ADCTCTL0_CPTRGEN0_Pos)              /*!< PWM_T::ADCTCTL0: CPTRGEN0 Mask            */
N
N#define PWM_ADCTCTL0_CDTRGEN0_Pos        (2)                                               /*!< PWM_T::ADCTCTL0: CDTRGEN0 Position        */
N#define PWM_ADCTCTL0_CDTRGEN0_Msk        (0x1ul << PWM_ADCTCTL0_CDTRGEN0_Pos)              /*!< PWM_T::ADCTCTL0: CDTRGEN0 Mask            */
N
N#define PWM_ADCTCTL0_ZPTRGEN0_Pos        (3)                                               /*!< PWM_T::ADCTCTL0: ZPTRGEN0 Position        */
N#define PWM_ADCTCTL0_ZPTRGEN0_Msk        (0x1ul << PWM_ADCTCTL0_ZPTRGEN0_Pos)              /*!< PWM_T::ADCTCTL0: ZPTRGEN0 Mask            */
N
N#define PWM_ADCTCTL0_CUTRGEN1_Pos        (8)                                               /*!< PWM_T::ADCTCTL0: CUTRGEN1 Position        */
N#define PWM_ADCTCTL0_CUTRGEN1_Msk        (0x1ul << PWM_ADCTCTL0_CUTRGEN1_Pos)              /*!< PWM_T::ADCTCTL0: CUTRGEN1 Mask            */
N
N#define PWM_ADCTCTL0_CPTRGEN1_Pos        (9)                                               /*!< PWM_T::ADCTCTL0: CPTRGEN1 Position        */
N#define PWM_ADCTCTL0_CPTRGEN1_Msk        (0x1ul << PWM_ADCTCTL0_CPTRGEN1_Pos)              /*!< PWM_T::ADCTCTL0: CPTRGEN1 Mask            */
N
N#define PWM_ADCTCTL0_CDTRGEN1_Pos        (10)                                              /*!< PWM_T::ADCTCTL0: CDTRGEN1 Position        */
N#define PWM_ADCTCTL0_CDTRGEN1_Msk        (0x1ul << PWM_ADCTCTL0_CDTRGEN1_Pos)              /*!< PWM_T::ADCTCTL0: CDTRGEN1 Mask            */
N
N#define PWM_ADCTCTL0_ZPTRGEN1_Pos        (11)                                              /*!< PWM_T::ADCTCTL0: ZPTRGEN1 Position        */
N#define PWM_ADCTCTL0_ZPTRGEN1_Msk        (0x1ul << PWM_ADCTCTL0_ZPTRGEN1_Pos)              /*!< PWM_T::ADCTCTL0: ZPTRGEN1 Mask            */
N
N#define PWM_ADCTCTL0_CUTRGEN2_Pos        (16)                                              /*!< PWM_T::ADCTCTL0: CUTRGEN2 Position        */
N#define PWM_ADCTCTL0_CUTRGEN2_Msk        (0x1ul << PWM_ADCTCTL0_CUTRGEN2_Pos)              /*!< PWM_T::ADCTCTL0: CUTRGEN2 Mask            */
N
N#define PWM_ADCTCTL0_CPTRGEN2_Pos        (17)                                              /*!< PWM_T::ADCTCTL0: CPTRGEN2 Position        */
N#define PWM_ADCTCTL0_CPTRGEN2_Msk        (0x1ul << PWM_ADCTCTL0_CPTRGEN2_Pos)              /*!< PWM_T::ADCTCTL0: CPTRGEN2 Mask            */
N
N#define PWM_ADCTCTL0_CDTRGEN2_Pos        (18)                                              /*!< PWM_T::ADCTCTL0: CDTRGEN2 Position        */
N#define PWM_ADCTCTL0_CDTRGEN2_Msk        (0x1ul << PWM_ADCTCTL0_CDTRGEN2_Pos)              /*!< PWM_T::ADCTCTL0: CDTRGEN2 Mask            */
N
N#define PWM_ADCTCTL0_ZPTRGEN2_Pos        (19)                                              /*!< PWM_T::ADCTCTL0: ZPTRGEN2 Position        */
N#define PWM_ADCTCTL0_ZPTRGEN2_Msk        (0x1ul << PWM_ADCTCTL0_ZPTRGEN2_Pos)              /*!< PWM_T::ADCTCTL0: ZPTRGEN2 Mask            */
N
N#define PWM_ADCTCTL0_CUTRGEN3_Pos        (24)                                              /*!< PWM_T::ADCTCTL0: CUTRGEN3 Position        */
N#define PWM_ADCTCTL0_CUTRGEN3_Msk        (0x1ul << PWM_ADCTCTL0_CUTRGEN3_Pos)              /*!< PWM_T::ADCTCTL0: CUTRGEN3 Mask            */
N
N#define PWM_ADCTCTL0_CPTRGEN3_Pos        (25)                                              /*!< PWM_T::ADCTCTL0: CPTRGEN3 Position        */
N#define PWM_ADCTCTL0_CPTRGEN3_Msk        (0x1ul << PWM_ADCTCTL0_CPTRGEN3_Pos)              /*!< PWM_T::ADCTCTL0: CPTRGEN3 Mask            */
N
N#define PWM_ADCTCTL0_CDTRGEN3_Pos        (26)                                              /*!< PWM_T::ADCTCTL0: CDTRGEN3 Position        */
N#define PWM_ADCTCTL0_CDTRGEN3_Msk        (0x1ul << PWM_ADCTCTL0_CDTRGEN3_Pos)              /*!< PWM_T::ADCTCTL0: CDTRGEN3 Mask            */
N
N#define PWM_ADCTCTL0_ZPTRGEN3_Pos        (27)                                              /*!< PWM_T::ADCTCTL0: ZPTRGEN3 Position        */
N#define PWM_ADCTCTL0_ZPTRGEN3_Msk        (0x1ul << PWM_ADCTCTL0_ZPTRGEN3_Pos)              /*!< PWM_T::ADCTCTL0: ZPTRGEN3 Mask            */
N
N#define PWM_ADCTCTL1_CUTRGEN4_Pos        (0)                                               /*!< PWM_T::ADCTCTL1: CUTRGEN4 Position        */
N#define PWM_ADCTCTL1_CUTRGEN4_Msk        (0x1ul << PWM_ADCTCTL1_CUTRGEN4_Pos)              /*!< PWM_T::ADCTCTL1: CUTRGEN4 Mask            */
N
N#define PWM_ADCTCTL1_CPTRGEN4_Pos        (1)                                               /*!< PWM_T::ADCTCTL1: CPTRGEN4 Position        */
N#define PWM_ADCTCTL1_CPTRGEN4_Msk        (0x1ul << PWM_ADCTCTL1_CPTRGEN4_Pos)              /*!< PWM_T::ADCTCTL1: CPTRGEN4 Mask            */
N
N#define PWM_ADCTCTL1_CDTRGEN4_Pos        (2)                                               /*!< PWM_T::ADCTCTL1: CDTRGEN4 Position        */
N#define PWM_ADCTCTL1_CDTRGEN4_Msk        (0x1ul << PWM_ADCTCTL1_CDTRGEN4_Pos)              /*!< PWM_T::ADCTCTL1: CDTRGEN4 Mask            */
N
N#define PWM_ADCTCTL1_ZPTRGEN4_Pos        (3)                                               /*!< PWM_T::ADCTCTL1: ZPTRGEN4 Position        */
N#define PWM_ADCTCTL1_ZPTRGEN4_Msk        (0x1ul << PWM_ADCTCTL1_ZPTRGEN4_Pos)              /*!< PWM_T::ADCTCTL1: ZPTRGEN4 Mask            */
N
N#define PWM_ADCTCTL1_CUTRGEN5_Pos        (8)                                               /*!< PWM_T::ADCTCTL1: CUTRGEN5 Position        */
N#define PWM_ADCTCTL1_CUTRGEN5_Msk        (0x1ul << PWM_ADCTCTL1_CUTRGEN5_Pos)              /*!< PWM_T::ADCTCTL1: CUTRGEN5 Mask            */
N
N#define PWM_ADCTCTL1_CPTRGEN5_Pos        (9)                                               /*!< PWM_T::ADCTCTL1: CPTRGEN5 Position        */
N#define PWM_ADCTCTL1_CPTRGEN5_Msk        (0x1ul << PWM_ADCTCTL1_CPTRGEN5_Pos)              /*!< PWM_T::ADCTCTL1: CPTRGEN5 Mask            */
N
N#define PWM_ADCTCTL1_CDTRGEN5_Pos        (10)                                              /*!< PWM_T::ADCTCTL1: CDTRGEN5 Position        */
N#define PWM_ADCTCTL1_CDTRGEN5_Msk        (0x1ul << PWM_ADCTCTL1_CDTRGEN5_Pos)              /*!< PWM_T::ADCTCTL1: CDTRGEN5 Mask            */
N
N#define PWM_ADCTCTL1_ZPTRGEN5_Pos        (11)                                              /*!< PWM_T::ADCTCTL1: ZPTRGEN5 Position        */
N#define PWM_ADCTCTL1_ZPTRGEN5_Msk        (0x1ul << PWM_ADCTCTL1_ZPTRGEN5_Pos)              /*!< PWM_T::ADCTCTL1: ZPTRGEN5 Mask            */
N
N#define PWM_ADCTSTS0_CUTRGF0_Pos         (0)                                               /*!< PWM_T::ADCTSTS0: CUTRGF0 Position         */
N#define PWM_ADCTSTS0_CUTRGF0_Msk         (0x1ul << PWM_ADCTSTS0_CUTRGF0_Pos)               /*!< PWM_T::ADCTSTS0: CUTRGF0 Mask             */
N
N#define PWM_ADCTSTS0_CPTRGF0_Pos         (1)                                               /*!< PWM_T::ADCTSTS0: CPTRGF0 Position         */
N#define PWM_ADCTSTS0_CPTRGF0_Msk         (0x1ul << PWM_ADCTSTS0_CPTRGF0_Pos)               /*!< PWM_T::ADCTSTS0: CPTRGF0 Mask             */
N
N#define PWM_ADCTSTS0_CDTRGF0_Pos         (2)                                               /*!< PWM_T::ADCTSTS0: CDTRGF0 Position         */
N#define PWM_ADCTSTS0_CDTRGF0_Msk         (0x1ul << PWM_ADCTSTS0_CDTRGF0_Pos)               /*!< PWM_T::ADCTSTS0: CDTRGF0 Mask             */
N
N#define PWM_ADCTSTS0_ZPTRGF0_Pos         (3)                                               /*!< PWM_T::ADCTSTS0: ZPTRGF0 Position         */
N#define PWM_ADCTSTS0_ZPTRGF0_Msk         (0x1ul << PWM_ADCTSTS0_ZPTRGF0_Pos)               /*!< PWM_T::ADCTSTS0: ZPTRGF0 Mask             */
N
N#define PWM_ADCTSTS0_CUTRGF1_Pos         (8)                                               /*!< PWM_T::ADCTSTS0: CUTRGF1 Position         */
N#define PWM_ADCTSTS0_CUTRGF1_Msk         (0x1ul << PWM_ADCTSTS0_CUTRGF1_Pos)               /*!< PWM_T::ADCTSTS0: CUTRGF1 Mask             */
N
N#define PWM_ADCTSTS0_CPTRGF1_Pos         (9)                                               /*!< PWM_T::ADCTSTS0: CPTRGF1 Position         */
N#define PWM_ADCTSTS0_CPTRGF1_Msk         (0x1ul << PWM_ADCTSTS0_CPTRGF1_Pos)               /*!< PWM_T::ADCTSTS0: CPTRGF1 Mask             */
N
N#define PWM_ADCTSTS0_CDTRGF1_Pos         (10)                                              /*!< PWM_T::ADCTSTS0: CDTRGF1 Position         */
N#define PWM_ADCTSTS0_CDTRGF1_Msk         (0x1ul << PWM_ADCTSTS0_CDTRGF1_Pos)               /*!< PWM_T::ADCTSTS0: CDTRGF1 Mask             */
N
N#define PWM_ADCTSTS0_ZPTRGF1_Pos         (11)                                              /*!< PWM_T::ADCTSTS0: ZPTRGF1 Position         */
N#define PWM_ADCTSTS0_ZPTRGF1_Msk         (0x1ul << PWM_ADCTSTS0_ZPTRGF1_Pos)               /*!< PWM_T::ADCTSTS0: ZPTRGF1 Mask             */
N
N#define PWM_ADCTSTS0_CUTRGF2_Pos         (16)                                              /*!< PWM_T::ADCTSTS0: CUTRGF2 Position         */
N#define PWM_ADCTSTS0_CUTRGF2_Msk         (0x1ul << PWM_ADCTSTS0_CUTRGF2_Pos)               /*!< PWM_T::ADCTSTS0: CUTRGF2 Mask             */
N
N#define PWM_ADCTSTS0_CPTRGF2_Pos         (17)                                              /*!< PWM_T::ADCTSTS0: CPTRGF2 Position         */
N#define PWM_ADCTSTS0_CPTRGF2_Msk         (0x1ul << PWM_ADCTSTS0_CPTRGF2_Pos)               /*!< PWM_T::ADCTSTS0: CPTRGF2 Mask             */
N
N#define PWM_ADCTSTS0_CDTRGF2_Pos         (18)                                              /*!< PWM_T::ADCTSTS0: CDTRGF2 Position         */
N#define PWM_ADCTSTS0_CDTRGF2_Msk         (0x1ul << PWM_ADCTSTS0_CDTRGF2_Pos)               /*!< PWM_T::ADCTSTS0: CDTRGF2 Mask             */
N
N#define PWM_ADCTSTS0_ZPTRGF2_Pos         (19)                                              /*!< PWM_T::ADCTSTS0: ZPTRGF2 Position         */
N#define PWM_ADCTSTS0_ZPTRGF2_Msk         (0x1ul << PWM_ADCTSTS0_ZPTRGF2_Pos)               /*!< PWM_T::ADCTSTS0: ZPTRGF2 Mask             */
N
N#define PWM_ADCTSTS0_CUTRGF3_Pos         (24)                                              /*!< PWM_T::ADCTSTS0: CUTRGF3 Position         */
N#define PWM_ADCTSTS0_CUTRGF3_Msk         (0x1ul << PWM_ADCTSTS0_CUTRGF3_Pos)               /*!< PWM_T::ADCTSTS0: CUTRGF3 Mask             */
N
N#define PWM_ADCTSTS0_CPTRGF3_Pos         (25)                                              /*!< PWM_T::ADCTSTS0: CPTRGF3 Position         */
N#define PWM_ADCTSTS0_CPTRGF3_Msk         (0x1ul << PWM_ADCTSTS0_CPTRGF3_Pos)               /*!< PWM_T::ADCTSTS0: CPTRGF3 Mask             */
N
N#define PWM_ADCTSTS0_CDTRGF3_Pos         (26)                                              /*!< PWM_T::ADCTSTS0: CDTRGF3 Position         */
N#define PWM_ADCTSTS0_CDTRGF3_Msk         (0x1ul << PWM_ADCTSTS0_CDTRGF3_Pos)               /*!< PWM_T::ADCTSTS0: CDTRGF3 Mask             */
N
N#define PWM_ADCTSTS0_ZPTRGF3_Pos         (27)                                              /*!< PWM_T::ADCTSTS0: ZPTRGF3 Position         */
N#define PWM_ADCTSTS0_ZPTRGF3_Msk         (0x1ul << PWM_ADCTSTS0_ZPTRGF3_Pos)               /*!< PWM_T::ADCTSTS0: ZPTRGF3 Mask             */
N
N#define PWM_ADCTSTS1_CUTRGF4_Pos         (0)                                               /*!< PWM_T::ADCTSTS1: CUTRGF4 Position         */
N#define PWM_ADCTSTS1_CUTRGF4_Msk         (0x1ul << PWM_ADCTSTS1_CUTRGF4_Pos)               /*!< PWM_T::ADCTSTS1: CUTRGF4 Mask             */
N
N#define PWM_ADCTSTS1_CPTRGF4_Pos         (1)                                               /*!< PWM_T::ADCTSTS1: CPTRGF4 Position         */
N#define PWM_ADCTSTS1_CPTRGF4_Msk         (0x1ul << PWM_ADCTSTS1_CPTRGF4_Pos)               /*!< PWM_T::ADCTSTS1: CPTRGF4 Mask             */
N
N#define PWM_ADCTSTS1_CDTRGF4_Pos         (2)                                               /*!< PWM_T::ADCTSTS1: CDTRGF4 Position         */
N#define PWM_ADCTSTS1_CDTRGF4_Msk         (0x1ul << PWM_ADCTSTS1_CDTRGF4_Pos)               /*!< PWM_T::ADCTSTS1: CDTRGF4 Mask             */
N
N#define PWM_ADCTSTS1_ZPTRGF4_Pos         (3)                                               /*!< PWM_T::ADCTSTS1: ZPTRGF4 Position         */
N#define PWM_ADCTSTS1_ZPTRGF4_Msk         (0x1ul << PWM_ADCTSTS1_ZPTRGF4_Pos)               /*!< PWM_T::ADCTSTS1: ZPTRGF4 Mask             */
N
N#define PWM_ADCTSTS1_CUTRGF5_Pos         (8)                                               /*!< PWM_T::ADCTSTS1: CUTRGF5 Position         */
N#define PWM_ADCTSTS1_CUTRGF5_Msk         (0x1ul << PWM_ADCTSTS1_CUTRGF5_Pos)               /*!< PWM_T::ADCTSTS1: CUTRGF5 Mask             */
N
N#define PWM_ADCTSTS1_CPTRGF5_Pos         (9)                                               /*!< PWM_T::ADCTSTS1: CPTRGF5 Position         */
N#define PWM_ADCTSTS1_CPTRGF5_Msk         (0x1ul << PWM_ADCTSTS1_CPTRGF5_Pos)               /*!< PWM_T::ADCTSTS1: CPTRGF5 Mask             */
N
N#define PWM_ADCTSTS1_CDTRGF5_Pos         (10)                                              /*!< PWM_T::ADCTSTS1: CDTRGF5 Position         */
N#define PWM_ADCTSTS1_CDTRGF5_Msk         (0x1ul << PWM_ADCTSTS1_CDTRGF5_Pos)               /*!< PWM_T::ADCTSTS1: CDTRGF5 Mask             */
N
N#define PWM_ADCTSTS1_ZPTRGF5_Pos         (11)                                              /*!< PWM_T::ADCTSTS1: ZPTRGF5 Position         */
N#define PWM_ADCTSTS1_ZPTRGF5_Msk         (0x1ul << PWM_ADCTSTS1_ZPTRGF5_Pos)               /*!< PWM_T::ADCTSTS1: ZPTRGF5 Mask             */
N
N#define PWM_PHCHG_MSKDAT0_Pos            (0)                                               /*!< PWM_T::PHCHG: MSKDAT0 Position            */
N#define PWM_PHCHG_MSKDAT0_Msk            (0x1ul << PWM_PHCHG_MSKDAT0_Pos)                  /*!< PWM_T::PHCHG: MSKDAT0 Mask                */
N
N#define PWM_PHCHG_MSKDAT1_Pos            (1)                                               /*!< PWM_T::PHCHG: MSKDAT1 Position            */
N#define PWM_PHCHG_MSKDAT1_Msk            (0x1ul << PWM_PHCHG_MSKDAT1_Pos)                  /*!< PWM_T::PHCHG: MSKDAT1 Mask                */
N
N#define PWM_PHCHG_MSKDAT2_Pos            (2)                                               /*!< PWM_T::PHCHG: MSKDAT2 Position            */
N#define PWM_PHCHG_MSKDAT2_Msk            (0x1ul << PWM_PHCHG_MSKDAT2_Pos)                  /*!< PWM_T::PHCHG: MSKDAT2 Mask                */
N
N#define PWM_PHCHG_MSKDAT3_Pos            (3)                                               /*!< PWM_T::PHCHG: MSKDAT3 Position            */
N#define PWM_PHCHG_MSKDAT3_Msk            (0x1ul << PWM_PHCHG_MSKDAT3_Pos)                  /*!< PWM_T::PHCHG: MSKDAT3 Mask                */
N
N#define PWM_PHCHG_MSKDAT4_Pos            (4)                                               /*!< PWM_T::PHCHG: MSKDAT4 Position            */
N#define PWM_PHCHG_MSKDAT4_Msk            (0x1ul << PWM_PHCHG_MSKDAT4_Pos)                  /*!< PWM_T::PHCHG: MSKDAT4 Mask                */
N
N#define PWM_PHCHG_MSKDAT5_Pos            (5)                                               /*!< PWM_T::PHCHG: MSKDAT5 Position            */
N#define PWM_PHCHG_MSKDAT5_Msk            (0x1ul << PWM_PHCHG_MSKDAT5_Pos)                  /*!< PWM_T::PHCHG: MSKDAT5 Mask                */
N
N#define PWM_PHCHG_MSKDAT6_Pos            (6)                                               /*!< PWM_T::PHCHG: MSKDAT6 Position            */
N#define PWM_PHCHG_MSKDAT6_Msk            (0x1ul << PWM_PHCHG_MSKDAT6_Pos)                  /*!< PWM_T::PHCHG: MSKDAT6 Mask                */
N
N#define PWM_PHCHG_MSKDAT7_Pos            (7)                                               /*!< PWM_T::PHCHG: MSKDAT7 Position            */
N#define PWM_PHCHG_MSKDAT7_Msk            (0x1ul << PWM_PHCHG_MSKDAT7_Pos)                  /*!< PWM_T::PHCHG: MSKDAT7 Mask                */
N
N#define PWM_PHCHG_MSKEN0_Pos             (8)                                               /*!< PWM_T::PHCHG: MSKEN0 Position             */
N#define PWM_PHCHG_MSKEN0_Msk             (0x1ul << PWM_PHCHG_MSKEN0_Pos)                   /*!< PWM_T::PHCHG: MSKEN0 Mask                 */
N
N#define PWM_PHCHG_MSKEN1_Pos             (9)                                               /*!< PWM_T::PHCHG: MSKEN1 Position             */
N#define PWM_PHCHG_MSKEN1_Msk             (0x1ul << PWM_PHCHG_MSKEN1_Pos)                   /*!< PWM_T::PHCHG: MSKEN1 Mask                 */
N
N#define PWM_PHCHG_MSKEN2_Pos             (10)                                              /*!< PWM_T::PHCHG: MSKEN2 Position             */
N#define PWM_PHCHG_MSKEN2_Msk             (0x1ul << PWM_PHCHG_MSKEN2_Pos)                   /*!< PWM_T::PHCHG: MSKEN2 Mask                 */
N
N#define PWM_PHCHG_MSKEN3_Pos             (11)                                              /*!< PWM_T::PHCHG: MSKEN3 Position             */
N#define PWM_PHCHG_MSKEN3_Msk             (0x1ul << PWM_PHCHG_MSKEN3_Pos)                   /*!< PWM_T::PHCHG: MSKEN3 Mask                 */
N
N#define PWM_PHCHG_MSKEN4_Pos             (12)                                              /*!< PWM_T::PHCHG: MSKEN4 Position             */
N#define PWM_PHCHG_MSKEN4_Msk             (0x1ul << PWM_PHCHG_MSKEN4_Pos)                   /*!< PWM_T::PHCHG: MSKEN4 Mask                 */
N
N#define PWM_PHCHG_MSKEN5_Pos             (13)                                              /*!< PWM_T::PHCHG: MSKEN5 Position             */
N#define PWM_PHCHG_MSKEN5_Msk             (0x1ul << PWM_PHCHG_MSKEN5_Pos)                   /*!< PWM_T::PHCHG: MSKEN5 Mask                 */
N
N#define PWM_PHCHG_AUTOCLR0_Pos           (14)                                              /*!< PWM_T::PHCHG: AUTOCLR0 Position           */
N#define PWM_PHCHG_AUTOCLR0_Msk           (0x1ul << PWM_PHCHG_AUTOCLR0_Pos)                 /*!< PWM_T::PHCHG: AUTOCLR0 Mask               */
N
N#define PWM_PHCHG_AUTOCLR1_Pos           (15)                                              /*!< PWM_T::PHCHG: AUTOCLR1 Position           */
N#define PWM_PHCHG_AUTOCLR1_Msk           (0x1ul << PWM_PHCHG_AUTOCLR1_Pos)                 /*!< PWM_T::PHCHG: AUTOCLR1 Mask               */
N
N#define PWM_PHCHG_AOFFEN01_Pos           (16)                                              /*!< PWM_T::PHCHG: AOFFEN01 Position           */
N#define PWM_PHCHG_AOFFEN01_Msk           (0x1ul << PWM_PHCHG_AOFFEN01_Pos)                 /*!< PWM_T::PHCHG: AOFFEN01 Mask               */
N
N#define PWM_PHCHG_AOFFEN11_Pos           (17)                                              /*!< PWM_T::PHCHG: AOFFEN11 Position           */
N#define PWM_PHCHG_AOFFEN11_Msk           (0x1ul << PWM_PHCHG_AOFFEN11_Pos)                 /*!< PWM_T::PHCHG: AOFFEN11 Mask               */
N
N#define PWM_PHCHG_AOFFEN21_Pos           (18)                                              /*!< PWM_T::PHCHG: AOFFEN21 Position           */
N#define PWM_PHCHG_AOFFEN21_Msk           (0x1ul << PWM_PHCHG_AOFFEN21_Pos)                 /*!< PWM_T::PHCHG: AOFFEN21 Mask               */
N
N#define PWM_PHCHG_AOFFEN31_Pos           (19)                                              /*!< PWM_T::PHCHG: AOFFEN31 Position           */
N#define PWM_PHCHG_AOFFEN31_Msk           (0x1ul << PWM_PHCHG_AOFFEN31_Pos)                 /*!< PWM_T::PHCHG: AOFFEN31 Mask               */
N
N#define PWM_PHCHG_A1POSSEL_Pos           (20)                                              /*!< PWM_T::PHCHG: A1POSSEL Position           */
N#define PWM_PHCHG_A1POSSEL_Msk           (0x3ul << PWM_PHCHG_A1POSSEL_Pos)                 /*!< PWM_T::PHCHG: A1POSSEL Mask               */
N
N#define PWM_PHCHG_TMR1TEN_Pos            (22)                                              /*!< PWM_T::PHCHG: TMR1TEN Position            */
N#define PWM_PHCHG_TMR1TEN_Msk            (0x1ul << PWM_PHCHG_TMR1TEN_Pos)                  /*!< PWM_T::PHCHG: TMR1TEN Mask                */
N
N#define PWM_PHCHG_ACMP1TEN_Pos           (23)                                              /*!< PWM_T::PHCHG: ACMP1TEN Position           */
N#define PWM_PHCHG_ACMP1TEN_Msk           (0x1ul << PWM_PHCHG_ACMP1TEN_Pos)                 /*!< PWM_T::PHCHG: ACMP1TEN Mask               */
N
N#define PWM_PHCHG_AOFFEN00_Pos           (24)                                              /*!< PWM_T::PHCHG: AOFFEN00 Position           */
N#define PWM_PHCHG_AOFFEN00_Msk           (0x1ul << PWM_PHCHG_AOFFEN00_Pos)                 /*!< PWM_T::PHCHG: AOFFEN00 Mask               */
N
N#define PWM_PHCHG_AOFFEN10_Pos           (25)                                              /*!< PWM_T::PHCHG: AOFFEN10 Position           */
N#define PWM_PHCHG_AOFFEN10_Msk           (0x1ul << PWM_PHCHG_AOFFEN10_Pos)                 /*!< PWM_T::PHCHG: AOFFEN10 Mask               */
N
N#define PWM_PHCHG_AOFFEN20_Pos           (26)                                              /*!< PWM_T::PHCHG: AOFFEN20 Position           */
N#define PWM_PHCHG_AOFFEN20_Msk           (0x1ul << PWM_PHCHG_AOFFEN20_Pos)                 /*!< PWM_T::PHCHG: AOFFEN20 Mask               */
N
N#define PWM_PHCHG_AOFFEN30_Pos           (27)                                              /*!< PWM_T::PHCHG: AOFFEN30 Position           */
N#define PWM_PHCHG_AOFFEN30_Msk           (0x1ul << PWM_PHCHG_AOFFEN30_Pos)                 /*!< PWM_T::PHCHG: AOFFEN30 Mask               */
N
N#define PWM_PHCHG_A0POSSEL_Pos           (28)                                              /*!< PWM_T::PHCHG: A0POSSEL Position           */
N#define PWM_PHCHG_A0POSSEL_Msk           (0x3ul << PWM_PHCHG_A0POSSEL_Pos)                 /*!< PWM_T::PHCHG: A0POSSEL Mask               */
N
N#define PWM_PHCHG_TMR0TEN_Pos            (30)                                              /*!< PWM_T::PHCHG: TMR0TEN Position            */
N#define PWM_PHCHG_TMR0TEN_Msk            (0x1ul << PWM_PHCHG_TMR0TEN_Pos)                  /*!< PWM_T::PHCHG: TMR0TEN Mask                */
N
N#define PWM_PHCHG_ACMP0TEN_Pos           (31)                                              /*!< PWM_T::PHCHG: ACMP0TEN Position           */
N#define PWM_PHCHG_ACMP0TEN_Msk           (0x1ul << PWM_PHCHG_ACMP0TEN_Pos)                 /*!< PWM_T::PHCHG: ACMP0TEN Mask               */
N
N#define PWM_PHCHGNXT_MSKDAT0_Pos         (0)                                               /*!< PWM_T::PHCHGNXT: MSKDAT0 Position         */
N#define PWM_PHCHGNXT_MSKDAT0_Msk         (0x1ul << PWM_PHCHGNXT_MSKDAT0_Pos)               /*!< PWM_T::PHCHGNXT: MSKDAT0 Mask             */
N
N#define PWM_PHCHGNXT_MSKDAT1_Pos         (1)                                               /*!< PWM_T::PHCHGNXT: MSKDAT1 Position         */
N#define PWM_PHCHGNXT_MSKDAT1_Msk         (0x1ul << PWM_PHCHGNXT_MSKDAT1_Pos)               /*!< PWM_T::PHCHGNXT: MSKDAT1 Mask             */
N
N#define PWM_PHCHGNXT_MSKDAT2_Pos         (2)                                               /*!< PWM_T::PHCHGNXT: MSKDAT2 Position         */
N#define PWM_PHCHGNXT_MSKDAT2_Msk         (0x1ul << PWM_PHCHGNXT_MSKDAT2_Pos)               /*!< PWM_T::PHCHGNXT: MSKDAT2 Mask             */
N
N#define PWM_PHCHGNXT_MSKDAT3_Pos         (3)                                               /*!< PWM_T::PHCHGNXT: MSKDAT3 Position         */
N#define PWM_PHCHGNXT_MSKDAT3_Msk         (0x1ul << PWM_PHCHGNXT_MSKDAT3_Pos)               /*!< PWM_T::PHCHGNXT: MSKDAT3 Mask             */
N
N#define PWM_PHCHGNXT_MSKDAT4_Pos         (4)                                               /*!< PWM_T::PHCHGNXT: MSKDAT4 Position         */
N#define PWM_PHCHGNXT_MSKDAT4_Msk         (0x1ul << PWM_PHCHGNXT_MSKDAT4_Pos)               /*!< PWM_T::PHCHGNXT: MSKDAT4 Mask             */
N
N#define PWM_PHCHGNXT_MSKDAT5_Pos         (5)                                               /*!< PWM_T::PHCHGNXT: MSKDAT5 Position         */
N#define PWM_PHCHGNXT_MSKDAT5_Msk         (0x1ul << PWM_PHCHGNXT_MSKDAT5_Pos)               /*!< PWM_T::PHCHGNXT: MSKDAT5 Mask             */
N
N#define PWM_PHCHGNXT_MSKDAT6_Pos         (6)                                               /*!< PWM_T::PHCHGNXT: MSKDAT6 Position         */
N#define PWM_PHCHGNXT_MSKDAT6_Msk         (0x1ul << PWM_PHCHGNXT_MSKDAT6_Pos)               /*!< PWM_T::PHCHGNXT: MSKDAT6 Mask             */
N
N#define PWM_PHCHGNXT_MSKDAT7_Pos         (7)                                               /*!< PWM_T::PHCHGNXT: MSKDAT7 Position         */
N#define PWM_PHCHGNXT_MSKDAT7_Msk         (0x1ul << PWM_PHCHGNXT_MSKDAT7_Pos)               /*!< PWM_T::PHCHGNXT: MSKDAT7 Mask             */
N
N#define PWM_PHCHGNXT_MSKEN0_Pos          (8)                                               /*!< PWM_T::PHCHGNXT: MSKEN0 Position          */
N#define PWM_PHCHGNXT_MSKEN0_Msk          (0x1ul << PWM_PHCHGNXT_MSKEN0_Pos)                /*!< PWM_T::PHCHGNXT: MSKEN0 Mask              */
N
N#define PWM_PHCHGNXT_MSKEN1_Pos          (9)                                               /*!< PWM_T::PHCHGNXT: MSKEN1 Position          */
N#define PWM_PHCHGNXT_MSKEN1_Msk          (0x1ul << PWM_PHCHGNXT_MSKEN1_Pos)                /*!< PWM_T::PHCHGNXT: MSKEN1 Mask              */
N
N#define PWM_PHCHGNXT_MSKEN2_Pos          (10)                                              /*!< PWM_T::PHCHGNXT: MSKEN2 Position          */
N#define PWM_PHCHGNXT_MSKEN2_Msk          (0x1ul << PWM_PHCHGNXT_MSKEN2_Pos)                /*!< PWM_T::PHCHGNXT: MSKEN2 Mask              */
N
N#define PWM_PHCHGNXT_MSKEN3_Pos          (11)                                              /*!< PWM_T::PHCHGNXT: MSKEN3 Position          */
N#define PWM_PHCHGNXT_MSKEN3_Msk          (0x1ul << PWM_PHCHGNXT_MSKEN3_Pos)                /*!< PWM_T::PHCHGNXT: MSKEN3 Mask              */
N
N#define PWM_PHCHGNXT_MSKEN4_Pos          (12)                                              /*!< PWM_T::PHCHGNXT: MSKEN4 Position          */
N#define PWM_PHCHGNXT_MSKEN4_Msk          (0x1ul << PWM_PHCHGNXT_MSKEN4_Pos)                /*!< PWM_T::PHCHGNXT: MSKEN4 Mask              */
N
N#define PWM_PHCHGNXT_MSKEN5_Pos          (13)                                              /*!< PWM_T::PHCHGNXT: MSKEN5 Position          */
N#define PWM_PHCHGNXT_MSKEN5_Msk          (0x1ul << PWM_PHCHGNXT_MSKEN5_Pos)                /*!< PWM_T::PHCHGNXT: MSKEN5 Mask              */
N
N#define PWM_PHCHGNXT_AUTOCLR0_Pos        (14)                                              /*!< PWM_T::PHCHGNXT: AUTOCLR0 Position        */
N#define PWM_PHCHGNXT_AUTOCLR0_Msk        (0x1ul << PWM_PHCHGNXT_AUTOCLR0_Pos)              /*!< PWM_T::PHCHGNXT: AUTOCLR0 Mask            */
N
N#define PWM_PHCHGNXT_AUTOCLR1_Pos        (15)                                              /*!< PWM_T::PHCHGNXT: AUTOCLR1 Position        */
N#define PWM_PHCHGNXT_AUTOCLR1_Msk        (0x1ul << PWM_PHCHGNXT_AUTOCLR1_Pos)              /*!< PWM_T::PHCHGNXT: AUTOCLR1 Mask            */
N
N#define PWM_PHCHGNXT_AOFFEN01_Pos        (16)                                              /*!< PWM_T::PHCHGNXT: AOFFEN01 Position        */
N#define PWM_PHCHGNXT_AOFFEN01_Msk        (0x1ul << PWM_PHCHGNXT_AOFFEN01_Pos)              /*!< PWM_T::PHCHGNXT: AOFFEN01 Mask            */
N
N#define PWM_PHCHGNXT_AOFFEN11_Pos        (17)                                              /*!< PWM_T::PHCHGNXT: AOFFEN11 Position        */
N#define PWM_PHCHGNXT_AOFFEN11_Msk        (0x1ul << PWM_PHCHGNXT_AOFFEN11_Pos)              /*!< PWM_T::PHCHGNXT: AOFFEN11 Mask            */
N
N#define PWM_PHCHGNXT_AOFFEN21_Pos        (18)                                              /*!< PWM_T::PHCHGNXT: AOFFEN21 Position        */
N#define PWM_PHCHGNXT_AOFFEN21_Msk        (0x1ul << PWM_PHCHGNXT_AOFFEN21_Pos)              /*!< PWM_T::PHCHGNXT: AOFFEN21 Mask            */
N
N#define PWM_PHCHGNXT_AOFFEN31_Pos        (19)                                              /*!< PWM_T::PHCHGNXT: AOFFEN31 Position        */
N#define PWM_PHCHGNXT_AOFFEN31_Msk        (0x1ul << PWM_PHCHGNXT_AOFFEN31_Pos)              /*!< PWM_T::PHCHGNXT: AOFFEN31 Mask            */
N
N#define PWM_PHCHGNXT_A1POSSEL_Pos        (20)                                              /*!< PWM_T::PHCHGNXT: A1POSSEL Position        */
N#define PWM_PHCHGNXT_A1POSSEL_Msk        (0x3ul << PWM_PHCHGNXT_A1POSSEL_Pos)              /*!< PWM_T::PHCHGNXT: A1POSSEL Mask            */
N
N#define PWM_PHCHGNXT_TMR1TEN_Pos         (22)                                              /*!< PWM_T::PHCHGNXT: TMR1TEN Position         */
N#define PWM_PHCHGNXT_TMR1TEN_Msk         (0x1ul << PWM_PHCHGNXT_TMR1TEN_Pos)               /*!< PWM_T::PHCHGNXT: TMR1TEN Mask             */
N
N#define PWM_PHCHGNXT_ACMP1TEN_Pos        (23)                                              /*!< PWM_T::PHCHGNXT: ACMP1TEN Position        */
N#define PWM_PHCHGNXT_ACMP1TEN_Msk        (0x1ul << PWM_PHCHGNXT_ACMP1TEN_Pos)              /*!< PWM_T::PHCHGNXT: ACMP1TEN Mask            */
N
N#define PWM_PHCHGNXT_AOFFEN00_Pos        (24)                                              /*!< PWM_T::PHCHGNXT: AOFFEN00 Position        */
N#define PWM_PHCHGNXT_AOFFEN00_Msk        (0x1ul << PWM_PHCHGNXT_AOFFEN00_Pos)              /*!< PWM_T::PHCHGNXT: AOFFEN00 Mask            */
N
N#define PWM_PHCHGNXT_AOFFEN10_Pos        (25)                                              /*!< PWM_T::PHCHGNXT: AOFFEN10 Position        */
N#define PWM_PHCHGNXT_AOFFEN10_Msk        (0x1ul << PWM_PHCHGNXT_AOFFEN10_Pos)              /*!< PWM_T::PHCHGNXT: AOFFEN10 Mask            */
N
N#define PWM_PHCHGNXT_AOFFEN20_Pos        (26)                                              /*!< PWM_T::PHCHGNXT: AOFFEN20 Position        */
N#define PWM_PHCHGNXT_AOFFEN20_Msk        (0x1ul << PWM_PHCHGNXT_AOFFEN20_Pos)              /*!< PWM_T::PHCHGNXT: AOFFEN20 Mask            */
N
N#define PWM_PHCHGNXT_AOFFEN30_Pos        (27)                                              /*!< PWM_T::PHCHGNXT: AOFFEN30 Position        */
N#define PWM_PHCHGNXT_AOFFEN30_Msk        (0x1ul << PWM_PHCHGNXT_AOFFEN30_Pos)              /*!< PWM_T::PHCHGNXT: AOFFEN30 Mask            */
N
N#define PWM_PHCHGNXT_A0POSSEL_Pos        (28)                                              /*!< PWM_T::PHCHGNXT: A0POSSEL Position        */
N#define PWM_PHCHGNXT_A0POSSEL_Msk        (0x3ul << PWM_PHCHGNXT_A0POSSEL_Pos)              /*!< PWM_T::PHCHGNXT: A0POSSEL Mask            */
N
N#define PWM_PHCHGNXT_TMR0TEN_Pos         (30)                                              /*!< PWM_T::PHCHGNXT: TMR0TEN Position         */
N#define PWM_PHCHGNXT_TMR0TEN_Msk         (0x1ul << PWM_PHCHGNXT_TMR0TEN_Pos)               /*!< PWM_T::PHCHGNXT: TMR0TEN Mask             */
N
N#define PWM_PHCHGNXT_ACMP0TEN_Pos        (31)                                              /*!< PWM_T::PHCHGNXT: ACMP0TEN Position        */
N#define PWM_PHCHGNXT_ACMP0TEN_Msk        (0x1ul << PWM_PHCHGNXT_ACMP0TEN_Pos)              /*!< PWM_T::PHCHGNXT: ACMP0TEN Mask            */
N
N#define PWM_PHCHGMSK_MASKEND6_Pos        (6)                                               /*!< PWM_T::PHCHGMSK: MASKEND6 Position        */
N#define PWM_PHCHGMSK_MASKEND6_Msk        (0x1ul << PWM_PHCHGMSK_MASKEND6_Pos)              /*!< PWM_T::PHCHGMSK: MASKEND6 Mask            */
N
N#define PWM_PHCHGMSK_MASKEND7_Pos        (7)                                               /*!< PWM_T::PHCHGMSK: MASKEND7 Position        */
N#define PWM_PHCHGMSK_MASKEND7_Msk        (0x1ul << PWM_PHCHGMSK_MASKEND7_Pos)              /*!< PWM_T::PHCHGMSK: MASKEND7 Mask            */
N
N#define PWM_PHCHGMSK_POSCTL0_Pos         (8)                                               /*!< PWM_T::PHCHGMSK: POSCTL0 Position         */
N#define PWM_PHCHGMSK_POSCTL0_Msk         (0x1ul << PWM_PHCHGMSK_POSCTL0_Pos)               /*!< PWM_T::PHCHGMSK: POSCTL0 Mask             */
N
N#define PWM_PHCHGMSK_POSCTL1_Pos         (9)                                               /*!< PWM_T::PHCHGMSK: POSCTL1 Position         */
N#define PWM_PHCHGMSK_POSCTL1_Msk         (0x1ul << PWM_PHCHGMSK_POSCTL1_Pos)               /*!< PWM_T::PHCHGMSK: POSCTL1 Mask             */
N
N#define PWM_IFA_IFAEN_Pos                (0)                                               /*!< PWM_T::IFA: IFAEN Position                */
N#define PWM_IFA_IFAEN_Msk                (0x1ul << PWM_IFA_IFAEN_Pos)                      /*!< PWM_T::IFA: IFAEN Mask                    */
N
N#define PWM_IFA_IFCNT_Pos                (4)                                               /*!< PWM_T::IFA: IFCNT Position                */
N#define PWM_IFA_IFCNT_Msk                (0xful << PWM_IFA_IFCNT_Pos)                      /*!< PWM_T::IFA: IFCNT Mask                    */
N
N#define PWM_PCACTL_PCAEN_Pos             (0)                                               /*!< PWM_T::PCACTL: PCAEN Position             */
N#define PWM_PCACTL_PCAEN_Msk             (0x1ul << PWM_PCACTL_PCAEN_Pos)                   /*!< PWM_T::PCACTL: PCAEN Mask                 */
N
N#define PWM_MSKALIGN_MSKDAT0_Pos         (0)                                               /*!< PWM_T::MSKALIGN: MSKDAT0 Position         */
N#define PWM_MSKALIGN_MSKDAT0_Msk         (0x1ul << PWM_MSKALIGN_MSKDAT0_Pos)               /*!< PWM_T::MSKALIGN: MSKDAT0 Mask             */
N
N#define PWM_MSKALIGN_MSKDAT1_Pos         (1)                                               /*!< PWM_T::MSKALIGN: MSKDAT1 Position         */
N#define PWM_MSKALIGN_MSKDAT1_Msk         (0x1ul << PWM_MSKALIGN_MSKDAT1_Pos)               /*!< PWM_T::MSKALIGN: MSKDAT1 Mask             */
N
N#define PWM_MSKALIGN_MSKDAT2_Pos         (2)                                               /*!< PWM_T::MSKALIGN: MSKDAT2 Position         */
N#define PWM_MSKALIGN_MSKDAT2_Msk         (0x1ul << PWM_MSKALIGN_MSKDAT2_Pos)               /*!< PWM_T::MSKALIGN: MSKDAT2 Mask             */
N
N#define PWM_MSKALIGN_MSKDAT3_Pos         (3)                                               /*!< PWM_T::MSKALIGN: MSKDAT3 Position         */
N#define PWM_MSKALIGN_MSKDAT3_Msk         (0x1ul << PWM_MSKALIGN_MSKDAT3_Pos)               /*!< PWM_T::MSKALIGN: MSKDAT3 Mask             */
N
N#define PWM_MSKALIGN_MSKDAT4_Pos         (4)                                               /*!< PWM_T::MSKALIGN: MSKDAT4 Position         */
N#define PWM_MSKALIGN_MSKDAT4_Msk         (0x1ul << PWM_MSKALIGN_MSKDAT4_Pos)               /*!< PWM_T::MSKALIGN: MSKDAT4 Mask             */
N
N#define PWM_MSKALIGN_MSKDAT5_Pos         (5)                                               /*!< PWM_T::MSKALIGN: MSKDAT5 Position         */
N#define PWM_MSKALIGN_MSKDAT5_Msk         (0x1ul << PWM_MSKALIGN_MSKDAT5_Pos)               /*!< PWM_T::MSKALIGN: MSKDAT5 Mask             */
N
N#define PWM_MSKALIGN_MSKEN0_Pos          (8)                                               /*!< PWM_T::MSKALIGN: MSKEN0 Position          */
N#define PWM_MSKALIGN_MSKEN0_Msk          (0x1ul << PWM_MSKALIGN_MSKEN0_Pos)                /*!< PWM_T::MSKALIGN: MSKEN0 Mask              */
N
N#define PWM_MSKALIGN_MSKEN1_Pos          (9)                                               /*!< PWM_T::MSKALIGN: MSKEN1 Position          */
N#define PWM_MSKALIGN_MSKEN1_Msk          (0x1ul << PWM_MSKALIGN_MSKEN1_Pos)                /*!< PWM_T::MSKALIGN: MSKEN1 Mask              */
N
N#define PWM_MSKALIGN_MSKEN2_Pos          (10)                                              /*!< PWM_T::MSKALIGN: MSKEN2 Position          */
N#define PWM_MSKALIGN_MSKEN2_Msk          (0x1ul << PWM_MSKALIGN_MSKEN2_Pos)                /*!< PWM_T::MSKALIGN: MSKEN2 Mask              */
N
N#define PWM_MSKALIGN_MSKEN3_Pos          (11)                                              /*!< PWM_T::MSKALIGN: MSKEN3 Position          */
N#define PWM_MSKALIGN_MSKEN3_Msk          (0x1ul << PWM_MSKALIGN_MSKEN3_Pos)                /*!< PWM_T::MSKALIGN: MSKEN3 Mask              */
N
N#define PWM_MSKALIGN_MSKEN4_Pos          (12)                                              /*!< PWM_T::MSKALIGN: MSKEN4 Position          */
N#define PWM_MSKALIGN_MSKEN4_Msk          (0x1ul << PWM_MSKALIGN_MSKEN4_Pos)                /*!< PWM_T::MSKALIGN: MSKEN4 Mask              */
N
N#define PWM_MSKALIGN_MSKEN5_Pos          (13)                                              /*!< PWM_T::MSKALIGN: MSKEN5 Position          */
N#define PWM_MSKALIGN_MSKEN5_Msk          (0x1ul << PWM_MSKALIGN_MSKEN5_Pos)                /*!< PWM_T::MSKALIGN: MSKEN5 Mask              */
N
N#define PWM_MSKALIGN_ALIGN0_Pos          (16)                                              /*!< PWM_T::MSKALIGN: ALIGN0 Position          */
N#define PWM_MSKALIGN_ALIGN0_Msk          (0x1ul << PWM_MSKALIGN_ALIGN0_Pos)                /*!< PWM_T::MSKALIGN: ALIGN0 Mask              */
N
N#define PWM_MSKALIGN_ALIGN1_Pos          (17)                                              /*!< PWM_T::MSKALIGN: ALIGN1 Position          */
N#define PWM_MSKALIGN_ALIGN1_Msk          (0x1ul << PWM_MSKALIGN_ALIGN1_Pos)                /*!< PWM_T::MSKALIGN: ALIGN1 Mask              */
N
N#define PWM_MSKALIGN_ALIGN2_Pos          (18)                                              /*!< PWM_T::MSKALIGN: ALIGN2 Position          */
N#define PWM_MSKALIGN_ALIGN2_Msk          (0x1ul << PWM_MSKALIGN_ALIGN2_Pos)                /*!< PWM_T::MSKALIGN: ALIGN2 Mask              */
N
N#define PWM_MSKALIGN_ALIGN3_Pos          (19)                                              /*!< PWM_T::MSKALIGN: ALIGN3 Position          */
N#define PWM_MSKALIGN_ALIGN3_Msk          (0x1ul << PWM_MSKALIGN_ALIGN3_Pos)                /*!< PWM_T::MSKALIGN: ALIGN3 Mask              */
N
N#define PWM_MSKALIGN_ALIGN4_Pos          (20)                                              /*!< PWM_T::MSKALIGN: ALIGN4 Position          */
N#define PWM_MSKALIGN_ALIGN4_Msk          (0x1ul << PWM_MSKALIGN_ALIGN4_Pos)                /*!< PWM_T::MSKALIGN: ALIGN4 Mask              */
N
N#define PWM_MSKALIGN_ALIGN5_Pos          (21)                                              /*!< PWM_T::MSKALIGN: ALIGN5 Position          */
N#define PWM_MSKALIGN_ALIGN5_Msk          (0x1ul << PWM_MSKALIGN_ALIGN5_Pos)                /*!< PWM_T::MSKALIGN: ALIGN5 Mask              */
N
N/**@}*/ /* PWM_CONST */
N/**@}*/ /* end of PWM register group */
N
N
N/*---------------------- Serial Peripheral Interface Controller -------------------------*/
N/**
N    @addtogroup SPI Serial Peripheral Interface Controller(SPI)
N    Memory Mapped Structure for SPI Controller
N@{ */
N
Ntypedef struct {
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x00  SPI Control and Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SPIEN     |SPI Transfer Control Bit And Busy Status
N     * |        |          |If FIFO mode is enabled, this bit will be controlled by hardware and it's read only.
N     * |        |          |If FIFO mode is disabled, during the data transfer, this bit keeps the value of 1.
N     * |        |          |As the transfer is finished, this bit will be cleared automatically.
N     * |        |          |0 = Writing 0 to this bit to stop data transfer if SPI is transferring.
N     * |        |          |1 = In Master mode, writing 1 to this bit to start the SPI data transfer; in Slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master.
N     * |        |          |Note 1: When FIFO mode is disabled, all configurations should be ready before writing 1 to the SPIEN bit.
N     * |        |          |Note 2: In SPI Slave mode, if FIFO mode is disabled and the SPI bus clock is kept at idle state during a data transfer, the SPIEN bit will not be cleared to 0 when slave select signal goes to inactive state.
N     * |[1]     |RXNEG     |Receive On Negative Edge
N     * |        |          |0 = The received data input signal latched on the rising-edge of SPI_CLK.
N     * |        |          |1 = The received data input signal latched on the falling-edge of SPI_CLK.
N     * |[2]     |TXNEG     |Transmit On Negative Edge
N     * |        |          |0 = The transmitted data output signal is driven on the rising-edge of SPI_CLK.
N     * |        |          |1 = The transmitted data output signal is driven on the falling-edge of SPI_CLK.
N     * |[7:3]   |DWIDTH    |Transmit Bit Length
N     * |        |          |This field specifies how many bits are transmitted in one transmit/receive.
N     * |        |          |The minimum bit length is 8 bits and can up to 32 bit.
N     * |        |          |DWIDTH = 0x01~0x07 .... reserved (can't use).
N     * |        |          |DWIDTH = 0x08 .... 8 bits.
N     * |        |          |DWIDTH = 0x09 .... 9 bits.
N     * |        |          |......
N     * |        |          |DWIDTH = 0x1F .... 31 bits.
N     * |        |          |DWIDTH = 0x00 .... 32 bits.
N     * |[10]    |LSB       |LSB First
N     * |        |          |0 = The MSB is transmitted/received first.
N     * |        |          |1 = The LSB is transmitted/received first.
N     * |[11]    |CLKPOL    |Clock Polarity
N     * |        |          |0 = SPI_CLK idle low.
N     * |        |          |1 = SPI_CLK idle high.
N     * |[15:12] |SUSPITV   |Suspend Interval (Master Only)
N     * |        |          |The four bits provide configurable suspend interval between two successive transactions in a transfer.
N     * |        |          |The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word and the first clock edge of the following transaction word.
N     * |        |          |The default value is 0x3.
N     * |        |          |The period of the suspend interval is obtained according to the following equation:
N     * |        |          |(SUSPITV[3:0] + 0.5) * period of SPI_CLK clock cycle
N     * |        |          |Example:
N     * |        |          |SUSPITV = 0x0 .... 0.5 SPI_CLK clock cycle.
N     * |        |          |SUSPITV = 0x1 .... 1.5 SPI_CLK clock cycle.
N     * |        |          |......
N     * |        |          |SUSPITV = 0xE .... 14.5 SPI_CLK clock cycle.
N     * |        |          |SUSPITV = 0xF .... 15.5 SPI_CLK clock cycle.
N     * |[16]    |UNITIF    |Unit-transfer Interrupt Flag
N     * |        |          |0 = The transfer does not finish yet.
N     * |        |          |1 = The SPI controller has finished one unit transfer.
N     * |        |          |Note 1: This bit will be cleared by writing 1 to itself.
N     * |        |          |Note 2: It's a mutual mirror bit of SPI_STATUS[16].
N     * |[17]    |UNITIEN   |Unit-transfer Interrupt Enable Bit
N     * |        |          |0 = SPI unit-transfer interrupt Disabled.
N     * |        |          |1 = SPI unit-transfer interrupt Enabled.
N     * |[18]    |SLAVE     |Slave Mode Control
N     * |        |          |0 = Master mode.
N     * |        |          |1 = Slave mode.
N     * |[19]    |REORDER   |Byte Reorder Function
N     * |        |          |0 = Byte reorder function Disabled.
N     * |        |          |1 = Byte reorder function Enabled.
N     * |        |          |Note: This setting is only available if DWIDTH is defined as 16, 24, or 32 bits.
N     * |[21]    |FIFOEN    |FIFO Mode Enable Bit
N     * |        |          |0 = FIFO Mode Disabled.
N     * |        |          |1 = FIFO Mode Enabled.
N     * |        |          |Note 1: Before enabling FIFO mode, the other related settings should be set in advance.
N     * |        |          |Note 2: In Master mode, if the FIFO mode is enabled, the SPIEN bit will be set to 1 automatically after writing data into the 4-layer depth transmit FIFO.
N     * |        |          |When all data stored in transmit FIFO buffer are transferred, the SPIEN bit will back to .
N     * |[24]    |RXEMPTY   |Receive FIFO Buffer Empty Indicator (Read Only)
N     * |        |          |0 = The receive FIFO buffer is not empty.
N     * |        |          |1 = The receive FIFO buffer is empty.
N     * |        |          |Note: It's a mutual mirror bit of SPI_STATUS[24].
N     * |[25]    |RXFULL    |Receive FIFO Buffer Full Indicator (Read Only)
N     * |        |          |0 = The receive FIFO buffer is not full.
N     * |        |          |1 = The receive FIFO buffer is full.
N     * |        |          |Note: It's a mutual mirror bit of SPI_STATUS[25]
N     * |[26]    |TXEMPTY   |Transmit FIFO Buffer Empty Indicator (Read Only)
N     * |        |          |0 = The transmit FIFO buffer is not empty.
N     * |        |          |1 = The transmit FIFO buffer is empty.
N     * |        |          |Note: It's a mutual mirror bit of SPI_STAUTS[26].
N     * |[27]    |TXFULL    |Transmit FIFO Buffer Full Indicator (Read Only)
N     * |        |          |0 = The transmit FIFO buffer is not full.
N     * |        |          |1 = The transmit FIFO buffer is full.
N     * |        |          |Note: It's a mutual mirror bit of SPI_STATUS[27].
N    */
N    __IO uint32_t CTL;
X    volatile uint32_t CTL;
N
N    /**
N     * CLKDIV
N     * ===================================================================================================
N     * Offset: 0x04  SPI Clock Divider Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |DIVIDER   |Clock Divider Register (Master Only)
N     * |        |          |The value in this field is the frequency divider to determine the SPI peripheral clock frequency fspi, and the SPI master's bus clock frequency on the SPI_CLK output pin.
N     * |        |          |The frequency is obtained according to the following equation:
N     * |        |          |If the bit of DIVMOD, SPI_SLVCTL[31], is set to 0.
N     * |        |          |else if DIVMOD is set to 1,
N     * |        |          |where
N     * |        |          |is the SPI peripheral clock source which is defined in the CLK_CLKSEL1 register.
N    */
N    __IO uint32_t CLKDIV;
X    volatile uint32_t CLKDIV;
N
N    /**
N     * SSCTL
N     * ===================================================================================================
N     * Offset: 0x08  SPI Slave Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SS        |Slave Select Control Bits (Master Only)
N     * |        |          |If AUTOSS bit is 0,
N     * |        |          |0 = Set the SPI_SS line to inactive state.
N     * |        |          |1 = Set the SPI_SS line to active state.
N     * |        |          |If AUTOSS bit is 1,
N     * |        |          |0 = Keep the SPI_SS line at inactive state.
N     * |        |          |1 = Select the SPI_SS line to be automatically driven to active state for the duration of transmission/reception, and will be driven to inactive state for the rest of the time.
N     * |        |          |The active state of SPI_SS is specified in SSACTPOL bit.
N     * |[2]     |SSACTPOL  |Slave Select Active Level (Slave Only)
N     * |        |          |It defines the active status of slave select signal (SPI_SS).
N     * |        |          |If SSLTEN bit is 1:
N     * |        |          |0 = The slave select signal SPI_SS is active at low-level.
N     * |        |          |1 = The slave select signal SPI_SS is active at high-level.
N     * |        |          |If SSLTEN bit is 0:
N     * |        |          |0 = The slave select signal SPI_SS is active at falling-edge.
N     * |        |          |1 = The slave select signal SPI_SS is active at rising-edge.
N     * |[3]     |AUTOSS    |Automatic Slave Selection Function Enable Bit (Master Only)
N     * |        |          |0 = SPI_SS pin signal will be asserted/de-asserted by setting /clearing SS bit.
N     * |        |          |1 = SPI_SS pin signal will be generated automatically by hardware, which means that slave select signal will be asserted by the SPI controller when transmit/receive is started by setting SPIEN, and will be de-asserted after each transmit/receive is finished.
N     * |[4]     |SSLTEN    |Slave Select Level Trigger Enable Bit (Slave Only)
N     * |        |          |0 = The input slave select signal is edge-trigger.
N     * |        |          |1 = The input slave select signal is level-trigger.
N     * |[5]     |LTF       |Level Trigger Flag (Read Only, Slave Only)
N     * |        |          |When the SSLTEN bit is set in Slave mode, this bit can be read to indicate the received bit number is met the requirement or not.
N     * |        |          |0 = The transaction number or the transferred bit length of one transaction does not meet the specified requirements.
N     * |        |          |1 = The transaction number and the transferred bit length meet the specified requirements which defined in DWIDTH.
N    */
N    __IO uint32_t SSCTL;
X    volatile uint32_t SSCTL;
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVED0[1];
X    volatile const  uint32_t RESERVED0[1];
N    /// @endcond //HIDDEN_SYMBOLS
N
N
N    /**
N     * RX
N     * ===================================================================================================
N     * Offset: 0x10  SPI Data Receive Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |RX        |Data Receive Register (Read Only)
N     * |        |          |The Data Receive Register holds the value of received data of the last executed transfer.
N     * |        |          |Valid bits depend on the transmit bit length field DWIDTH in the SPI_CTL register.
N     * |        |          |For example, if DWIDTH is set to 0x08, the bit field RX[7:0] holds the received data.
N     * |        |          |The values of the other bits are unknown.
N     * |        |          |The Data Receive Register is read-only register.
N    */
N    __I  uint32_t RX;
X    volatile const  uint32_t RX;
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVED1[3];
X    volatile const  uint32_t RESERVED1[3];
N    /// @endcond //HIDDEN_SYMBOLS
N
N
N    /**
N     * TX
N     * ===================================================================================================
N     * Offset: 0x20  SPI Data Transmit Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |TX        |Data Transmit Register
N     * |        |          |The Data Transmit Register holds the data to be transmitted in the next transfer.
N     * |        |          |Valid bits depend on the transmit bit length field DWIDTH in the SPI_CTL register.
N     * |        |          |For example, if DWIDTH is set to 0x08, the bit filed TX[7:0] will be transmitted in next transfer.
N    */
N    __O  uint32_t TX;
X    volatile  uint32_t TX;
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVED2[6];
X    volatile const  uint32_t RESERVED2[6];
N    /// @endcond //HIDDEN_SYMBOLS
N
N
N    /**
N     * SLVCTL
N     * ===================================================================================================
N     * Offset: 0x3C  SPI Slave Control and Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8]     |SLV3WIRE  |Slave 3-wire Mode Enable Bit (Slave Only)
N     * |        |          |The SPI controller work with 3-wire interface including SPI_CLK, SPI_MISO, and SPI_MOSI.
N     * |        |          |0 = The controller is 4-wire bi-direction interface in Slave mode.
N     * |        |          |1 = The controller is 3-wire bi-direction interface in Slave mode.
N     * |        |          |The controller will be ready to transmit/receive data after the SPIEN bit is set to .
N     * |        |          |Note: In Slave 3-wire mode, the SSLTEN bit (SPI_SSCTL[4]) shall be set as 1.
N     * |[9]     |SLVABT    |Slave 3-wire Mode Abort Control Bit (Slave Only)
N     * |        |          |In normal operation, there is an interrupt event when the number of received bits meets the requirement which defined in DWIDTH.
N     * |        |          |If the number of received bits is less than the requirement and there is no more bus clock input over one transfer time in Slave 3-wire mode, user can set this bit to force the current transfer done and then user can get a unit transfer interrupt event.
N     * |        |          |0 = No force the transfer done when the SLV3WIRE bit is set to 1.
N     * |        |          |1 = Force the transfer done when the SLV3WIRE bit is set to 1.
N     * |        |          |Note: This bit will be cleared to 0 automatically by hardware after it is set to 1 by software.
N     * |[10]    |SLVSTIEN  |Slave 3-wire Mode Start Interrupt Enable (Slave Only)
N     * |        |          |It is used to enable interrupt when the transfer has started in Slave 3-wire mode.
N     * |        |          |If there is no transfer done interrupt over the time period which is defined by user after the transfer start, user can set the SLVABT bit to force the transfer don.
N     * |        |          |0 = Transaction start interrupt Disabled.
N     * |        |          |1 = Transaction start interrupt Enabled.
N     * |        |          |Note: It will be cleared to 0 as the current transfer is done or the SLVSTIF bit is cleared to 0.
N     * |[11]    |SLVSTIF   |Slave 3-wire Mode Start Interrupt Status (Slave Only)
N     * |        |          |This bit dedicates if a transaction has started in Slave 3-wire mode.
N     * |        |          |0 = Slave does not detect any SPI bus clock transfer since the SLVSTIEN bit was set to 1.
N     * |        |          |1 = The transfer has started in Slave 3-wire mode.
N     * |        |          |Note 1: It will be cleared automatically when a transaction is done or by writing 1 to this bit.
N     * |        |          |Note 2: It is a mutual mirror bit of SPI_STATUS[11].
N     * |[16]    |SSINAIEN  |Slave Select Inactive Interrupt Option (Slave Only)
N     * |        |          |0 = As the slave select signal goes to inactive level, the IF bit will NOT be set to 1.
N     * |        |          |1 = As the slave select signal goes to inactive level, the IF bit will be set to 1.
N     * |        |          |Note: This setting is only available if the SPI controller is configured as level trigger in slave device.
N     * |[31]    |DIVMOD    |Clock Configuration Backward Compatible Option
N     * |        |          |0 = The clock configuration is backward compatible.
N     * |        |          |1 = The clock configuration is not backward compatible.
N     * |        |          |Note:
N     * |        |          |Refer to the description of SPI_CLKDIV register for details.
N    */
N    __IO uint32_t SLVCTL;
X    volatile uint32_t SLVCTL;
N
N    /**
N     * FIFOCTL
N     * ===================================================================================================
N     * Offset: 0x40  SPI FIFO Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RXRST     |Clear Receive FIFO Buffer
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear receive FIFO buffer.
N     * |        |          |Note: This bit will be cleared to 0 by hardware after software sets it to 1 and the receive FIFO is cleared.
N     * |[1]     |TXRST     |Clear Transmit FIFO Buffer
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear transmit FIFO buffer.
N     * |        |          |Note: This bit will be cleared to 0 by hardware after software sets it to 1 and the transmit FIFO is cleared.
N     * |[2]     |RXTHIEN   |Receive Threshold Interrupt Enable Bit
N     * |        |          |0 = Receive threshold interrupt Disabled.
N     * |        |          |1 = Receive threshold interrupt Enabled.
N     * |[3]     |TXTHIEN   |Transmit Threshold Interrupt Enable Bit
N     * |        |          |0 = Transmit threshold interrupt Disabled.
N     * |        |          |1 = Transmit threshold interrupt Enabled.
N     * |[6]     |RXOVIEN   |Receive FIFO Overrun Interrupt Enable Bit
N     * |        |          |0 = Receive
N     * |        |          |FIFO overrun interrupt Disabled.
N     * |        |          |1 = Receive
N     * |        |          |FIFO overrun interrupt Enabled.
N     * |[21]    |RXTOIEN   |Receive FIFO Time-out Interrupt Enable Bit
N     * |        |          |0 = Time-out interrupt Disabled.
N     * |        |          |1 = Time-out interrupt Enabled.
N     * |[25:24] |RXTH      |Receive FIFO Threshold
N     * |        |          |If the valid data count of the receive FIFO buffer is larger than the RXTH setting, the RXTHIF bit will be set to 1, else the RXTHIF bit will be cleared to 0.
N     * |[29:28] |TXTH      |Transmit FIFO Threshold
N     * |        |          |If the valid data count of the transmit FIFO buffer is less than or equal to the TXTH setting, the TXTHIF bit will be set to 1, else the TXTHIF bit will be cleared to 0.
N    */
N    __IO uint32_t FIFOCTL;
X    volatile uint32_t FIFOCTL;
N
N    /**
N     * STATUS
N     * ===================================================================================================
N     * Offset: 0x44  SPI Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RXTHIF    |Receive FIFO Threshold Interrupt Status (Read Only)
N     * |        |          |0 = The valid data count within the receive FIFO buffer is less than or equal to the setting value of RXTH.
N     * |        |          |1 = The valid data count within the receive FIFO buffer is larger than the setting value of RXTH.
N     * |        |          |Note: If RXTHIEN = 1 and RXTHIF = 1, the SPI controller will generate a SPI interrupt request.
N     * |[2]     |RXOVIF    |Receive FIFO Overrun Status
N     * |        |          |When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.
N     * |        |          |0 = No overrun in receive FIFO.
N     * |        |          |1 = Overrun in receive FIFO.
N     * |        |          |Note: This bit will be cleared by writing 1 to itself.
N     * |[4]     |TXTHIF    |Transmit FIFO Threshold Interrupt Status (Read Only)
N     * |        |          |0 = The valid data count within the transmit FIFO buffer is larger than the setting value of TXTH.
N     * |        |          |1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TXTH.
N     * |        |          |Note: If TXTHIEN = 1 and TXTHIF = 1, the SPI controller will generate a SPI interrupt request.
N     * |[11]    |SLVSTIF   |Slave Start Interrupt Status (Slave Only)
N     * |        |          |It is used to dedicate that the transfer has started in slave 3-wire mode.
N     * |        |          |0 = Slave does not detect any SPI bus clock transfer since the SLVSTIEN bit was set to 1.
N     * |        |          |The transfer is not started.
N     * |        |          |1 = The transfer has started in Slave 3-wire mode.
N     * |        |          |Note 1: It will be cleared as transfer done or by writing one to this bit.
N     * |        |          |Note 2: It's a mutual mirror bit of SPI_SLVCTL[11].
N     * |[15:12] |RXCNT     |Receive FIFO Data Count (Read Only)
N     * |        |          |Indicates the valid data count of receive FIFO buffer.
N     * |[16]    |UNITIF    |SPI Unit-transfer Interrupt Flag
N     * |        |          |0 = The transfer does not finish yet.
N     * |        |          |1 = The SPI controller has finished one unit transfer.
N     * |        |          |Note 1: This bit will be cleared by writing 1 to itself.
N     * |        |          |Note 2: It's a mutual mirror bit of SPI_CTL[16].
N     * |[20]    |SLVTOIF   |Time-out Interrupt Flag
N     * |        |          |0 = No receive FIFO time-out event.
N     * |        |          |1 = The receive FIFO buffer is not empty and it does not be read over 64 SPI clock periods in Master mode or over 576 SPI peripheral clock periods in Slave mode.
N     * |        |          |When the received FIFO buffer is read by software, the time-out status will be cleared automatically.
N     * |        |          |Note: This bit will be cleared by writing 1 to itself.
N     * |[24]    |RXEMPTY   |Receive FIFO Buffer Empty Indicator (Read Only)
N     * |        |          |0 = The receive FIFO buffer is not empty.
N     * |        |          |1 = The receive FIFO buffer is empty.
N     * |        |          |Note: It's a mutual mirror bit of SPI_CTL[24].
N     * |[25]    |RXFULL    |Receive FIFO Buffer Full Indicator (Read Only)
N     * |        |          |0 = The receive FIFO buffer is not full.
N     * |        |          |1 = The receive FIFO buffer is full.
N     * |        |          |Note: It's a mutual mirror bit of SPI_CTL[25].
N     * |[26]    |TXEMPTY   |Transmit FIFO Buffer Empty Indicator (Read Only)
N     * |        |          |0 = The transmit FIFO buffer is not empty.
N     * |        |          |1 = The transmit FIFO buffer is empty.
N     * |        |          |Note: It's a mutual mirror bit of SPI_CTL[26].
N     * |[27]    |TXFULL    |Transmit FIFO Buffer Full Indicator (Read Only)
N     * |        |          |0 = The transmit FIFO buffer is not full.
N     * |        |          |1 = The transmit FIFO buffer is full.
N     * |        |          |Note: It's a mutual mirror bit of SPI_CTL[27].
N     * |[31:28] |TXCNT     |Transmit FIFO Data Count (Read Only)
N     * |        |          |Indicates the valid data count of transmit FIFO buffer.
N    */
N    __IO  uint32_t STATUS;
X    volatile  uint32_t STATUS;
N
N} SPI_T;
N
N/**
N    @addtogroup SPI_CONST SPI Bit Field Definition
N    Constant Definitions for SPI Controller
N@{ */
N
N#define SPI_CTL_SPIEN_Pos                (0)                                               /*!< SPI_T::CTL: SPIEN Position                */
N#define SPI_CTL_SPIEN_Msk                (0x1ul << SPI_CTL_SPIEN_Pos)                      /*!< SPI_T::CTL: SPIEN Mask                    */
N
N#define SPI_CTL_RXNEG_Pos                (1)                                               /*!< SPI_T::CTL: RXNEG Position                */
N#define SPI_CTL_RXNEG_Msk                (0x1ul << SPI_CTL_RXNEG_Pos)                      /*!< SPI_T::CTL: RXNEG Mask                    */
N
N#define SPI_CTL_TXNEG_Pos                (2)                                               /*!< SPI_T::CTL: TXNEG Position                */
N#define SPI_CTL_TXNEG_Msk                (0x1ul << SPI_CTL_TXNEG_Pos)                      /*!< SPI_T::CTL: TXNEG Mask                    */
N
N#define SPI_CTL_DWIDTH_Pos               (3)                                               /*!< SPI_T::CTL: DWIDTH Position               */
N#define SPI_CTL_DWIDTH_Msk               (0x1ful << SPI_CTL_DWIDTH_Pos)                    /*!< SPI_T::CTL: DWIDTH Mask                   */
N
N#define SPI_CTL_LSB_Pos                  (10)                                              /*!< SPI_T::CTL: LSB Position                  */
N#define SPI_CTL_LSB_Msk                  (0x1ul << SPI_CTL_LSB_Pos)                        /*!< SPI_T::CTL: LSB Mask                      */
N
N#define SPI_CTL_CLKPOL_Pos               (11)                                              /*!< SPI_T::CTL: CLKPOL Position               */
N#define SPI_CTL_CLKPOL_Msk               (0x1ul << SPI_CTL_CLKPOL_Pos)                     /*!< SPI_T::CTL: CLKPOL Mask                   */
N
N#define SPI_CTL_SUSPITV_Pos              (12)                                              /*!< SPI_T::CTL: SUSPITV Position              */
N#define SPI_CTL_SUSPITV_Msk              (0xful << SPI_CTL_SUSPITV_Pos)                    /*!< SPI_T::CTL: SUSPITV Mask                  */
N
N#define SPI_CTL_UNITIF_Pos               (16)                                              /*!< SPI_T::CTL: UNITIF Position               */
N#define SPI_CTL_UNITIF_Msk               (0x1ul << SPI_CTL_UNITIF_Pos)                     /*!< SPI_T::CTL: UNITIF Mask                   */
N
N#define SPI_CTL_UNITIEN_Pos              (17)                                              /*!< SPI_T::CTL: UNITIEN Position              */
N#define SPI_CTL_UNITIEN_Msk              (0x1ul << SPI_CTL_UNITIEN_Pos)                    /*!< SPI_T::CTL: UNITIEN Mask                  */
N
N#define SPI_CTL_SLAVE_Pos                (18)                                              /*!< SPI_T::CTL: SLAVE Position                */
N#define SPI_CTL_SLAVE_Msk                (0x1ul << SPI_CTL_SLAVE_Pos)                      /*!< SPI_T::CTL: SLAVE Mask                    */
N
N#define SPI_CTL_REORDER_Pos              (19)                                              /*!< SPI_T::CTL: REORDER Position              */
N#define SPI_CTL_REORDER_Msk              (0x1ul << SPI_CTL_REORDER_Pos)                    /*!< SPI_T::CTL: REORDER Mask                  */
N
N#define SPI_CTL_FIFOEN_Pos               (21)                                              /*!< SPI_T::CTL: FIFOEN Position               */
N#define SPI_CTL_FIFOEN_Msk               (0x1ul << SPI_CTL_FIFOEN_Pos)                     /*!< SPI_T::CTL: FIFOEN Mask                   */
N
N#define SPI_CTL_RXEMPTY_Pos              (24)                                              /*!< SPI_T::CTL: RXEMPTY Position              */
N#define SPI_CTL_RXEMPTY_Msk              (0x1ul << SPI_CTL_RXEMPTY_Pos)                    /*!< SPI_T::CTL: RXEMPTY Mask                  */
N
N#define SPI_CTL_RXFULL_Pos               (25)                                              /*!< SPI_T::CTL: RXFULL Position               */
N#define SPI_CTL_RXFULL_Msk               (0x1ul << SPI_CTL_RXFULL_Pos)                     /*!< SPI_T::CTL: RXFULL Mask                   */
N
N#define SPI_CTL_TXEMPTY_Pos              (26)                                              /*!< SPI_T::CTL: TXEMPTY Position              */
N#define SPI_CTL_TXEMPTY_Msk              (0x1ul << SPI_CTL_TXEMPTY_Pos)                    /*!< SPI_T::CTL: TXEMPTY Mask                  */
N
N#define SPI_CTL_TXFULL_Pos               (27)                                              /*!< SPI_T::CTL: TXFULL Position               */
N#define SPI_CTL_TXFULL_Msk               (0x1ul << SPI_CTL_TXFULL_Pos)                     /*!< SPI_T::CTL: TXFULL Mask                   */
N
N#define SPI_CLKDIV_DIVIDER_Pos           (0)                                               /*!< SPI_T::CLKDIV: DIVIDER Position           */
N#define SPI_CLKDIV_DIVIDER_Msk           (0xfful << SPI_CLKDIV_DIVIDER_Pos)                /*!< SPI_T::CLKDIV: DIVIDER Mask               */
N
N#define SPI_SSCTL_SS_Pos                 (0)                                               /*!< SPI_T::SSCTL: SS Position                 */
N#define SPI_SSCTL_SS_Msk                 (0x1ul << SPI_SSCTL_SS_Pos)                       /*!< SPI_T::SSCTL: SS Mask                     */
N
N#define SPI_SSCTL_SSACTPOL_Pos           (2)                                               /*!< SPI_T::SSCTL: SSACTPOL Position           */
N#define SPI_SSCTL_SSACTPOL_Msk           (0x1ul << SPI_SSCTL_SSACTPOL_Pos)                 /*!< SPI_T::SSCTL: SSACTPOL Mask               */
N
N#define SPI_SSCTL_AUTOSS_Pos             (3)                                               /*!< SPI_T::SSCTL: AUTOSS Position             */
N#define SPI_SSCTL_AUTOSS_Msk             (0x1ul << SPI_SSCTL_AUTOSS_Pos)                   /*!< SPI_T::SSCTL: AUTOSS Mask                 */
N
N#define SPI_SSCTL_SSLTEN_Pos             (4)                                               /*!< SPI_T::SSCTL: SSLTEN Position             */
N#define SPI_SSCTL_SSLTEN_Msk             (0x1ul << SPI_SSCTL_SSLTEN_Pos)                   /*!< SPI_T::SSCTL: SSLTEN Mask                 */
N
N#define SPI_SSCTL_LTF_Pos                (5)                                               /*!< SPI_T::SSCTL: LTF Position                */
N#define SPI_SSCTL_LTF_Msk                (0x1ul << SPI_SSCTL_LTF_Pos)                      /*!< SPI_T::SSCTL: LTF Mask                    */
N
N#define SPI_RX_RX_Pos                    (0)                                               /*!< SPI_T::RX: RX Position                    */
N#define SPI_RX_RX_Msk                    (0xfffffffful << SPI_RX_RX_Pos)                   /*!< SPI_T::RX: RX Mask                        */
N
N#define SPI_TX_TX_Pos                    (0)                                               /*!< SPI_T::TX: TX Position                    */
N#define SPI_TX_TX_Msk                    (0xfffffffful << SPI_TX_TX_Pos)                   /*!< SPI_T::TX: TX Mask                        */
N
N#define SPI_SLVCTL_SLV3WIRE_Pos          (8)                                               /*!< SPI_T::SLVCTL: SLV3WIRE Position          */
N#define SPI_SLVCTL_SLV3WIRE_Msk          (0x1ul << SPI_SLVCTL_SLV3WIRE_Pos)                /*!< SPI_T::SLVCTL: SLV3WIRE Mask              */
N
N#define SPI_SLVCTL_SLVABT_Pos            (9)                                               /*!< SPI_T::SLVCTL: SLVABT Position            */
N#define SPI_SLVCTL_SLVABT_Msk            (0x1ul << SPI_SLVCTL_SLVABT_Pos)                  /*!< SPI_T::SLVCTL: SLVABT Mask                */
N
N#define SPI_SLVCTL_SLVSTIEN_Pos          (10)                                              /*!< SPI_T::SLVCTL: SLVSTIEN Position          */
N#define SPI_SLVCTL_SLVSTIEN_Msk          (0x1ul << SPI_SLVCTL_SLVSTIEN_Pos)                /*!< SPI_T::SLVCTL: SLVSTIEN Mask              */
N
N#define SPI_SLVCTL_SLVSTIF_Pos           (11)                                              /*!< SPI_T::SLVCTL: SLVSTIF Position           */
N#define SPI_SLVCTL_SLVSTIF_Msk           (0x1ul << SPI_SLVCTL_SLVSTIF_Pos)                 /*!< SPI_T::SLVCTL: SLVSTIF Mask               */
N
N#define SPI_SLVCTL_SSINAIEN_Pos          (16)                                              /*!< SPI_T::SLVCTL: SSINAIEN Position          */
N#define SPI_SLVCTL_SSINAIEN_Msk          (0x1ul << SPI_SLVCTL_SSINAIEN_Pos)                /*!< SPI_T::SLVCTL: SSINAIEN Mask              */
N
N#define SPI_SLVCTL_DIVMOD_Pos            (31)                                              /*!< SPI_T::SLVCTL: DIVMOD Position            */
N#define SPI_SLVCTL_DIVMOD_Msk            (0x1ul << SPI_SLVCTL_DIVMOD_Pos)                  /*!< SPI_T::SLVCTL: DIVMOD Mask                */
N
N#define SPI_FIFOCTL_RXRST_Pos            (0)                                               /*!< SPI_T::FIFOCTL: RXRST Position            */
N#define SPI_FIFOCTL_RXRST_Msk            (0x1ul << SPI_FIFOCTL_RXRST_Pos)                  /*!< SPI_T::FIFOCTL: RXRST Mask                */
N
N#define SPI_FIFOCTL_TXRST_Pos            (1)                                               /*!< SPI_T::FIFOCTL: TXRST Position            */
N#define SPI_FIFOCTL_TXRST_Msk            (0x1ul << SPI_FIFOCTL_TXRST_Pos)                  /*!< SPI_T::FIFOCTL: TXRST Mask                */
N
N#define SPI_FIFOCTL_RXTHIEN_Pos          (2)                                               /*!< SPI_T::FIFOCTL: RXTHIEN Position          */
N#define SPI_FIFOCTL_RXTHIEN_Msk          (0x1ul << SPI_FIFOCTL_RXTHIEN_Pos)                /*!< SPI_T::FIFOCTL: RXTHIEN Mask              */
N
N#define SPI_FIFOCTL_TXTHIEN_Pos          (3)                                               /*!< SPI_T::FIFOCTL: TXTHIEN Position          */
N#define SPI_FIFOCTL_TXTHIEN_Msk          (0x1ul << SPI_FIFOCTL_TXTHIEN_Pos)                /*!< SPI_T::FIFOCTL: TXTHIEN Mask              */
N
N#define SPI_FIFOCTL_RXOVIEN_Pos          (6)                                               /*!< SPI_T::FIFOCTL: RXOVIEN Position          */
N#define SPI_FIFOCTL_RXOVIEN_Msk          (0x1ul << SPI_FIFOCTL_RXOVIEN_Pos)                /*!< SPI_T::FIFOCTL: RXOVIEN Mask              */
N
N#define SPI_FIFOCTL_RXTOIEN_Pos          (21)                                              /*!< SPI_T::FIFOCTL: RXTOIEN Position          */
N#define SPI_FIFOCTL_RXTOIEN_Msk          (0x1ul << SPI_FIFOCTL_RXTOIEN_Pos)                /*!< SPI_T::FIFOCTL: RXTOIEN Mask              */
N
N#define SPI_FIFOCTL_RXTH_Pos             (24)                                              /*!< SPI_T::FIFOCTL: RXTH Position             */
N#define SPI_FIFOCTL_RXTH_Msk             (0x3ul << SPI_FIFOCTL_RXTH_Pos)                   /*!< SPI_T::FIFOCTL: RXTH Mask                 */
N
N#define SPI_FIFOCTL_TXTH_Pos             (28)                                              /*!< SPI_T::FIFOCTL: TXTH Position             */
N#define SPI_FIFOCTL_TXTH_Msk             (0x3ul << SPI_FIFOCTL_TXTH_Pos)                   /*!< SPI_T::FIFOCTL: TXTH Mask                 */
N
N#define SPI_STATUS_RXTHIF_Pos            (0)                                               /*!< SPI_T::STATUS: RXTHIF Position            */
N#define SPI_STATUS_RXTHIF_Msk            (0x1ul << SPI_STATUS_RXTHIF_Pos)                  /*!< SPI_T::STATUS: RXTHIF Mask                */
N
N#define SPI_STATUS_RXOVIF_Pos            (2)                                               /*!< SPI_T::STATUS: RXOVIF Position            */
N#define SPI_STATUS_RXOVIF_Msk            (0x1ul << SPI_STATUS_RXOVIF_Pos)                  /*!< SPI_T::STATUS: RXOVIF Mask                */
N
N#define SPI_STATUS_TXTHIF_Pos            (4)                                               /*!< SPI_T::STATUS: TXTHIF Position            */
N#define SPI_STATUS_TXTHIF_Msk            (0x1ul << SPI_STATUS_TXTHIF_Pos)                  /*!< SPI_T::STATUS: TXTHIF Mask                */
N
N#define SPI_STATUS_SLVSTIF_Pos           (11)                                              /*!< SPI_T::STATUS: SLVSTIF Position           */
N#define SPI_STATUS_SLVSTIF_Msk           (0x1ul << SPI_STATUS_SLVSTIF_Pos)                 /*!< SPI_T::STATUS: SLVSTIF Mask               */
N
N#define SPI_STATUS_RXCNT_Pos             (12)                                              /*!< SPI_T::STATUS: RXCNT Position             */
N#define SPI_STATUS_RXCNT_Msk             (0xful << SPI_STATUS_RXCNT_Pos)                   /*!< SPI_T::STATUS: RXCNT Mask                 */
N
N#define SPI_STATUS_UNITIF_Pos            (16)                                              /*!< SPI_T::STATUS: UNITIF Position            */
N#define SPI_STATUS_UNITIF_Msk            (0x1ul << SPI_STATUS_UNITIF_Pos)                  /*!< SPI_T::STATUS: UNITIF Mask                */
N
N#define SPI_STATUS_SLVTOIF_Pos           (20)                                              /*!< SPI_T::STATUS: SLVTOIF Position           */
N#define SPI_STATUS_SLVTOIF_Msk           (0x1ul << SPI_STATUS_SLVTOIF_Pos)                 /*!< SPI_T::STATUS: SLVTOIF Mask               */
N
N#define SPI_STATUS_RXEMPTY_Pos           (24)                                              /*!< SPI_T::STATUS: RXEMPTY Position           */
N#define SPI_STATUS_RXEMPTY_Msk           (0x1ul << SPI_STATUS_RXEMPTY_Pos)                 /*!< SPI_T::STATUS: RXEMPTY Mask               */
N
N#define SPI_STATUS_RXFULL_Pos            (25)                                              /*!< SPI_T::STATUS: RXFULL Position            */
N#define SPI_STATUS_RXFULL_Msk            (0x1ul << SPI_STATUS_RXFULL_Pos)                  /*!< SPI_T::STATUS: RXFULL Mask                */
N
N#define SPI_STATUS_TXEMPTY_Pos           (26)                                              /*!< SPI_T::STATUS: TXEMPTY Position           */
N#define SPI_STATUS_TXEMPTY_Msk           (0x1ul << SPI_STATUS_TXEMPTY_Pos)                 /*!< SPI_T::STATUS: TXEMPTY Mask               */
N
N#define SPI_STATUS_TXFULL_Pos            (27)                                              /*!< SPI_T::STATUS: TXFULL Position            */
N#define SPI_STATUS_TXFULL_Msk            (0x1ul << SPI_STATUS_TXFULL_Pos)                  /*!< SPI_T::STATUS: TXFULL Mask                */
N
N#define SPI_STATUS_TXCNT_Pos             (28)                                              /*!< SPI_T::STATUS: TXCNT Position             */
N#define SPI_STATUS_TXCNT_Msk             (0xful << SPI_STATUS_TXCNT_Pos)                   /*!< SPI_T::STATUS: TXCNT Mask                 */
N
N/**@}*/ /* SPI_CONST */
N/**@}*/ /* end of SPI register group */
N
N
N/*---------------------- System Manger Controller -------------------------*/
N/**
N    @addtogroup SYS System Manger Controller(SYS)
N    Memory Mapped Structure for SYS Controller
N@{ */
N
Ntypedef struct {
N
N
N    /**
N     * PDID
N     * ===================================================================================================
N     * Offset: 0x00  Part Device Identification Number Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |PDID      |Product Device Identification Number (Read Only)
N     * |        |          |This register reflects the device part number code.
N     * |        |          |Software can read this register to identify which device is use.
N     * |        |          |For example, the MINI58LDE PDID code is "0x00A05800".
N    */
N    __I  uint32_t PDID;
X    volatile const  uint32_t PDID;
N
N    /**
N     * RSTSTS
N     * ===================================================================================================
N     * Offset: 0x04  System Reset Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PORF      |POR Reset Flag
N     * |        |          |The POR reset flag is set by the "Reset Signal" from the Power-on Reset (POR) Controller or bit CHIPRST (SYS_IPRST0[0]) to indicate the previous reset source.
N     * |        |          |0 = No reset from POR or CHIPRST.
N     * |        |          |1 = Power-on-Reset (POR) or CHIPRST had issued the reset signal to reset the system.
N     * |        |          |Note: Software can write 1 to clear this bit to zero.
N     * |[1]     |PINRF     |NRESET Pin Reset Flag
N     * |        |          |The nRESET pin reset flag is set by the "Reset Signal" from the nRESET pin to indicate the previous reset source.
N     * |        |          |0 = No reset from nRESET pin.
N     * |        |          |1 = Pin nRESET had issued the reset signal to reset the system.
N     * |        |          |Note: Software can write 1 to clear this bit to zero.
N     * |[2]     |WDTRF     |WDT Reset Flag
N     * |        |          |The WDT reset flag is set by the "Reset Signal" from the Watchdog Timer or Window Watchdog Timer to indicate the previous reset source.
N     * |        |          |0 = No reset from watchdog timer or window watchdog timer.
N     * |        |          |1 = The watchdog timer or window watchdog timer had issued the reset signal to reset the system.
N     * |        |          |Note: Software can write 1 to clear this bit to zero.
N     * |[4]     |BODRF     |BOD Reset Flag
N     * |        |          |The BOD reset flag is set by the "Reset Signal" from the Brown-out Detector to indicate the previous reset source.
N     * |        |          |0 = No reset from BOD.
N     * |        |          |1 = The BOD had issued the reset signal to reset the system.
N     * |        |          |Note: Software can write 1 to clear this bit to zero.
N     * |[5]     |SYSRF     |System Reset Flag
N     * |        |          |The system reset flag is set by the "Reset Signal" from the Cortex-M0 Core to indicate the previous reset source.
N     * |        |          |0 = No reset from Cortex-M0.
N     * |        |          |1 = The Cortex-M0 had issued the reset signal to reset the system by writing 1 to the bit SYSRESETREQ (SCS_AIRCR[2]), Application Interrupt and Reset Control Register, address = 0xE000ED0C in system control registers of Cortex-M0 core.
N     * |        |          |Note: Software can write 1 to clear this bit to zero.
N     * |[7]     |CPURF     |CPU Reset Flag
N     * |        |          |The CPU reset flag is set by hardware if software writes CPURST (SYS_IPRST0[1]) 1 to reset Cortex-M0 Core and Flash Memory Controller (FMC).
N     * |        |          |0 = No reset from CPU.
N     * |        |          |1 = The Cortex-M0 Core and FMC are reset by software setting CPURST to 1.
N     * |        |          |Note: Software can write 1 to clear this bit to zero.
N     * |[8]     |CPULKRF   |The Cortex-M0 LOCKUP Flag
N     * |        |          |0 = No reset from Cortex-M0 LOCKUP happened.
N     * |        |          |1 = The Cortex-M0 LOCKUP happened and chip is reset.
N     * |        |          |Note: Software can write 1 to clear this bit to zero.
N    */
N    __IO uint32_t RSTSTS;
X    volatile uint32_t RSTSTS;
N
N    /**
N     * IPRST0
N     * ===================================================================================================
N     * Offset: 0x08  Peripheral Reset Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CHIPRST   |CHIP One-shot Reset (Write Protect)
N     * |        |          |Setting this bit will reset the whole chip, including Processor core and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.
N     * |        |          |The CHIPRST is the same as the POR reset, all the chip controllers is reset and the chip settings from flash are also reload.
N     * |        |          |0 = Chip normal operation.
N     * |        |          |1 = CHIP one-shot reset.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[1]     |CPURST    |Processor Core One-shot Reset (Write Protect)
N     * |        |          |Setting this bit will only reset the processor core and Flash Memory Controller (FMC), and this bit will automatically return to 0 after the 2 clock cycles.
N     * |        |          |0 = Processor core normal operation.
N     * |        |          |1 = Processor core one-shot reset.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N    */
N    __IO uint32_t IPRST0;
X    volatile uint32_t IPRST0;
N
N    /**
N     * IPRST1
N     * ===================================================================================================
N     * Offset: 0x0C  Peripheral Reset Control Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |GPIORST   |GPIO (P0~P5) Controller Reset
N     * |        |          |0 = GPIO controller normal operation.
N     * |        |          |1 = GPIO controller reset.
N     * |[2]     |TMR0RST   |Timer0 Controller Reset
N     * |        |          |0 = Timer0 controller normal operation.
N     * |        |          |1 = Timer0 controller reset.
N     * |[3]     |TMR1RST   |Timer1 Controller Reset
N     * |        |          |0 = Timer1 controller normal operation.
N     * |        |          |1 = Timer1 controller reset.
N     * |[8]     |I2C0RST   |I2C0 Controller Reset
N     * |        |          |0 = I2C0 controller normal operation.
N     * |        |          |1 = I2C0 controller reset.
N     * |[9]     |I2C1RST   |I2C1 Controller Reset
N     * |        |          |0 = I2C1 controller normal operation.
N     * |        |          |1 = I2C1 controller reset.
N     * |[12]    |SPI0RST   |SPI0 Controller Reset
N     * |        |          |0 = SPI controller normal operation.
N     * |        |          |1 = SPI controller reset.
N     * |[16]    |UART0RST  |UART0 Controller Reset
N     * |        |          |0 = UART0 controller normal operation.
N     * |        |          |1 = UART0 controller reset.
N     * |[17]    |UART1RST  |UART1 Controller Reset
N     * |        |          |0 = UART1 controller normal operation.
N     * |        |          |1 = UART1 controller reset.
N     * |[20]    |PWM0RST   |PWM0 Controller Reset
N     * |        |          |0 = PWM0 controller normal operation.
N     * |        |          |1 = PWM0 controller reset.
N     * |[22]    |ACMPRST   |ACMP Controller Reset
N     * |        |          |0 = ACMP controller normal operation.
N     * |        |          |1 = ACMP controller reset.
N     * |[28]    |ADCRST    |ADC Controller Reset
N     * |        |          |0 = ADC controller normal operation.
N     * |        |          |1 = ADC controller reset.
N    */
N    __IO uint32_t IPRST1;
X    volatile uint32_t IPRST1;
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVED0[2];
X    volatile const  uint32_t RESERVED0[2];
N    /// @endcond //HIDDEN_SYMBOLS
N
N
N    /**
N     * BODCTL
N     * ===================================================================================================
N     * Offset: 0x18  Brown-out Detector Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BODEN     |Brown-out Detector Selection Extension (Initiated & Write-protected Bit)
N     * |        |          |The default value is set by flash controller user configuration register config0 bit[23].
N     * |        |          |If config0 bit[23] is set to 1, default value of BODEN is 0.
N     * |        |          |If config0 bit[23] is set to 0, default value of BODEN is 1.
N     * |        |          |0 = Brown-out detector threshold voltage is selected by the table defined in BODVL.
N     * |        |          |1 = Brown-out detector threshold voltage is selected by the table defined as below.
N     * |        |          |BODVL = 00 = Brown-out Detector threshold voltage is 2.2V.
N     * |        |          |BODVL = 01 = Brown-out Detector threshold voltage is 2.7V.
N     * |        |          |BODVL = 10 = Brown-out Detector threshold voltage is 3.7V.
N     * |        |          |BODVL = 11 = Brown-out Detector threshold voltage is 4.4V.
N     * |[2:1]   |BODVL     |Brown-out Detector Threshold Voltage Selection (Write Protect)
N     * |        |          |The default value is set by flash controller user configuration register CBOV (CONFIG0[22:21]).
N     * |        |          |00 = Reserved.
N     * |        |          |01 = Brown-out Detector threshold voltage is 2.7V.
N     * |        |          |10 = Brown-out Detector threshold voltage is 3.7V.
N     * |        |          |11 = Brown-out Detector function Disabled.
N     * |[3]     |BODRSTEN  |Brown-out Reset Enable Bit (Write Protect)
N     * |        |          |The default value is set by flash controller user configuration register CBORST(CONFIG0[20]) bit.
N     * |        |          |0 = Brown-out "INTERRUPT" function Enabled; when the Brown-out Detector function is enable and the detected voltage is lower than the threshold, then assert a signal to interrupt the Cortex-M0 CPU.
N     * |        |          |1 = Brown-out "RESET" function Enabled; when the Brown-out Detector function is enable and the detected voltage is lower than the threshold then assert a signal to reset the chip.
N     * |        |          |Note: When the BOD_EN is enabled and the interrupt is asserted, the interrupt will be kept till the BOD_EN is set to 0.
N     * |        |          |The interrupt for CPU can be blocked by disabling the NVIC in CPU for BOD interrupt or disable the interrupt source by disabling the BOD_EN and then re-enabling the BOD_EN function if the BOD function is require.
N     * |[4]     |BODIF     |Brown-out Detector Interrupt Flag
N     * |        |          |0 = Brown-out Detector does not detect any voltage draft at VDD down through or up through the voltage of BODVL setting.
N     * |        |          |1 = When Brown-out Detector detects the VDD is dropped through the voltage of BODVL setting or the VDD is raised up through the voltage of BODVL setting, this bit is set to 1 and the Brown-out interrupt is requested if Brown-out interrupt is enabled.
N     * |[5]     |BODLPM    |Brown-out Detector Low Power Mode (Write Protect)
N     * |        |          |0 = BOD operate in normal mode (default).
N     * |        |          |1 = BOD Low Power mode Enabled.
N     * |        |          |Note: The BOD consumes about 100uA in normal mode, the low power mode can reduce the current to about 1/10 but slow the BOD response.
N     * |[6]     |BODOUT    |Brown-out Detector Output Status
N     * |        |          |0 = Brown-out Detector status output is 0, the detected voltage is higher than BODVL setting.
N     * |        |          |1 = Brown-out Detector status output is 1, the detected voltage is lower than BODVL setting.
N    */
N    __IO uint32_t BODCTL;
X    volatile uint32_t BODCTL;
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVED1[5];
X    volatile const  uint32_t RESERVED1[5];
N    /// @endcond //HIDDEN_SYMBOLS
N
N
N    /**
N     * P0_MFP
N     * ===================================================================================================
N     * Offset: 0x30  P0 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |MFP       |P0 Multiple Function Select Bit
N     * |        |          |The pin function of P0 depends on MFP and ALT.
N     * |        |          |Refer to ALT Description for details.
N     * |[8]     |ALT0      |P0.0 Alternate Function Select Bit
N     * |        |          |Bits ALT[0] (SYS_P0_MFP[8]), and MFP[0] (SYS_P0_MFP[0]) determine the P0.0 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = Reserved.
N     * |        |          |(1, 0) = UART0_nCTS function is selected.
N     * |        |          |(1, 1) = UART0_TXD function is selected.
N     * |[9]     |ALT1      |P0.1 Alternate Function Select Bit
N     * |        |          |Bits ALT[1] (SYS_P0_MFP[9]), and MFP[1] (SYS_P0_MFP[1]) determine the P0.1 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = SPI0_SS function is selected.
N     * |        |          |(1, 0) = UART0_nRTS function is selected.
N     * |        |          |(1, 1) = UART0_RXD function is selected.
N     * |[12]    |ALT4      |P0.4 Alternate Function Select Bit
N     * |        |          |Bits ALT[4] (SYS_P0_MFP[12]), and MFP[4] (SYS_P0_MFP[4]) determine the P0.4 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = Reserved.
N     * |        |          |(1, 0) = SPI0_SS function is selected.
N     * |        |          |(1, 1) = PWM0_CH5 function is selected.
N     * |[13]    |ALT5      |P0.5 Alternate Function Select Bit
N     * |        |          |Bits ALT[5] (SYS_P0_MFP[13]), and MFP[5] (SYS_P0_MFP[5]) determine the P0.5 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = Reserved.
N     * |        |          |(1, 0) = SPI0_MOSI function is selected.
N     * |        |          |(1, 1) = PWM0_CH4 function is selected.
N     * |[14]    |ALT6      |P0.6 Alternate Function Select Bit
N     * |        |          |Bits ALT[6] (SYS_P0_MFP[14]), and MFP[6] (SYS_P0_MFP[6]) determine the P0.6 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = Reserved.
N     * |        |          |(1, 0) = SPI0_MISO function is selected.
N     * |        |          |(1, 1) = PWM0_CH1 function is selected.
N     * |[15]    |ALT7      |P0.7 Alternate Function Select Bit
N     * |        |          |Bits ALT[7] (SYS_P0_MFP[15]), and MFP[7] (SYS_P0_MFP[7]) determine the P0.7 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = Reserved.
N     * |        |          |(1, 0) = SPI0_CLK function is selected.
N     * |        |          |(1, 1) = PWM0_CH0 function is selected.
N     * |[23:16] |TYPE      |P0[7:0] Input Schmitt Trigger Function Enable Bits
N     * |        |          |0 = P0[7:0] I/O input Schmitt Trigger function Disabled.
N     * |        |          |1 = P0[7:0] I/O input Schmitt Trigger function Enabled.
N    */
N    __IO uint32_t P0_MFP;
X    volatile uint32_t P0_MFP;
N
N    /**
N     * P1_MFP
N     * ===================================================================================================
N     * Offset: 0x34  P1 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |MFP       |P1 Multiple Function Select Bit
N     * |        |          |The pin function of P1 depends on MFP and ALT.
N     * |        |          |Refer to ALT Description for details.
N     * |[8]     |ALT0      |P1.0 Alternate Function Select Bit
N     * |        |          |Bits ALT[0] (SYS_P1_MFP[8]), and MFP[0] (SYS_P1_MFP[0]) determine the P1.0 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = ADC_CH1 function is selected.
N     * |        |          |(1, 0) = Reserved.
N     * |        |          |(1, 1) = ACMP0_P1 function is selected.
N     * |[10]    |ALT2      |P1.2 Alternate Function Select Bit
N     * |        |          |Bits P12EXT (SYS_P1_MFP[26]), ALT[2] (SYS_P1_MFP[10]), and MFP[2] (SYS_P1_MFP[2]) determine the P1.2 function.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = ADC_CH2 function is selected.
N     * |        |          |(0, 1, 0) = UART0_RXD function is selected.
N     * |        |          |(0, 1, 1) = ACMP0_P2 function is selected.
N     * |        |          |(1, 0, 0) = PWM0_CH0 function is selected.
N     * |[11]    |ALT3      |P1.3 Alternate Function Select Bit
N     * |        |          |Bits P13EXT (SYS_P1_MFP[27]), ALT[3] (SYS_P1_MFP[11]), and MFP[3] (SYS_P1_MFP[3]) determine the P1.3 function.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = ADC_CH3 function is selected.
N     * |        |          |(0, 1, 0) = UART0_TXD function is selected.
N     * |        |          |(0, 1, 1) = ACMP0_P3 function is selected.
N     * |        |          |(1, 0, 0) = PWM0_CH1 function is selected.
N     * |[12]    |ALT4      |P1.4 Alternate Function Select Bit
N     * |        |          |Bits P14EXT (SYS_P1_MFP[28]), ALT[4] (SYS_P1_MFP[12]), and MFP[4] (SYS_P1_MFP[4]) determine the P1.4 function.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = ADC_CH4 function is selected.
N     * |        |          |(0, 1, 0) = UART1_RXD function is selected.
N     * |        |          |(0, 1, 1) = ACMP0_N function is selected.
N     * |        |          |(1, 0, 0) = PWM0_CH4 function is selected.
N     * |[13]    |ALT5      |P1.5 Alternate Function Select Bit
N     * |        |          |Bits ALT[5] (SYS_P1_MFP[13]), and MFP[5] (SYS_P1_MFP[5]) determine the P1.5 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = ADC_CH5 function is selected.
N     * |        |          |(1, 0) = UART1_TXD function is selected.
N     * |        |          |(1, 1) = ACMP0_P0 function is selected.
N     * |[23:16] |TYPE      |P1[7:0] Input Schmitt Trigger Function Enable Bit
N     * |        |          |0 = P1[7:0] I/O input Schmitt Trigger function Disabled.
N     * |        |          |1 = P1[7:0] I/O input Schmitt Trigger function Enabled.
N     * |[26]    |P12EXT    |P1.2 Alternate Function Selection Extension
N     * |        |          |Bits P12EXT (SYS_P1_MFP[26]), ALT[2] (SYS_P1_MFP[10]), and MFP[2] (SYS_P1_MFP[2]) determine the P1.2 function.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = ADC_CH2 function is selected.
N     * |        |          |(0, 1, 0) = UART0_RXD function is selected.
N     * |        |          |(0, 1, 1) = ACMP0_P2 function is selected.
N     * |        |          |(1, 0, 0) = PWM0_CH0 function is selected.
N     * |[27]    |P13EXT    |P1.3 Alternate Function Selection Extension
N     * |        |          |Bits P13EXT (SYS_P1_MFP[27]), ALT[3] (SYS_P1_MFP[11]), and MFP[3] (SYS_P1_MFP[3]) determine the P1.3 function.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = ADC_CH3 function is selected.
N     * |        |          |(0, 1, 0) = UART0_TXD function is selected.
N     * |        |          |(0, 1, 1) = ACMP0_P3 function is selected.
N     * |        |          |(1, 0, 0) = PWM0_CH1 function is selected.
N     * |[28]    |P14EXT    |P1.4 Alternate Function Selection Extension
N     * |        |          |Bits P14EXT (SYS_P1_MFP[28]), ALT[4] (SYS_P1_MFP[12]), and MFP[4] (SYS_P1_MFP[4]) determine the P1.4 function.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = ADC_CH4 function is selected.
N     * |        |          |(0, 1, 0) = UART1_RXD function is selected.
N     * |        |          |(0, 1, 1) = ACMP0_N function is selected.
N     * |        |          |(1, 0, 0) = PWM0_CH4 function is selected.
N    */
N    __IO uint32_t P1_MFP;
X    volatile uint32_t P1_MFP;
N
N    /**
N     * P2_MFP
N     * ===================================================================================================
N     * Offset: 0x38  P2 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |MFP       |P2 Multiple Function Select Bit
N     * |        |          |The pin function of P2 depends on MFP and ALT.
N     * |        |          |Refer to ALT Description for details.
N     * |[10]    |ALT2      |P2.2 Alternate Function Select Bit
N     * |        |          |Bits ALT[2] (SYS_P2_MFP[10]), and MFP[2] (SYS_P2_MFP[2]) determine the P2.2 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = Reserved.
N     * |        |          |(1, 0) = PWM0_CH0 function is selected.
N     * |        |          |(1, 1) = I2C1_SCL function is selected.
N     * |[11]    |ALT3      |P2.3 Alternate Function Select Bit
N     * |        |          |Bits ALT[3] (SYS_P2_MFP[11]), and MFP[3] (SYS_P2_MFP[3]) determine the P2.3 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = Reserved.
N     * |        |          |(1, 0) = PWM0_CH1 function is selected.
N     * |        |          |(1, 1) = I2C1_SDA1 function is selected.
N     * |[12]    |ALT4      |P2.4 Alternate Function Select Bit
N     * |        |          |Bits ALT[4] (SYS_P2_MFP[12]), and MFP[4] (SYS_P2_MFP[4]) determine the P2.4 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = UART1_RXD function is selected.
N     * |        |          |(1, 0) = PWM0_CH2 function is selected.
N     * |        |          |(1, 1) = Reserved.
N     * |[13]    |ALT5      |P2.5 Alternate Function Select Bit
N     * |        |          |Bits ALT[5] (SYS_P2_MFP[13]), and MFP[5] (SYS_P2_MFP[5]) determine the P2.5 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = UART1_TXD function is selected.
N     * |        |          |(1, 0) = PWM0_CH3 function is selected.
N     * |        |          |(1, 1) = Reserved.
N     * |[14]    |ALT6      |P2.6 Alternate Function Select Bit
N     * |        |          |Bits ALT[6] (SYS_P2_MFP[14]), and MFP[6] (SYS_P2_MFP[6]) determine the P2.6 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = Reserved.
N     * |        |          |(1, 0) = PWM0_CH4 function is selected.
N     * |        |          |(1, 1) = ACMP1_O0 function is selected.
N     * |[23:16] |TYPE      |P2[7:0] Input Schmitt Trigger Function Enable Bits
N     * |        |          |0 = P2[7:0] I/O input Schmitt Trigger function Disabled.
N     * |        |          |1 = P2[7:0] I/O input Schmitt Trigger function Enabled.
N    */
N    __IO uint32_t P2_MFP;
X    volatile uint32_t P2_MFP;
N
N    /**
N     * P3_MFP
N     * ===================================================================================================
N     * Offset: 0x3C  P3 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |MFP       |P3 Multiple Function Select Bits
N     * |        |          |The pin function of P3 depends on MFP and ALT.
N     * |        |          |Refer to ALT Description for details.
N     * |[8]     |ALT0      |P3.0 Alternate Function Select Bit
N     * |        |          |Bits ALT[0] (SYS_P3_MFP[8]), and MFP[0] (SYS_P3_MFP[0]) determine the P3.0 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = Reserved.
N     * |        |          |(1, 0) = ACMP1_N function is selected.
N     * |        |          |(1, 1) = ADC_CH6 function is selected.
N     * |[9]     |ALT1      |P3.1 Alternate Function Select Bit
N     * |        |          |The pin function of P3.1 depends on P3_MFP[1] and P3_ALT[1].
N     * |        |          |Bits ALT[1] (SYS_P3_MFP[9]), and MFP[1] (SYS_P3_MFP[1]) determine the P3.1 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = Reserved.
N     * |        |          |(1, 0) = ACMP1_P0 function is selected.
N     * |        |          |(1, 1) = ADC_CH7 function is selected.
N     * |[10]    |ALT2      |P3.2 Alternate Function Select Bit
N     * |        |          |Bits P32EXT (SYS_P3_MFP[26]), ALT[2] (SYS_P3_MFP[10]), and MFP[2] (SYS_P3_MFP[2]) determine the P3.2 function.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = INT1 function is selected.
N     * |        |          |(0, 1, 0) = TM0_EXT function is selected.
N     * |        |          |(0, 1, 1) = STADC function is selected.
N     * |        |          |(1, 0, 0) = ACMP1_P1 function is selected.
N     * |[12]    |ALT4      |P3.4 Alternate Function Select Bit
N     * |        |          |Bits ALT[4] (SYS_P3_MFP[12]), and MFP[4] (SYS_P3_MFP[4]) determine the P3.4 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = TM0_CNT_OUT function is selected.
N     * |        |          |(1, 0) = I2C0_SDA function is selected.
N     * |        |          |(1, 1) = ACMP1_P2 function is selected.
N     * |[13]    |ALT5      |P3.5 Alternate Function Select Bit
N     * |        |          |Bits ALT[5] (SYS_P3_MFP[13]), and MFP[5] (SYS_P3_MFP[5]) determine the P3.5 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = TM1_CNT_OUTfunction is selected.
N     * |        |          |(1, 0) = I2C0_SCL function is selected.
N     * |        |          |(1, 1) = ACMP1_P3 function is selected.
N     * |[14]    |ALT6      |P3.6 Alternate Function Select Bit
N     * |        |          |Bits ALT[6] (SYS_P3_MFP[14]), and MFP[6] (SYS_P3_MFP[6]) determine the P3.6 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = TM1_EXT function is selected.
N     * |        |          |(1, 0) = CLKO function is selected.
N     * |        |          |(1, 1) = ACMP0_O function is selected.
N     * |[23:16] |TYPE      |P3[7:0] Input Schmitt Trigger Function Enable Bits
N     * |        |          |0 = P3[7:0] I/O input Schmitt Trigger function Disabled.
N     * |        |          |1 = P3[7:0] I/O input Schmitt Trigger function Enabled.
N     * |[26]    |P32EXT    |P3.2 Alternate Function Selection Extension
N     * |        |          |Bits P32EXT (SYS_P3_MFP[26]), ALT[2] (SYS_P3_MFP[10]), and MFP[2] (SYS_P3_MFP[2]) determine the P3.2 function.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = INT1 function is selected.
N     * |        |          |(0, 1, 0) = TM0_EXT function is selected.
N     * |        |          |(0, 1, 1) = STADC function is selected.
N     * |        |          |(1, 0, 0) = ACMP1_P1 function is selected.
N    */
N    __IO uint32_t P3_MFP;
X    volatile uint32_t P3_MFP;
N
N    /**
N     * P4_MFP
N     * ===================================================================================================
N     * Offset: 0x40  P4 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |MFP       |P4 Multiple Function Select Bits
N     * |        |          |The pin function of P4 depends on MFP and ALT.
N     * |        |          |Refer to ALT Description for details.
N     * |[14]    |ALT6      |P4.6 Alternate Function Select Bit
N     * |        |          |Bits ALT[6] (SYS_P4_MFP[6]), and MFP[6] (SYS_P4_MFP[6]) determine the P4.6 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = ICE_CLK function is selected.
N     * |        |          |(1, 0) = UART1_RXD function is selected.
N     * |        |          |(1, 1) = Reserved.
N     * |[15]    |ALT7      |P4.7 Alternate Function Select Bit
N     * |        |          |Bits ALT[7] (SYS_P4_MFP[15]), and MFP[7] (SYS_P4_MFP[7]) determine the P4.7 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = ICE_DAT function is selected.
N     * |        |          |(1, 0) = UART1_TXD function is selected.
N     * |        |          |(1, 1) = Reserved.
N     * |[23:16] |TYPE      |P4[7:0] Input Schmitt Trigger Function Enable Bits
N     * |        |          |0 = P4[7:0] I/O input Schmitt Trigger function Disabled.
N     * |        |          |1 = P4[7:0] I/O input Schmitt Trigger function Enabled.
N    */
N    __IO uint32_t P4_MFP;
X    volatile uint32_t P4_MFP;
N
N    /**
N     * P5_MFP
N     * ===================================================================================================
N     * Offset: 0x44  P5 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |MFP       |P5 Multiple Function Select Bits
N     * |        |          |The pin function of P5 depends on MFP and ALT.
N     * |        |          |Refer to ALT Description for details.
N     * |[8]     |ALT0      |P5.0 Alternate Function Select Bit
N     * |        |          |The pin function of P5.0 depends on MFP[0] and ALT[0].
N     * |        |          |Bits ALT[0] (SYS_P5_MFP[8]), and MFP[0] (SYS_P5_MFP[0]) determine the P5.0 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = XT1_IN function is selected.
N     * |        |          |(1, 0) = I2C1_SDA1 function is selected.
N     * |        |          |(1, 1) = UART0_TXD function is selected.
N     * |        |          |Note: To enable external XTAL function, the CLK_PWRCTL bit [1:0] (XTLEN), external HXT or LXT crystal oscillator control register must also be set.
N     * |[9]     |ALT1      |P5.1 Alternate Function Select Bit
N     * |        |          |Bits ALT[1] (SYS_P5_MFP[9]), and MFP[1] (SYS_P5_MFP[1]) determine the P5.1 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = XT1_OUT function is selected.
N     * |        |          |(1, 0) = I2C1_SCL1 function is selected.
N     * |        |          |(1, 1) = UART0_RXD function is selected.
N     * |        |          |Note: To enable external XTAL function, the CLK_PWRCTL bit [1:0] (XTLEN), external HXT or LXT crystal oscillator control register must also be set.
N     * |[10]    |ALT2      |P5.2 Alternate Function Select Bit
N     * |        |          |Bits ALT[2] (SYS_P5_MFP[10]), and MFP[2] (SYS_P5_MFP[2]) determine the P5.2 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = INT1 function is selected.
N     * |        |          |Others = Reserved.
N     * |[11]    |ALT3      |P5.3 Alternate Function Select Bit
N     * |        |          |Bits ALT[3] (SYS_P5_MFP[11]), and MFP[3] (SYS_P5_MFP[3]) determine the P5.3 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = ADC_CH0 function is selected.
N     * |        |          |Others = Reserved.
N     * |[12]    |ALT4      |P5.4 Alternate Function Select Bit
N     * |        |          |Bits ALT[4] (SYS_P5_MFP[12]), and MFP[4] (SYS_P5_MFP[4]) determine the P5.4 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |Others = Reserved.
N     * |[13]    |ALT5      |P5.5 Alternate Function Select Bit
N     * |        |          |Bits ALT[5] (SYS_P5_MFP[13]), and MFP[5] (SYS_P5_MFP[5]) determine the P5.5 function.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |Others = Reserved.
N     * |[23:16] |TYPE      |P5[7:0] Input Schmitt Trigger Function Enable Bits
N     * |        |          |0 = P5[7:0] I/O input Schmitt Trigger function Disabled.
N     * |        |          |1 = P5[7:0] I/O input Schmitt Trigger function Enabled.
N    */
N    __IO uint32_t P5_MFP;
X    volatile uint32_t P5_MFP;
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVED2[14];
X    volatile const  uint32_t RESERVED2[14];
N    /// @endcond //HIDDEN_SYMBOLS
N
N
N    /**
N     * IRCTCTL
N     * ===================================================================================================
N     * Offset: 0x80  HIRC Trim Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |FREQSEL   |Trim Frequency Select Bit
N     * |        |          |This bit is to enable the HIRC auto trim.
N     * |        |          |When setting this bit to 1, the HIRC auto trim function will trim HIRC to 22.1184 MHz automatically based on the LXT reference clock.
N     * |        |          |During auto trim operation, if LXT clock error is detected or trim retry limitation count reached, this field will be cleared to 0 automatically.
N     * |        |          |0 = HIRC auto trim function Disabled.
N     * |        |          |1 = HIRC auto trim function Enabled and HIRC trimmed to 22.1184 MHz.
N     * |[5:4]   |LOOPSEL   |Trim Calculation Loop
N     * |        |          |This field defines trim value calculation based on the number of LXT clock.
N     * |        |          |For example, if LOOPSEL is set as "00", auto trim circuit will calculate trim value based on the average frequency difference in 4 LXT clocks.
N     * |        |          |This field also defines how many times the auto trim circuit will try to update the HIRC trim value before the frequency of HIRC is locked.
N     * |        |          |Once the HIRC is locked, the internal trim value update counter will be reset.
N     * |        |          |If the trim value update counter reaches this limitation value and frequency of HIRC is still not locked, the auto trim operation will be disabled and FREQSEL will be cleared to 0.
N     * |        |          |00 = Trim value calculation is based on average difference in 4 LXT clock and trim retry count limitation is 64.
N     * |        |          |01 = Trim value calculation is based on average difference in 8 LXT clock and trim retry count limitation is 128.
N     * |        |          |10 = Trim value calculation is based on average difference in 16 LXT clock and trim retry count limitation is 256.
N     * |        |          |11 = Trim value calculation is based on average difference in 32 LXT clock and trim retry count limitation is 512.
N    */
N    __IO uint32_t IRCTCTL;
X    volatile uint32_t IRCTCTL;
N
N    /**
N     * IRCTIEN
N     * ===================================================================================================
N     * Offset: 0x84  HIRC Trim Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |TFAILIEN  |Trim Failure Interrupt Enable Bit
N     * |        |          |This bit controls if an interrupt will be triggered while HIRC trim value update limitation count is reached and HIRC frequency is still not locked on target frequency set by FREQSEL (SYS_IRCTCTL[1:0]).
N     * |        |          |If this bit is high and TFAILIF (SYS_IRCTISTS[1]) is set during auto trim operation, an interrupt will be triggered to notify that HIRC trim value update limitation count is reached.
N     * |        |          |0 = TFAILIF (SYS_IRCTISTS[1]) status Disabled to trigger an interrupt to CPU.
N     * |        |          |1 = TFAILIF (SYS_IRCTISTS[1]) status Enabled to trigger an interrupt to CPU.
N     * |[2]     |CLKEIEN   |LXT Clock Error Interrupt Enable Bit
N     * |        |          |This bit controls if CPU could get an interrupt while LXT clock is inaccurate during auto trim operation.
N     * |        |          |If this bit is high, and CLKERRIF (SYS_IRCTISTS[2]) is set during auto trim operation, an interrupt will be triggered to notify the LXT clock frequency is inaccurate.
N     * |        |          |0 = CLKERRIF (SYS_IRCTISTS[2]) status Disabled to trigger an interrupt to CPU.
N     * |        |          |1 = CLKERRIF (SYS_IRCTISTS[2]) status Enabled to trigger an interrupt to CPU.
N    */
N    __IO uint32_t IRCTIEN;
X    volatile uint32_t IRCTIEN;
N
N    /**
N     * IRCTISTS
N     * ===================================================================================================
N     * Offset: 0x88  HIRC Trim Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |FREQLOCK  |HIRC Frequency Lock Status
N     * |        |          |This bit indicates the HIRC frequency locked in 22.1184 MHz.
N     * |        |          |This is a read only status bit and doesn't trigger any interrupt.
N     * |[1]     |TFAILIF   |Trim Failure Interrupt Status
N     * |        |          |This bit indicates that HIRC trim value update limitation count reached and HIRC clock frequency still doesn't lock.
N     * |        |          |Once this bit is set, the auto trim operation stopped and FREQSEL (SYS_IRCTCTL[1:0]) will be cleared to 0 by hardware automatically.
N     * |        |          |If this bit is set and TFAILIEN (SYS_IRCTIEN[1]) is high, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached.
N     * |        |          |Software can write 1 to clear this bit to .
N     * |        |          |0 = Trim value update limitation count is not reached.
N     * |        |          |1 = Trim value update limitation count is reached and HIRC frequency is still not locked.
N     * |[2]     |CLKERRIF  |LXT Clock Error Interrupt Status
N     * |        |          |This bit indicates that LXT clock frequency is inaccuracy.
N     * |        |          |Once this bit is set, the auto trim operation stopped and FREQSEL (SYS_IRCTCTL[0]) will be cleared to 0 by hardware automatically.
N     * |        |          |If this bit is set and CLKEIEN (SYS_IRCTIEN[2]) is high, an interrupt will be triggered to notify the LXT clock frequency is inaccuracy.
N     * |        |          |Software can write 1 to clear this bit to .
N     * |        |          |0 = LXT clock frequency is accuracy.
N     * |        |          |1 = LXT clock frequency is inaccuracy.
N    */
N    __IO uint32_t IRCTISTS;
X    volatile uint32_t IRCTISTS;
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVED3[29];
X    volatile const  uint32_t RESERVED3[29];
N    /// @endcond //HIDDEN_SYMBOLS
N
N
N    /**
N     * REGLCTL
N     * ===================================================================================================
N     * Offset: 0x100  Register Write-Protection Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |REGLCTL   |Register Write-protection Code (Write Only)
N     * |        |          |Some registers have write-protection function.
N     * |        |          |Writing these registers have to disable the protected function by writing the sequence value 0x59, 0x16, 0x88 to this field.
N     * |        |          |After this sequence is completed, the REGLCTL bit will be set to 1 and write-protection registers can be normal writ.
N     * |        |          |Register Write-protection Disable Index (Read Only)
N     * |        |          |0 = Write-protection Enabled for writing protected registers.
N     * |        |          |Any write to the protected register is ignore.
N     * |        |          |1 = Write-protection Disabled for writing protected registers.
N     * |        |          |Protected registers are listed below:
N     * |        |          |SYS_IPRST0 (0x5000_0008) : Peripheral Reset Control Resister 0
N     * |        |          |SYS_BODCTL (0x5000_0018) : Brown-out Detector Control Register
N     * |        |          |CLK_PWRCTL (0x5000_0200) : Bit[6] is not protected for power wake-up interrupt clear.
N     * |        |          |CLK_APBCLK bit[0] (0x5000_0208) : Bit[0] is watchdog clock enable.
N     * |        |          |CLK_CLKSEL0 (0x5000_0210) : HCLK and CPU STCLK clock source select.
N     * |        |          |CLK_CLKSEL1 bit[1:0] (0x5000_0214) : Watchdog clock source select.
N     * |        |          |NMI_SEL bit[8] (0x5000_0380) : NMI interrupt enable.
N     * |        |          |ISPCON (0x5000_C000) : Flash ISP Control.
N     * |        |          |ISPTRG (0x5000_C010) : ISP Trigger Control.
N     * |        |          |WTCR (0x4000_4000) : Watchdog Timer Control.
N     * |        |          |Note: The bits which are write-protected will be noted as" (Write Protect)" beside the description.
N    */
N    __O  uint32_t REGLCTL;
X    volatile  uint32_t REGLCTL;
N
N} SYS_T;
N
N/**
N    @addtogroup SYS_CONST SYS Bit Field Definition
N    Constant Definitions for SYS Controller
N@{ */
N
N#define SYS_PDID_PDID_Pos                (0)                                               /*!< SYS_T::PDID: PDID Position                */
N#define SYS_PDID_PDID_Msk                (0xfffffffful << SYS_PDID_PDID_Pos)               /*!< SYS_T::PDID: PDID Mask                    */
N
N#define SYS_RSTSTS_PORF_Pos              (0)                                               /*!< SYS_T::RSTSTS: PORF Position              */
N#define SYS_RSTSTS_PORF_Msk              (0x1ul << SYS_RSTSTS_PORF_Pos)                    /*!< SYS_T::RSTSTS: PORF Mask                  */
N
N#define SYS_RSTSTS_PINRF_Pos             (1)                                               /*!< SYS_T::RSTSTS: PINRF Position             */
N#define SYS_RSTSTS_PINRF_Msk             (0x1ul << SYS_RSTSTS_PINRF_Pos)                   /*!< SYS_T::RSTSTS: PINRF Mask                 */
N
N#define SYS_RSTSTS_WDTRF_Pos             (2)                                               /*!< SYS_T::RSTSTS: WDTRF Position             */
N#define SYS_RSTSTS_WDTRF_Msk             (0x1ul << SYS_RSTSTS_WDTRF_Pos)                   /*!< SYS_T::RSTSTS: WDTRF Mask                 */
N
N#define SYS_RSTSTS_BODRF_Pos             (4)                                               /*!< SYS_T::RSTSTS: BODRF Position             */
N#define SYS_RSTSTS_BODRF_Msk             (0x1ul << SYS_RSTSTS_BODRF_Pos)                   /*!< SYS_T::RSTSTS: BODRF Mask                 */
N
N#define SYS_RSTSTS_SYSRF_Pos             (5)                                               /*!< SYS_T::RSTSTS: SYSRF Position             */
N#define SYS_RSTSTS_SYSRF_Msk             (0x1ul << SYS_RSTSTS_SYSRF_Pos)                   /*!< SYS_T::RSTSTS: SYSRF Mask                 */
N
N#define SYS_RSTSTS_CPURF_Pos             (7)                                               /*!< SYS_T::RSTSTS: CPURF Position             */
N#define SYS_RSTSTS_CPURF_Msk             (0x1ul << SYS_RSTSTS_CPURF_Pos)                   /*!< SYS_T::RSTSTS: CPURF Mask                 */
N
N#define SYS_RSTSTS_CPULKRF_Pos           (8)                                               /*!< SYS_T::RSTSTS: CPULKRF Position           */
N#define SYS_RSTSTS_CPULKRF_Msk           (0x1ul << SYS_RSTSTS_CPULKRF_Pos)                 /*!< SYS_T::RSTSTS: CPULKRF Mask               */
N
N#define SYS_IPRST0_CHIPRST_Pos           (0)                                               /*!< SYS_T::IPRST0: CHIPRST Position           */
N#define SYS_IPRST0_CHIPRST_Msk           (0x1ul << SYS_IPRST0_CHIPRST_Pos)                 /*!< SYS_T::IPRST0: CHIPRST Mask               */
N
N#define SYS_IPRST0_CPURST_Pos            (1)                                               /*!< SYS_T::IPRST0: CPURST Position            */
N#define SYS_IPRST0_CPURST_Msk            (0x1ul << SYS_IPRST0_CPURST_Pos)                  /*!< SYS_T::IPRST0: CPURST Mask                */
N
N#define SYS_IPRST1_GPIORST_Pos           (1)                                               /*!< SYS_T::IPRST1: GPIORST Position           */
N#define SYS_IPRST1_GPIORST_Msk           (0x1ul << SYS_IPRST1_GPIORST_Pos)                 /*!< SYS_T::IPRST1: GPIORST Mask               */
N
N#define SYS_IPRST1_TMR0RST_Pos           (2)                                               /*!< SYS_T::IPRST1: TMR0RST Position           */
N#define SYS_IPRST1_TMR0RST_Msk           (0x1ul << SYS_IPRST1_TMR0RST_Pos)                 /*!< SYS_T::IPRST1: TMR0RST Mask               */
N
N#define SYS_IPRST1_TMR1RST_Pos           (3)                                               /*!< SYS_T::IPRST1: TMR1RST Position           */
N#define SYS_IPRST1_TMR1RST_Msk           (0x1ul << SYS_IPRST1_TMR1RST_Pos)                 /*!< SYS_T::IPRST1: TMR1RST Mask               */
N
N#define SYS_IPRST1_I2C0RST_Pos           (8)                                               /*!< SYS_T::IPRST1: I2C0RST Position           */
N#define SYS_IPRST1_I2C0RST_Msk           (0x1ul << SYS_IPRST1_I2C0RST_Pos)                 /*!< SYS_T::IPRST1: I2C0RST Mask               */
N
N#define SYS_IPRST1_I2C1RST_Pos           (9)                                               /*!< SYS_T::IPRST1: I2C1RST Position           */
N#define SYS_IPRST1_I2C1RST_Msk           (0x1ul << SYS_IPRST1_I2C1RST_Pos)                 /*!< SYS_T::IPRST1: I2C1RST Mask               */
N
N#define SYS_IPRST1_SPI0RST_Pos           (12)                                              /*!< SYS_T::IPRST1: SPI0RST Position           */
N#define SYS_IPRST1_SPI0RST_Msk           (0x1ul << SYS_IPRST1_SPI0RST_Pos)                 /*!< SYS_T::IPRST1: SPI0RST Mask               */
N
N#define SYS_IPRST1_UART0RST_Pos          (16)                                              /*!< SYS_T::IPRST1: UART0RST Position          */
N#define SYS_IPRST1_UART0RST_Msk          (0x1ul << SYS_IPRST1_UART0RST_Pos)                /*!< SYS_T::IPRST1: UART0RST Mask              */
N
N#define SYS_IPRST1_UART1RST_Pos          (17)                                              /*!< SYS_T::IPRST1: UART1RST Position          */
N#define SYS_IPRST1_UART1RST_Msk          (0x1ul << SYS_IPRST1_UART1RST_Pos)                /*!< SYS_T::IPRST1: UART1RST Mask              */
N
N#define SYS_IPRST1_PWM0RST_Pos           (20)                                              /*!< SYS_T::IPRST1: PWM0RST Position           */
N#define SYS_IPRST1_PWM0RST_Msk           (0x1ul << SYS_IPRST1_PWM0RST_Pos)                 /*!< SYS_T::IPRST1: PWM0RST Mask               */
N
N#define SYS_IPRST1_ACMPRST_Pos           (22)                                              /*!< SYS_T::IPRST1: ACMPRST Position           */
N#define SYS_IPRST1_ACMPRST_Msk           (0x1ul << SYS_IPRST1_ACMPRST_Pos)                 /*!< SYS_T::IPRST1: ACMPRST Mask               */
N
N#define SYS_IPRST1_ADCRST_Pos            (28)                                              /*!< SYS_T::IPRST1: ADCRST Position            */
N#define SYS_IPRST1_ADCRST_Msk            (0x1ul << SYS_IPRST1_ADCRST_Pos)                  /*!< SYS_T::IPRST1: ADCRST Mask                */
N
N#define SYS_BODCTL_BODEN_Pos             (0)                                               /*!< SYS_T::BODCTL: BODEN Position             */
N#define SYS_BODCTL_BODEN_Msk             (0x1ul << SYS_BODCTL_BODEN_Pos)                   /*!< SYS_T::BODCTL: BODEN Mask                 */
N
N#define SYS_BODCTL_BODVL_Pos             (1)                                               /*!< SYS_T::BODCTL: BODVL Position             */
N#define SYS_BODCTL_BODVL_Msk             (0x3ul << SYS_BODCTL_BODVL_Pos)                   /*!< SYS_T::BODCTL: BODVL Mask                 */
N
N#define SYS_BODCTL_BODRSTEN_Pos          (3)                                               /*!< SYS_T::BODCTL: BODRSTEN Position          */
N#define SYS_BODCTL_BODRSTEN_Msk          (0x1ul << SYS_BODCTL_BODRSTEN_Pos)                /*!< SYS_T::BODCTL: BODRSTEN Mask              */
N
N#define SYS_BODCTL_BODIF_Pos             (4)                                               /*!< SYS_T::BODCTL: BODIF Position             */
N#define SYS_BODCTL_BODIF_Msk             (0x1ul << SYS_BODCTL_BODIF_Pos)                   /*!< SYS_T::BODCTL: BODIF Mask                 */
N
N#define SYS_BODCTL_BODLPM_Pos            (5)                                               /*!< SYS_T::BODCTL: BODLPM Position            */
N#define SYS_BODCTL_BODLPM_Msk            (0x1ul << SYS_BODCTL_BODLPM_Pos)                  /*!< SYS_T::BODCTL: BODLPM Mask                */
N
N#define SYS_BODCTL_BODOUT_Pos            (6)                                               /*!< SYS_T::BODCTL: BODOUT Position            */
N#define SYS_BODCTL_BODOUT_Msk            (0x1ul << SYS_BODCTL_BODOUT_Pos)                  /*!< SYS_T::BODCTL: BODOUT Mask                */
N
N#define SYS_P0_MFP_MFP_Pos               (0)                                               /*!< SYS_T::P0_MFP: MFP Position               */
N#define SYS_P0_MFP_MFP_Msk               (0xfful << SYS_P0_MFP_MFP_Pos)                    /*!< SYS_T::P0_MFP: MFP Mask                   */
N
N#define SYS_P0_MFP_ALT0_Pos              (8)                                               /*!< SYS_T::P0_MFP: ALT0 Position              */
N#define SYS_P0_MFP_ALT0_Msk              (0x1ul << SYS_P0_MFP_ALT0_Pos)                    /*!< SYS_T::P0_MFP: ALT0 Mask                  */
N
N#define SYS_P0_MFP_ALT1_Pos              (9)                                               /*!< SYS_T::P0_MFP: ALT1 Position              */
N#define SYS_P0_MFP_ALT1_Msk              (0x1ul << SYS_P0_MFP_ALT1_Pos)                    /*!< SYS_T::P0_MFP: ALT1 Mask                  */
N
N#define SYS_P0_MFP_ALT4_Pos              (12)                                              /*!< SYS_T::P0_MFP: ALT4 Position              */
N#define SYS_P0_MFP_ALT4_Msk              (0x1ul << SYS_P0_MFP_ALT4_Pos)                    /*!< SYS_T::P0_MFP: ALT4 Mask                  */
N
N#define SYS_P0_MFP_ALT5_Pos              (13)                                              /*!< SYS_T::P0_MFP: ALT5 Position              */
N#define SYS_P0_MFP_ALT5_Msk              (0x1ul << SYS_P0_MFP_ALT5_Pos)                    /*!< SYS_T::P0_MFP: ALT5 Mask                  */
N
N#define SYS_P0_MFP_ALT6_Pos              (14)                                              /*!< SYS_T::P0_MFP: ALT6 Position              */
N#define SYS_P0_MFP_ALT6_Msk              (0x1ul << SYS_P0_MFP_ALT6_Pos)                    /*!< SYS_T::P0_MFP: ALT6 Mask                  */
N
N#define SYS_P0_MFP_ALT7_Pos              (15)                                              /*!< SYS_T::P0_MFP: ALT7 Position              */
N#define SYS_P0_MFP_ALT7_Msk              (0x1ul << SYS_P0_MFP_ALT7_Pos)                    /*!< SYS_T::P0_MFP: ALT7 Mask                  */
N
N#define SYS_P0_MFP_TYPE_Pos              (16)                                              /*!< SYS_T::P0_MFP: TYPE Position              */
N#define SYS_P0_MFP_TYPE_Msk              (0xfful << SYS_P0_MFP_TYPE_Pos)                   /*!< SYS_T::P0_MFP: TYPE Mask                  */
N
N#define SYS_P1_MFP_MFP_Pos               (0)                                               /*!< SYS_T::P1_MFP: MFP Position               */
N#define SYS_P1_MFP_MFP_Msk               (0xfful << SYS_P1_MFP_MFP_Pos)                    /*!< SYS_T::P1_MFP: MFP Mask                   */
N
N#define SYS_P1_MFP_ALT0_Pos              (8)                                               /*!< SYS_T::P1_MFP: ALT0 Position              */
N#define SYS_P1_MFP_ALT0_Msk              (0x1ul << SYS_P1_MFP_ALT0_Pos)                    /*!< SYS_T::P1_MFP: ALT0 Mask                  */
N
N#define SYS_P1_MFP_ALT2_Pos              (10)                                              /*!< SYS_T::P1_MFP: ALT2 Position              */
N#define SYS_P1_MFP_ALT2_Msk              (0x1ul << SYS_P1_MFP_ALT2_Pos)                    /*!< SYS_T::P1_MFP: ALT2 Mask                  */
N
N#define SYS_P1_MFP_ALT3_Pos              (11)                                              /*!< SYS_T::P1_MFP: ALT3 Position              */
N#define SYS_P1_MFP_ALT3_Msk              (0x1ul << SYS_P1_MFP_ALT3_Pos)                    /*!< SYS_T::P1_MFP: ALT3 Mask                  */
N
N#define SYS_P1_MFP_ALT4_Pos              (12)                                              /*!< SYS_T::P1_MFP: ALT4 Position              */
N#define SYS_P1_MFP_ALT4_Msk              (0x1ul << SYS_P1_MFP_ALT4_Pos)                    /*!< SYS_T::P1_MFP: ALT4 Mask                  */
N
N#define SYS_P1_MFP_ALT5_Pos              (13)                                              /*!< SYS_T::P1_MFP: ALT5 Position              */
N#define SYS_P1_MFP_ALT5_Msk              (0x1ul << SYS_P1_MFP_ALT5_Pos)                    /*!< SYS_T::P1_MFP: ALT5 Mask                  */
N
N#define SYS_P1_MFP_TYPE_Pos              (16)                                              /*!< SYS_T::P1_MFP: TYPE Position              */
N#define SYS_P1_MFP_TYPE_Msk              (0xfful << SYS_P1_MFP_TYPE_Pos)                   /*!< SYS_T::P1_MFP: TYPE Mask                  */
N
N#define SYS_P1_MFP_P12EXT_Pos            (26)                                              /*!< SYS_T::P1_MFP: P12EXT Position            */
N#define SYS_P1_MFP_P12EXT_Msk            (0x1ul << SYS_P1_MFP_P12EXT_Pos)                  /*!< SYS_T::P1_MFP: P12EXT Mask                */
N
N#define SYS_P1_MFP_P13EXT_Pos            (27)                                              /*!< SYS_T::P1_MFP: P13EXT Position            */
N#define SYS_P1_MFP_P13EXT_Msk            (0x1ul << SYS_P1_MFP_P13EXT_Pos)                  /*!< SYS_T::P1_MFP: P13EXT Mask                */
N
N#define SYS_P1_MFP_P14EXT_Pos            (28)                                              /*!< SYS_T::P1_MFP: P14EXT Position            */
N#define SYS_P1_MFP_P14EXT_Msk            (0x1ul << SYS_P1_MFP_P14EXT_Pos)                  /*!< SYS_T::P1_MFP: P14EXT Mask                */
N
N#define SYS_P2_MFP_MFP_Pos               (0)                                               /*!< SYS_T::P2_MFP: MFP Position               */
N#define SYS_P2_MFP_MFP_Msk               (0xfful << SYS_P2_MFP_MFP_Pos)                    /*!< SYS_T::P2_MFP: MFP Mask                   */
N
N#define SYS_P2_MFP_ALT2_Pos              (10)                                              /*!< SYS_T::P2_MFP: ALT2 Position              */
N#define SYS_P2_MFP_ALT2_Msk              (0x1ul << SYS_P2_MFP_ALT2_Pos)                    /*!< SYS_T::P2_MFP: ALT2 Mask                  */
N
N#define SYS_P2_MFP_ALT3_Pos              (11)                                              /*!< SYS_T::P2_MFP: ALT3 Position              */
N#define SYS_P2_MFP_ALT3_Msk              (0x1ul << SYS_P2_MFP_ALT3_Pos)                    /*!< SYS_T::P2_MFP: ALT3 Mask                  */
N
N#define SYS_P2_MFP_ALT4_Pos              (12)                                              /*!< SYS_T::P2_MFP: ALT4 Position              */
N#define SYS_P2_MFP_ALT4_Msk              (0x1ul << SYS_P2_MFP_ALT4_Pos)                    /*!< SYS_T::P2_MFP: ALT4 Mask                  */
N
N#define SYS_P2_MFP_ALT5_Pos              (13)                                              /*!< SYS_T::P2_MFP: ALT5 Position              */
N#define SYS_P2_MFP_ALT5_Msk              (0x1ul << SYS_P2_MFP_ALT5_Pos)                    /*!< SYS_T::P2_MFP: ALT5 Mask                  */
N
N#define SYS_P2_MFP_ALT6_Pos              (14)                                              /*!< SYS_T::P2_MFP: ALT6 Position              */
N#define SYS_P2_MFP_ALT6_Msk              (0x1ul << SYS_P2_MFP_ALT6_Pos)                    /*!< SYS_T::P2_MFP: ALT6 Mask                  */
N
N#define SYS_P2_MFP_TYPE_Pos              (16)                                              /*!< SYS_T::P2_MFP: TYPE Position              */
N#define SYS_P2_MFP_TYPE_Msk              (0xfful << SYS_P2_MFP_TYPE_Pos)                   /*!< SYS_T::P2_MFP: TYPE Mask                  */
N
N#define SYS_P3_MFP_MFP_Pos               (0)                                               /*!< SYS_T::P3_MFP: MFP Position               */
N#define SYS_P3_MFP_MFP_Msk               (0xfful << SYS_P3_MFP_MFP_Pos)                    /*!< SYS_T::P3_MFP: MFP Mask                   */
N
N#define SYS_P3_MFP_ALT0_Pos              (8)                                               /*!< SYS_T::P3_MFP: ALT0 Position              */
N#define SYS_P3_MFP_ALT0_Msk              (0x1ul << SYS_P3_MFP_ALT0_Pos)                    /*!< SYS_T::P3_MFP: ALT0 Mask                  */
N
N#define SYS_P3_MFP_ALT1_Pos              (9)                                               /*!< SYS_T::P3_MFP: ALT1 Position              */
N#define SYS_P3_MFP_ALT1_Msk              (0x1ul << SYS_P3_MFP_ALT1_Pos)                    /*!< SYS_T::P3_MFP: ALT1 Mask                  */
N
N#define SYS_P3_MFP_ALT2_Pos              (10)                                              /*!< SYS_T::P3_MFP: ALT2 Position              */
N#define SYS_P3_MFP_ALT2_Msk              (0x1ul << SYS_P3_MFP_ALT2_Pos)                    /*!< SYS_T::P3_MFP: ALT2 Mask                  */
N
N#define SYS_P3_MFP_ALT4_Pos              (12)                                              /*!< SYS_T::P3_MFP: ALT4 Position              */
N#define SYS_P3_MFP_ALT4_Msk              (0x1ul << SYS_P3_MFP_ALT4_Pos)                    /*!< SYS_T::P3_MFP: ALT4 Mask                  */
N
N#define SYS_P3_MFP_ALT5_Pos              (13)                                              /*!< SYS_T::P3_MFP: ALT5 Position              */
N#define SYS_P3_MFP_ALT5_Msk              (0x1ul << SYS_P3_MFP_ALT5_Pos)                    /*!< SYS_T::P3_MFP: ALT5 Mask                  */
N
N#define SYS_P3_MFP_ALT6_Pos              (14)                                              /*!< SYS_T::P3_MFP: ALT6 Position              */
N#define SYS_P3_MFP_ALT6_Msk              (0x1ul << SYS_P3_MFP_ALT6_Pos)                    /*!< SYS_T::P3_MFP: ALT6 Mask                  */
N
N#define SYS_P3_MFP_TYPE_Pos              (16)                                              /*!< SYS_T::P3_MFP: TYPE Position              */
N#define SYS_P3_MFP_TYPE_Msk              (0xfful << SYS_P3_MFP_TYPE_Pos)                   /*!< SYS_T::P3_MFP: TYPE Mask                  */
N
N#define SYS_P3_MFP_P32EXT_Pos            (26)                                              /*!< SYS_T::P3_MFP: P32EXT Position            */
N#define SYS_P3_MFP_P32EXT_Msk            (0x1ul << SYS_P3_MFP_P32EXT_Pos)                  /*!< SYS_T::P3_MFP: P32EXT Mask                */
N
N#define SYS_P4_MFP_MFP_Pos               (0)                                               /*!< SYS_T::P4_MFP: MFP Position               */
N#define SYS_P4_MFP_MFP_Msk               (0xfful << SYS_P4_MFP_MFP_Pos)                    /*!< SYS_T::P4_MFP: MFP Mask                   */
N
N#define SYS_P4_MFP_ALT6_Pos              (14)                                              /*!< SYS_T::P4_MFP: ALT6 Position              */
N#define SYS_P4_MFP_ALT6_Msk              (0x1ul << SYS_P4_MFP_ALT6_Pos)                    /*!< SYS_T::P4_MFP: ALT6 Mask                  */
N
N#define SYS_P4_MFP_ALT7_Pos              (15)                                              /*!< SYS_T::P4_MFP: ALT7 Position              */
N#define SYS_P4_MFP_ALT7_Msk              (0x1ul << SYS_P4_MFP_ALT7_Pos)                    /*!< SYS_T::P4_MFP: ALT7 Mask                  */
N
N#define SYS_P4_MFP_TYPE_Pos              (16)                                              /*!< SYS_T::P4_MFP: TYPE Position              */
N#define SYS_P4_MFP_TYPE_Msk              (0xfful << SYS_P4_MFP_TYPE_Pos)                   /*!< SYS_T::P4_MFP: TYPE Mask                  */
N
N#define SYS_P5_MFP_MFP_Pos               (0)                                               /*!< SYS_T::P5_MFP: MFP Position               */
N#define SYS_P5_MFP_MFP_Msk               (0xfful << SYS_P5_MFP_MFP_Pos)                    /*!< SYS_T::P5_MFP: MFP Mask                   */
N
N#define SYS_P5_MFP_ALT0_Pos              (8)                                               /*!< SYS_T::P5_MFP: ALT0 Position              */
N#define SYS_P5_MFP_ALT0_Msk              (0x1ul << SYS_P5_MFP_ALT0_Pos)                    /*!< SYS_T::P5_MFP: ALT0 Mask                  */
N
N#define SYS_P5_MFP_ALT1_Pos              (9)                                               /*!< SYS_T::P5_MFP: ALT1 Position              */
N#define SYS_P5_MFP_ALT1_Msk              (0x1ul << SYS_P5_MFP_ALT1_Pos)                    /*!< SYS_T::P5_MFP: ALT1 Mask                  */
N
N#define SYS_P5_MFP_ALT2_Pos              (10)                                              /*!< SYS_T::P5_MFP: ALT2 Position              */
N#define SYS_P5_MFP_ALT2_Msk              (0x1ul << SYS_P5_MFP_ALT2_Pos)                    /*!< SYS_T::P5_MFP: ALT2 Mask                  */
N
N#define SYS_P5_MFP_ALT3_Pos              (11)                                              /*!< SYS_T::P5_MFP: ALT3 Position              */
N#define SYS_P5_MFP_ALT3_Msk              (0x1ul << SYS_P5_MFP_ALT3_Pos)                    /*!< SYS_T::P5_MFP: ALT3 Mask                  */
N
N#define SYS_P5_MFP_ALT4_Pos              (12)                                              /*!< SYS_T::P5_MFP: ALT4 Position              */
N#define SYS_P5_MFP_ALT4_Msk              (0x1ul << SYS_P5_MFP_ALT4_Pos)                    /*!< SYS_T::P5_MFP: ALT4 Mask                  */
N
N#define SYS_P5_MFP_ALT5_Pos              (13)                                              /*!< SYS_T::P5_MFP: ALT5 Position              */
N#define SYS_P5_MFP_ALT5_Msk              (0x1ul << SYS_P5_MFP_ALT5_Pos)                    /*!< SYS_T::P5_MFP: ALT5 Mask                  */
N
N#define SYS_P5_MFP_TYPE_Pos              (16)                                              /*!< SYS_T::P5_MFP: TYPE Position              */
N#define SYS_P5_MFP_TYPE_Msk              (0xfful << SYS_P5_MFP_TYPE_Pos)                   /*!< SYS_T::P5_MFP: TYPE Mask                  */
N
N#define SYS_IRCTCTL_FREQSEL_Pos          (0)                                               /*!< SYS_T::IRCTCTL: FREQSEL Position          */
N#define SYS_IRCTCTL_FREQSEL_Msk          (0x1ul << SYS_IRCTCTL_FREQSEL_Pos)                /*!< SYS_T::IRCTCTL: FREQSEL Mask              */
N
N#define SYS_IRCTCTL_LOOPSEL_Pos          (4)                                               /*!< SYS_T::IRCTCTL: LOOPSEL Position          */
N#define SYS_IRCTCTL_LOOPSEL_Msk          (0x3ul << SYS_IRCTCTL_LOOPSEL_Pos)                /*!< SYS_T::IRCTCTL: LOOPSEL Mask              */
N
N#define SYS_IRCTIEN_TFAILIEN_Pos         (1)                                               /*!< SYS_T::IRCTIEN: TFAILIEN Position         */
N#define SYS_IRCTIEN_TFAILIEN_Msk         (0x1ul << SYS_IRCTIEN_TFAILIEN_Pos)               /*!< SYS_T::IRCTIEN: TFAILIEN Mask             */
N
N#define SYS_IRCTIEN_CLKEIEN_Pos          (2)                                               /*!< SYS_T::IRCTIEN: CLKEIEN Position          */
N#define SYS_IRCTIEN_CLKEIEN_Msk          (0x1ul << SYS_IRCTIEN_CLKEIEN_Pos)                /*!< SYS_T::IRCTIEN: CLKEIEN Mask              */
N
N#define SYS_IRCTISTS_FREQLOCK_Pos        (0)                                               /*!< SYS_T::IRCTISTS: FREQLOCK Position        */
N#define SYS_IRCTISTS_FREQLOCK_Msk        (0x1ul << SYS_IRCTISTS_FREQLOCK_Pos)              /*!< SYS_T::IRCTISTS: FREQLOCK Mask            */
N
N#define SYS_IRCTISTS_TFAILIF_Pos         (1)                                               /*!< SYS_T::IRCTISTS: TFAILIF Position         */
N#define SYS_IRCTISTS_TFAILIF_Msk         (0x1ul << SYS_IRCTISTS_TFAILIF_Pos)               /*!< SYS_T::IRCTISTS: TFAILIF Mask             */
N
N#define SYS_IRCTISTS_CLKERRIF_Pos        (2)                                               /*!< SYS_T::IRCTISTS: CLKERRIF Position        */
N#define SYS_IRCTISTS_CLKERRIF_Msk        (0x1ul << SYS_IRCTISTS_CLKERRIF_Pos)              /*!< SYS_T::IRCTISTS: CLKERRIF Mask            */
N
N#define SYS_REGLCTL_REGLCTL_Pos          (0)                                               /*!< SYS_T::REGLCTL: REGLCTL Position          */
N#define SYS_REGLCTL_REGLCTL_Msk          (0xfful << SYS_REGLCTL_REGLCTL_Pos)               /*!< SYS_T::REGLCTL: REGLCTL Mask              */
N
N/**@}*/ /* SYS_CONST */
N/**@}*/ /* end of SYS register group */
N
N
N/*---------------------- Timer Controller -------------------------*/
N/**
N    @addtogroup TIMER Timer Controller(TIMER)
N    Memory Mapped Structure for TIMER Controller
N@{ */
N
Ntypedef struct {
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x00  Timer0 Control and Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |PSC       |Prescale Counter
N     * |        |          |Timer input clock or event source is divided by (PSC+1) before it is fed to the timer up counter.
N     * |        |          |If this field is 0 (PSC = 0), then there is no scaling.
N     * |[17]    |CMPCTL    |Timer Compared Mode Select Bit
N     * |        |          |0 = The behavior selection in one-shot or periodic mode Disabled.
N     * |        |          |When user updates CMPDAT while timer is running in one-shot or periodic mode,
N     * |        |          |CNT will be reset to default value.
N     * |        |          |1 = The behavior selection in one-shot or periodic mode Enabled.
N     * |        |          |When user updates CMPDAT while timer is running in one-shot or periodic mode, the limitations as bellows list,
N     * |        |          |If updated CMPDAT value > CNT, CMPDAT will be updated and CNT keep running continually.
N     * |        |          |If updated CMPDAT value = CNT, timer time-out interrupt will be asserted immediately.
N     * |        |          |If updated CMPDAT value < CNT, CNT will be reset to default value.
N     * |[18]    |TGLPINSEL |Toggle-output Pin Select Bit
N     * |        |          |0 = Toggle mode output to TMx (Timer Event Counter Pin).
N     * |        |          |1 = Toggle mode output to TMx_EXT (Timer External Capture Pin).
N     * |[19]    |CAPSRC    |Capture Pin Source Select Bit
N     * |        |          |0 = Capture Function source is from TMx_EXT (x= 0~1)
N     * |        |          |pin.
N     * |        |          |1 = Capture Function source is from internal ACMP output signal.
N     * |        |          |User can set CAPSRCMP (TIMERx_EXTCTL[9]) to decide which ACMP output signal as timer capture source.
N     * |[23]    |WKEN      |Wake-up Function Enable Bit
N     * |        |          |If this bit is set to 1, while the timer interrupt flag TIF (TIMERx_INTSTS[0]) is 1 and INTEN (TIMERx_CTL[29]) is enabled, the timer interrupt signal will generate a wake-up trigger event to CPU.
N     * |        |          |0 = Wake-up function Disabled if timer interrupt signal generated.
N     * |        |          |1 = Wake-up function Enabled if timer interrupt signal generated.
N     * |[24]    |EXTCNTEN  |Event Counter Mode Enable Bit
N     * |        |          |This bit is for external counting pin function enabled.
N     * |        |          |0 = Event counter mode Disabled.
N     * |        |          |1 = Event counter mode Enabled.
N     * |        |          |Note: When timer is used as an event counter, this bit should be set to 1 and select HCLK as timer clock source
N     * |[25]    |ACTSTS    |Timer Active Status (Read Only)
N     * |        |          |This bit indicates the 24-bit up counter status.
N     * |        |          |0 = 24-bit up counter is not active.
N     * |        |          |1 = 24-bit up counter is active.
N     * |[26]    |RSTCNT    |Timer Counter Reset
N     * |        |          |Setting this bit will reset the 24-bit up counter value CNT (TIMERx_CNT[23:0]) and also force CNTEN (TIMERx_CTL[30]) to 0 if ACTSTS (TIMERx_CTL[25]) is 1.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset internal 8-bit prescale counter, 24-bit up counter value and CNTEN bit.
N     * |[28:27] |OPMODE    |Timer Counting Mode Selection
N     * |        |          |00 = The Timer controller is operated in one-shot mode.
N     * |        |          |01 = The Timer controller is operated in periodic mode.
N     * |        |          |10 = The Timer controller is operated in toggle-output mode.
N     * |        |          |11 = The Timer controller is operated in continuous counting mode.
N     * |[29]    |INTEN     |Timer Interrupt Enable Bit
N     * |        |          |0 = Timer Interrupt Disabled.
N     * |        |          |1 = Timer Interrupt Enabled.
N     * |        |          |Note: If this bit is enabled, when the timer interrupt flag TIF is set to 1, the timer interrupt signal will be generated and inform CPU.
N     * |[30]    |CNTEN     |Timer Counting Enable Bit
N     * |        |          |0 = Stops/Suspends counting.
N     * |        |          |1 = Starts counting.
N     * |        |          |Note1: In stop status, and then setting CNTEN to 1 will enable the 24-bit up counter to keep counting from the last stop counting value.
N     * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode (TIMERx_CTL[28:27] = 2'b00) when the timer interrupt flag TIF (TIMERx_INTSTS[0]) is generated.
N     * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Bit (Write Protect)
N     * |        |          |0 = ICE debug mode acknowledgement effects TIMER counting.
N     * |        |          |TIMER counter will be held while CPU is held by ICE.
N     * |        |          |1 = ICE debug mode acknowledgement Disabled.
N     * |        |          |TIMER counter will keep going no matter CPU is held by ICE or not.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N    */
N    __IO uint32_t CTL;
X    volatile uint32_t CTL;
N
N    /**
N     * CMP
N     * ===================================================================================================
N     * Offset: 0x04  Timer0 Compare Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |CMPDAT    |Timer Compared Value
N     * |        |          |CMPDAT is a 24-bit compared value register.
N     * |        |          |When the internal 24-bit up counter value is equal to CMPDAT value, the TIF (TIMERx_INTSTS[0] Timer Interrupt Flag) will set to .
N     * |        |          |Time-out period = (Period of timer clock input) * (8-bit PSC + 1) * (24-bit CMPDAT).
N     * |        |          |Note1: Never write 0x0 or 0x1 in CMPDAT field, or the core will run into unknown state.
N     * |        |          |Note2: When timer is operating at continuous counting mode, the 24-bit up counter will keep counting continuously even if user writes a new value into CMPDAT field.
N     * |        |          |But if timer is operating at other modes, the 24-bit up counter will restart counting from 0 and using newest CMPDAT value to be the timer compared value while user writes a new value into the CMPDAT fiel.
N    */
N    __IO uint32_t CMP;
X    volatile uint32_t CMP;
N
N    /**
N     * INTSTS
N     * ===================================================================================================
N     * Offset: 0x08  Timer0 Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TIF       |Timer Interrupt Flag
N     * |        |          |This bit indicates the interrupt flag status of Timer while 24-bit timer up counter CNT (TIMERx_CNT[23:0]) value reaches to CMPDAT (TIMERx_CMP[23:0]) value.
N     * |        |          |0 = No effect.
N     * |        |          |1 = CNT value matches the CMPDAT value.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[1]     |TWKF      |Timer Wake-up Flag
N     * |        |          |This bit indicates the interrupt wake-up flag status of timer.
N     * |        |          |0 = Timer does not cause CPU wake-up.
N     * |        |          |1 = CPU wake-up from Idle or Power-down mode if timer time-out interrupt signal generated.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N    */
N    __IO uint32_t INTSTS;
X    volatile uint32_t INTSTS;
N
N    /**
N     * CNT
N     * ===================================================================================================
N     * Offset: 0x0C  Timer0 Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |CNT       |Timer Data Register
N     * |        |          |This field can be reflected the internal 24-bit timer counter value or external event input counter value from TMx (x=0~1) pin.
N     * |        |          |If EXTCNTEN (TIMERx_CTL[24]) is 0, user can read CNT value for getting current 24- bit counter value.
N     * |        |          |If EXTCNTEN (TIMERx_CTL[24]) is 1, user can read CNT value for getting current 24- bit event input counter value.
N    */
N    __I  uint32_t CNT;
X    volatile const  uint32_t CNT;
N
N    /**
N     * CAP
N     * ===================================================================================================
N     * Offset: 0x10  Timer0 Capture Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |CAPDAT    |Timer Capture Data Register
N     * |        |          |When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on TMx_EXT pin matched the CAPEDGE (TIMERx_EXTCTL[2:1]) setting, CAPIF (TIMERx_EINTSTS[0]) will set to 1 and the current timer counter value CNT (TIMERx_CNT[23:0]) will be auto-loaded into this CAPDAT field.
N    */
N    __I  uint32_t CAP;
X    volatile const  uint32_t CAP;
N
N    /**
N     * EXTCTL
N     * ===================================================================================================
N     * Offset: 0x14  Timer0 External Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CNTPHASE  |Timer External Count Phase
N     * |        |          |This bit indicates the detection phase of external counting pin TMx (x= 0~1).
N     * |        |          |0 = A falling edge of external counting pin will be counted.
N     * |        |          |1 = A rising edge of external counting pin will be counted.
N     * |[2:1]   |CAPEDGE   |Timer External Capture Pin Edge Detection
N     * |        |          |00 = A falling edge on TMx_EXT (x= 0~1) pin will be detected.
N     * |        |          |01 = A rising edge on TMx_EXT (x= 0~1) pin will be detected.
N     * |        |          |10 = Either rising or falling edge on TMx_EXT (x= 0~1) pin will be detected.
N     * |        |          |11 = Reserved.
N     * |[3]     |CAPEN     |Timer External Capture Pin Enable Bit
N     * |        |          |This bit enables the TMx_EXT pin.
N     * |        |          |0 = TMx_EXT (x= 0~1) pin Disabled.
N     * |        |          |1 = TMx_EXT (x= 0~1) pin Enabled.
N     * |[4]     |CAPFUNCS  |Capture Function Select Bit
N     * |        |          |0 = External Capture Mode Enabled.
N     * |        |          |1 = External Reset Mode Enabled.
N     * |        |          |Note1: When CAPFUNCS is 0, transition on TMx_EXT (x= 0~1) pin is using to save the 24-bit timer counter value to CAPDAT register.
N     * |        |          |Note2: When CAPFUNCS is 1, transition on TMx_EXT (x= 0~1) pin is using to reset the 24-bit timer counter value.
N     * |[5]     |CAPIEN    |Timer External Capture Interrupt Enable Bit
N     * |        |          |0 = TMx_EXT (x= 0~1) pin detection Interrupt Disabled.
N     * |        |          |1 = TMx_EXT (x= 0~1) pin detection Interrupt Enabled.
N     * |        |          |Note: CAPIEN is used to enable timer external interrupt.
N     * |        |          |If CAPIEN enabled, timer will generate an interrupt when CAPIF (TIMERx_EINTSTS[0]) is .
N     * |        |          |For example, while CAPIEN = 1, CAPEN = 1, and CAPEDGE = 00, an 1 to 0 transition on the TMx_EXT pin will cause the CAPIF to be set then the interrupt signal is generated and sent to NVIC to inform CPU.
N     * |[6]     |CAPDBEN   |Timer External Capture Pin De-bounce Enable Bit
N     * |        |          |0 = TMx_EXT (x= 0~1) pin de-bounce Disabled.
N     * |        |          |1 = TMx_EXT (x= 0~1) pin de-bounce Enabled.
N     * |        |          |Note1: If this bit is enabled, the edge detection of TMx_EXT pin is detected with de-bounce circuit.
N     * |        |          |Note2: The de-bounce circuit doesn't support ACMP output.
N     * |[7]     |CNTDBEN   |Timer Counter Pin De-bounce Enable Bit
N     * |        |          |0 = TMx (x= 0~1) pin de-bounce Disabled.
N     * |        |          |1 = TMx (x= 0~1) pin de-bounce Enabled.
N     * |        |          |Note: If this bit is enabled, the edge detection of TMx pin is detected with de-bounce circuit.
N     * |[8]     |CAPSEL    |Capture Mode Select Bit
N     * |        |          |0 = Timer counter reset function or free-counting mode of timer capture function.
N     * |        |          |1 = Trigger-counting mode of timer capture function.
N     * |[9]     |ACMPSSEL  |ACMP Source Selection to Trigger Capture Function
N     * |        |          |For Timer 0:
N     * |        |          |0 = Capture Function source is from ACMP0 output signal for TIMER0.
N     * |        |          |1 = Capture Function source is from ACMP1 output signal for TIMER0.
N     * |        |          |For Timer 1:
N     * |        |          |0 = Capture Function source is from ACMP1 output signal for TIMER1.
N     * |        |          |1 = Capture Function source is from ACMP0 output signal for TIMER1.
N    */
N    __IO uint32_t EXTCTL;
X    volatile uint32_t EXTCTL;
N
N    /**
N     * EINTSTS
N     * ===================================================================================================
N     * Offset: 0x18  Timer0 External Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CAPIF     |Timer External Capture Interrupt Flag
N     * |        |          |This bit indicates the timer external capture interrupt flag status.
N     * |        |          |0 = TMx_EXT (x= 0~1) pin interrupt did not occur.
N     * |        |          |1 = TMx_EXT (x= 0~1) pin interrupt occurred.
N     * |        |          |Note1: This bit is cleared by writing 1 to it.
N     * |        |          |Note2: When CAPEN (TIMERx_EXTCTL[3]) bit is set, CAPFUNCS (TIMERx_EXTCTL[4]) bit is 0, and a transition on TMx_EXT (x= 0~1) pin matched the CAPEDGE (TIMERx_EXTCTL[2:1]) setting, this bit will set to 1 by hardware.
N     * |        |          |Note3: There is a new incoming capture event detected before CPU clearing the CAPIF status.
N     * |        |          |If the above condition occurred, the Timer will keep register TIMERx_CAP unchanged and drop the new capture value.
N    */
N    __IO uint32_t EINTSTS;
X    volatile uint32_t EINTSTS;
N
N} TIMER_T;
N
N/**
N    @addtogroup TIMER_CONST TIMER Bit Field Definition
N    Constant Definitions for TIMER Controller
N@{ */
N
N#define TIMER_CTL_PSC_Pos                  (0)                                               /*!< TIMER_T::CTL: PSC Position                  */
N#define TIMER_CTL_PSC_Msk                  (0xfful << TIMER_CTL_PSC_Pos)                     /*!< TIMER_T::CTL: PSC Mask                      */
N
N#define TIMER_CTL_CMPCTL_Pos               (17)                                              /*!< TIMER_T::CTL: CMPCTL Position               */
N#define TIMER_CTL_CMPCTL_Msk               (0x1ul << TIMER_CTL_CMPCTL_Pos)                   /*!< TIMER_T::CTL: CMPCTL Mask                   */
N
N#define TIMER_CTL_TGLPINSEL_Pos            (18)                                              /*!< TIMER_T::CTL: TGLPINSEL Position            */
N#define TIMER_CTL_TGLPINSEL_Msk            (0x1ul << TIMER_CTL_TGLPINSEL_Pos)                /*!< TIMER_T::CTL: TGLPINSEL Mask                */
N
N#define TIMER_CTL_CAPSRC_Pos               (19)                                              /*!< TIMER_T::CTL: CAPSRC Position               */
N#define TIMER_CTL_CAPSRC_Msk               (0x1ul << TIMER_CTL_CAPSRC_Pos)                   /*!< TIMER_T::CTL: CAPSRC Mask                   */
N
N#define TIMER_CTL_WKEN_Pos                 (23)                                              /*!< TIMER_T::CTL: WKEN Position                 */
N#define TIMER_CTL_WKEN_Msk                 (0x1ul << TIMER_CTL_WKEN_Pos)                     /*!< TIMER_T::CTL: WKEN Mask                     */
N
N#define TIMER_CTL_EXTCNTEN_Pos             (24)                                              /*!< TIMER_T::CTL: EXTCNTEN Position             */
N#define TIMER_CTL_EXTCNTEN_Msk             (0x1ul << TIMER_CTL_EXTCNTEN_Pos)                 /*!< TIMER_T::CTL: EXTCNTEN Mask                 */
N
N#define TIMER_CTL_ACTSTS_Pos               (25)                                              /*!< TIMER_T::CTL: ACTSTS Position               */
N#define TIMER_CTL_ACTSTS_Msk               (0x1ul << TIMER_CTL_ACTSTS_Pos)                   /*!< TIMER_T::CTL: ACTSTS Mask                   */
N
N#define TIMER_CTL_RSTCNT_Pos               (26)                                              /*!< TIMER_T::CTL: RSTCNT Position               */
N#define TIMER_CTL_RSTCNT_Msk               (0x1ul << TIMER_CTL_RSTCNT_Pos)                   /*!< TIMER_T::CTL: RSTCNT Mask                   */
N
N#define TIMER_CTL_OPMODE_Pos               (27)                                              /*!< TIMER_T::CTL: OPMODE Position               */
N#define TIMER_CTL_OPMODE_Msk               (0x3ul << TIMER_CTL_OPMODE_Pos)                   /*!< TIMER_T::CTL: OPMODE Mask                   */
N
N#define TIMER_CTL_INTEN_Pos                (29)                                              /*!< TIMER_T::CTL: INTEN Position                */
N#define TIMER_CTL_INTEN_Msk                (0x1ul << TIMER_CTL_INTEN_Pos)                    /*!< TIMER_T::CTL: INTEN Mask                    */
N
N#define TIMER_CTL_CNTEN_Pos                (30)                                              /*!< TIMER_T::CTL: CNTEN Position                */
N#define TIMER_CTL_CNTEN_Msk                (0x1ul << TIMER_CTL_CNTEN_Pos)                    /*!< TIMER_T::CTL: CNTEN Mask                    */
N
N#define TIMER_CTL_ICEDEBUG_Pos             (31)                                              /*!< TIMER_T::CTL: ICEDEBUG Position             */
N#define TIMER_CTL_ICEDEBUG_Msk             (0x1ul << TIMER_CTL_ICEDEBUG_Pos)                 /*!< TIMER_T::CTL: ICEDEBUG Mask                 */
N
N#define TIMER_CMP_CMPDAT_Pos               (0)                                               /*!< TIMER_T::CMP: CMPDAT Position               */
N#define TIMER_CMP_CMPDAT_Msk               (0xfffffful << TIMER_CMP_CMPDAT_Pos)              /*!< TIMER_T::CMP: CMPDAT Mask                   */
N
N#define TIMER_INTSTS_TIF_Pos               (0)                                               /*!< TIMER_T::INTSTS: TIF Position               */
N#define TIMER_INTSTS_TIF_Msk               (0x1ul << TIMER_INTSTS_TIF_Pos)                   /*!< TIMER_T::INTSTS: TIF Mask                   */
N
N#define TIMER_INTSTS_TWKF_Pos              (1)                                               /*!< TIMER_T::INTSTS: TWKF Position              */
N#define TIMER_INTSTS_TWKF_Msk              (0x1ul << TIMER_INTSTS_TWKF_Pos)                  /*!< TIMER_T::INTSTS: TWKF Mask                  */
N
N#define TIMER_CNT_CNT_Pos                  (0)                                               /*!< TIMER_T::CNT: CNT Position                  */
N#define TIMER_CNT_CNT_Msk                  (0xfffffful << TIMER_CNT_CNT_Pos)                 /*!< TIMER_T::CNT: CNT Mask                      */
N
N#define TIMER_CAP_CAPDAT_Pos               (0)                                               /*!< TIMER_T::CAP: CAPDAT Position               */
N#define TIMER_CAP_CAPDAT_Msk               (0xfffffful << TIMER_CAP_CAPDAT_Pos)              /*!< TIMER_T::CAP: CAPDAT Mask                   */
N
N#define TIMER_EXTCTL_CNTPHASE_Pos          (0)                                               /*!< TIMER_T::EXTCTL: CNTPHASE Position          */
N#define TIMER_EXTCTL_CNTPHASE_Msk          (0x1ul << TIMER_EXTCTL_CNTPHASE_Pos)              /*!< TIMER_T::EXTCTL: CNTPHASE Mask              */
N
N#define TIMER_EXTCTL_CAPEDGE_Pos           (1)                                               /*!< TIMER_T::EXTCTL: CAPEDGE Position           */
N#define TIMER_EXTCTL_CAPEDGE_Msk           (0x3ul << TIMER_EXTCTL_CAPEDGE_Pos)               /*!< TIMER_T::EXTCTL: CAPEDGE Mask               */
N
N#define TIMER_EXTCTL_CAPEN_Pos             (3)                                               /*!< TIMER_T::EXTCTL: CAPEN Position             */
N#define TIMER_EXTCTL_CAPEN_Msk             (0x1ul << TIMER_EXTCTL_CAPEN_Pos)                 /*!< TIMER_T::EXTCTL: CAPEN Mask                 */
N
N#define TIMER_EXTCTL_CAPFUNCS_Pos          (4)                                               /*!< TIMER_T::EXTCTL: CAPFUNCS Position          */
N#define TIMER_EXTCTL_CAPFUNCS_Msk          (0x1ul << TIMER_EXTCTL_CAPFUNCS_Pos)              /*!< TIMER_T::EXTCTL: CAPFUNCS Mask              */
N
N#define TIMER_EXTCTL_CAPIEN_Pos            (5)                                               /*!< TIMER_T::EXTCTL: CAPIEN Position            */
N#define TIMER_EXTCTL_CAPIEN_Msk            (0x1ul << TIMER_EXTCTL_CAPIEN_Pos)                /*!< TIMER_T::EXTCTL: CAPIEN Mask                */
N
N#define TIMER_EXTCTL_CAPDBEN_Pos           (6)                                               /*!< TIMER_T::EXTCTL: CAPDBEN Position           */
N#define TIMER_EXTCTL_CAPDBEN_Msk           (0x1ul << TIMER_EXTCTL_CAPDBEN_Pos)               /*!< TIMER_T::EXTCTL: CAPDBEN Mask               */
N
N#define TIMER_EXTCTL_CNTDBEN_Pos           (7)                                               /*!< TIMER_T::EXTCTL: CNTDBEN Position           */
N#define TIMER_EXTCTL_CNTDBEN_Msk           (0x1ul << TIMER_EXTCTL_CNTDBEN_Pos)               /*!< TIMER_T::EXTCTL: CNTDBEN Mask               */
N
N#define TIMER_EXTCTL_CAPSEL_Pos            (8)                                               /*!< TIMER_T::EXTCTL: CAPSEL Position            */
N#define TIMER_EXTCTL_CAPSEL_Msk            (0x1ul << TIMER_EXTCTL_CAPSEL_Pos)                /*!< TIMER_T::EXTCTL: CAPSEL Mask                */
N
N#define TIMER_EXTCTL_ACMPSSEL_Pos          (9)                                               /*!< TIMER_T::EXTCTL: ACMPSSEL Position          */
N#define TIMER_EXTCTL_ACMPSSEL_Msk          (0x1ul << TIMER_EXTCTL_ACMPSSEL_Pos)              /*!< TIMER_T::EXTCTL: ACMPSSEL Mask              */
N
N#define TIMER_EINTSTS_CAPIF_Pos            (0)                                               /*!< TIMER_T::EINTSTS: CAPIF Position            */
N#define TIMER_EINTSTS_CAPIF_Msk            (0x1ul << TIMER_EINTSTS_CAPIF_Pos)                /*!< TIMER_T::EINTSTS: CAPIF Mask                */
N
N#define TIMER_CTL_PSC_Pos                  (0)                                               /*!< TIMER_T::CTL: PSC Position                  */
N#define TIMER_CTL_PSC_Msk                  (0xfful << TIMER_CTL_PSC_Pos)                     /*!< TIMER_T::CTL: PSC Mask                      */
N
N#define TIMER_CTL_CMPCTL_Pos               (17)                                              /*!< TIMER_T::CTL: CMPCTL Position               */
N#define TIMER_CTL_CMPCTL_Msk               (0x1ul << TIMER_CTL_CMPCTL_Pos)                   /*!< TIMER_T::CTL: CMPCTL Mask                   */
N
N#define TIMER_CTL_TGLPINSEL_Pos            (18)                                              /*!< TIMER_T::CTL: TGLPINSEL Position            */
N#define TIMER_CTL_TGLPINSEL_Msk            (0x1ul << TIMER_CTL_TGLPINSEL_Pos)                /*!< TIMER_T::CTL: TGLPINSEL Mask                */
N
N#define TIMER_CTL_CAPSRC_Pos               (19)                                              /*!< TIMER_T::CTL: CAPSRC Position               */
N#define TIMER_CTL_CAPSRC_Msk               (0x1ul << TIMER_CTL_CAPSRC_Pos)                   /*!< TIMER_T::CTL: CAPSRC Mask                   */
N
N#define TIMER_CTL_WKEN_Pos                 (23)                                              /*!< TIMER_T::CTL: WKEN Position                 */
N#define TIMER_CTL_WKEN_Msk                 (0x1ul << TIMER_CTL_WKEN_Pos)                     /*!< TIMER_T::CTL: WKEN Mask                     */
N
N#define TIMER_CTL_EXTCNTEN_Pos             (24)                                              /*!< TIMER_T::CTL: EXTCNTEN Position             */
N#define TIMER_CTL_EXTCNTEN_Msk             (0x1ul << TIMER_CTL_EXTCNTEN_Pos)                 /*!< TIMER_T::CTL: EXTCNTEN Mask                 */
N
N#define TIMER_CTL_ACTSTS_Pos               (25)                                              /*!< TIMER_T::CTL: ACTSTS Position               */
N#define TIMER_CTL_ACTSTS_Msk               (0x1ul << TIMER_CTL_ACTSTS_Pos)                   /*!< TIMER_T::CTL: ACTSTS Mask                   */
N
N#define TIMER_CTL_RSTCNT_Pos               (26)                                              /*!< TIMER_T::CTL: RSTCNT Position               */
N#define TIMER_CTL_RSTCNT_Msk               (0x1ul << TIMER_CTL_RSTCNT_Pos)                   /*!< TIMER_T::CTL: RSTCNT Mask                   */
N
N#define TIMER_CTL_OPMODE_Pos               (27)                                              /*!< TIMER_T::CTL: OPMODE Position               */
N#define TIMER_CTL_OPMODE_Msk               (0x3ul << TIMER_CTL_OPMODE_Pos)                   /*!< TIMER_T::CTL: OPMODE Mask                   */
N
N#define TIMER_CTL_INTEN_Pos                (29)                                              /*!< TIMER_T::CTL: INTEN Position                */
N#define TIMER_CTL_INTEN_Msk                (0x1ul << TIMER_CTL_INTEN_Pos)                    /*!< TIMER_T::CTL: INTEN Mask                    */
N
N#define TIMER_CTL_CNTEN_Pos                (30)                                              /*!< TIMER_T::CTL: CNTEN Position                */
N#define TIMER_CTL_CNTEN_Msk                (0x1ul << TIMER_CTL_CNTEN_Pos)                    /*!< TIMER_T::CTL: CNTEN Mask                    */
N
N#define TIMER_CTL_ICEDEBUG_Pos             (31)                                              /*!< TIMER_T::CTL: ICEDEBUG Position             */
N#define TIMER_CTL_ICEDEBUG_Msk             (0x1ul << TIMER_CTL_ICEDEBUG_Pos)                 /*!< TIMER_T::CTL: ICEDEBUG Mask                 */
N
N#define TIMER_CMP_CMPDAT_Pos               (0)                                               /*!< TIMER_T::CMP: CMPDAT Position               */
N#define TIMER_CMP_CMPDAT_Msk               (0xfffffful << TIMER_CMP_CMPDAT_Pos)              /*!< TIMER_T::CMP: CMPDAT Mask                   */
N
N#define TIMER_INTSTS_TIF_Pos               (0)                                               /*!< TIMER_T::INTSTS: TIF Position               */
N#define TIMER_INTSTS_TIF_Msk               (0x1ul << TIMER_INTSTS_TIF_Pos)                   /*!< TIMER_T::INTSTS: TIF Mask                   */
N
N#define TIMER_INTSTS_TWKF_Pos              (1)                                               /*!< TIMER_T::INTSTS: TWKF Position              */
N#define TIMER_INTSTS_TWKF_Msk              (0x1ul << TIMER_INTSTS_TWKF_Pos)                  /*!< TIMER_T::INTSTS: TWKF Mask                  */
N
N#define TIMER_CNT_CNT_Pos                  (0)                                               /*!< TIMER_T::CNT: CNT Position                  */
N#define TIMER_CNT_CNT_Msk                  (0xfffffful << TIMER_CNT_CNT_Pos)                 /*!< TIMER_T::CNT: CNT Mask                      */
N
N#define TIMER_CAP_CAPDAT_Pos               (0)                                               /*!< TIMER_T::CAP: CAPDAT Position               */
N#define TIMER_CAP_CAPDAT_Msk               (0xfffffful << TIMER_CAP_CAPDAT_Pos)              /*!< TIMER_T::CAP: CAPDAT Mask                   */
N
N#define TIMER_EXTCTL_CNTPHASE_Pos          (0)                                               /*!< TIMER_T::EXTCTL: CNTPHASE Position          */
N#define TIMER_EXTCTL_CNTPHASE_Msk          (0x1ul << TIMER_EXTCTL_CNTPHASE_Pos)              /*!< TIMER_T::EXTCTL: CNTPHASE Mask              */
N
N#define TIMER_EXTCTL_CAPEDGE_Pos           (1)                                               /*!< TIMER_T::EXTCTL: CAPEDGE Position           */
N#define TIMER_EXTCTL_CAPEDGE_Msk           (0x3ul << TIMER_EXTCTL_CAPEDGE_Pos)               /*!< TIMER_T::EXTCTL: CAPEDGE Mask               */
N
N#define TIMER_EXTCTL_CAPEN_Pos             (3)                                               /*!< TIMER_T::EXTCTL: CAPEN Position             */
N#define TIMER_EXTCTL_CAPEN_Msk             (0x1ul << TIMER_EXTCTL_CAPEN_Pos)                 /*!< TIMER_T::EXTCTL: CAPEN Mask                 */
N
N#define TIMER_EXTCTL_CAPFUNCS_Pos          (4)                                               /*!< TIMER_T::EXTCTL: CAPFUNCS Position          */
N#define TIMER_EXTCTL_CAPFUNCS_Msk          (0x1ul << TIMER_EXTCTL_CAPFUNCS_Pos)              /*!< TIMER_T::EXTCTL: CAPFUNCS Mask              */
N
N#define TIMER_EXTCTL_CAPIEN_Pos            (5)                                               /*!< TIMER_T::EXTCTL: CAPIEN Position            */
N#define TIMER_EXTCTL_CAPIEN_Msk            (0x1ul << TIMER_EXTCTL_CAPIEN_Pos)                /*!< TIMER_T::EXTCTL: CAPIEN Mask                */
N
N#define TIMER_EXTCTL_CAPDBEN_Pos           (6)                                               /*!< TIMER_T::EXTCTL: CAPDBEN Position           */
N#define TIMER_EXTCTL_CAPDBEN_Msk           (0x1ul << TIMER_EXTCTL_CAPDBEN_Pos)               /*!< TIMER_T::EXTCTL: CAPDBEN Mask               */
N
N#define TIMER_EXTCTL_CNTDBEN_Pos           (7)                                               /*!< TIMER_T::EXTCTL: CNTDBEN Position           */
N#define TIMER_EXTCTL_CNTDBEN_Msk           (0x1ul << TIMER_EXTCTL_CNTDBEN_Pos)               /*!< TIMER_T::EXTCTL: CNTDBEN Mask               */
N
N#define TIMER_EXTCTL_CAPSEL_Pos            (8)                                               /*!< TIMER_T::EXTCTL: CAPSEL Position            */
N#define TIMER_EXTCTL_CAPSEL_Msk            (0x1ul << TIMER_EXTCTL_CAPSEL_Pos)                /*!< TIMER_T::EXTCTL: CAPSEL Mask                */
N
N#define TIMER_EXTCTL_ACMPSSEL_Pos          (9)                                               /*!< TIMER_T::EXTCTL: ACMPSSEL Position          */
N#define TIMER_EXTCTL_ACMPSSEL_Msk          (0x1ul << TIMER_EXTCTL_ACMPSSEL_Pos)              /*!< TIMER_T::EXTCTL: ACMPSSEL Mask              */
N
N#define TIMER_EINTSTS_CAPIF_Pos            (0)                                               /*!< TIMER_T::EINTSTS: CAPIF Position            */
N#define TIMER_EINTSTS_CAPIF_Msk            (0x1ul << TIMER_EINTSTS_CAPIF_Pos)                /*!< TIMER_T::EINTSTS: CAPIF Mask                */
N
N/**@}*/ /* TIMER_CONST */
N/**@}*/ /* end of TIMER register group */
N
N
N/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
N/**
N    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
N    Memory Mapped Structure for UART Controller
N@{ */
N
Ntypedef struct {
N
N
N    /**
N     * DAT
N     * ===================================================================================================
N     * Offset: 0x00  UART Receive/Transmit Buffer Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |DAT       |Receiving/Transmit Buffer
N     * |        |          |Write Operation:
N     * |        |          |By writing one byte to this register, the data byte will be stored in transmitter FIFO.
N     * |        |          |The UART Controller will send out the data stored in transmitter FIFO top location through the UART_TX.
N     * |        |          |Read Operation:
N     * |        |          |By reading this register, the UART will return an 8-bit data received from receiving FIFO.
N    */
N    __IO uint32_t DAT;
X    volatile uint32_t DAT;
N
N    /**
N     * INTEN
N     * ===================================================================================================
N     * Offset: 0x04  UART Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDAIEN    |Receive Data Available Interrupt Enable Bit
N     * |        |          |0 = RDAINT Masked off.
N     * |        |          |1 = RDAINT Enabled.
N     * |[1]     |THREIEN   |Transmit Holding Register Empty Interrupt Enable Bit
N     * |        |          |0 = THREINT Masked off.
N     * |        |          |1 = THREINT Enabled.
N     * |[2]     |RLSIEN    |Receive Line Status Interrupt Enable Bit
N     * |        |          |0 = RLSINT Masked off.
N     * |        |          |1 = RLSINT Enabled.
N     * |[3]     |MODEMIEN  |Modem Status Interrupt Enable Bit
N     * |        |          |0 = MODEMINT Masked off.
N     * |        |          |1 = MODEMINT Enabled.
N     * |[4]     |RXTOIEN   |RX Time-out Interrupt Enable Bit
N     * |        |          |0 = RXTOINT Masked off.
N     * |        |          |1 = RXTOINT Enabled.
N     * |[5]     |BUFERRIEN |Buffer Error Interrupt Enable Bit
N     * |        |          |0 = Buffer Error Interrupt Masked Disabled.
N     * |        |          |1 = Buffer Error Interrupt Masked Enabled.
N     * |[9]     |WKCTSIEN  |Wake-up CPU Function Interrupt Enable Bit (Only Available In UART0)
N     * |        |          |0 = UART wake-up function Disabled.
N     * |        |          |1 = UART Wake-up function Enabled.
N     * |        |          |Note: When the chip is in Power-down mode, an external CTS change will wake-up chip from Power-down mode.
N     * |[11]    |TOCNTEN   |Time-out Counter Enable Bit
N     * |        |          |0 = Time-out counter Disabled.
N     * |        |          |1 = Time-out counter Enabled.
N     * |[12]    |ATORTSEN  |RTS Auto Flow Control Enable Bit (Only Available In UART0)
N     * |        |          |0 = RTS auto flow control Disabled.
N     * |        |          |1 = RTS auto flow control Enabled.
N     * |        |          |Note: When RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTSTRGLV (UART_FIFO [19:16]), the UART will de-assert RTS signal.
N     * |[13]    |ATOCTSEN  |CTS Auto Flow Control Enable Bit (Only Available In UART0)
N     * |        |          |0 = CTS auto flow control Disabled.
N     * |        |          |1 = CTS auto flow control Enabled.
N     * |        |          |Note: When CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).
N    */
N    __IO uint32_t INTEN;
X    volatile uint32_t INTEN;
N
N    /**
N     * FIFO
N     * ===================================================================================================
N     * Offset: 0x08  UART FIFO Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |RXRST     |RX Field Software Reset
N     * |        |          |When RX_RST is set, all the byte in the receiver FIFO and RX internal state machine are cleared.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset RX internal state machine and pointers reset.
N     * |        |          |Note: This bit will auto clear needs at least 3 UART Controller peripheral clock cycles.
N     * |[2]     |TXRST     |TX Field Software Reset
N     * |        |          |When TX_RST is set, all the byte in the transmit FIFO and TX internal state machine are cleared.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset TX internal state machine and pointers reset.
N     * |        |          |Note: This bit will auto clear needs at least 3 UART Controller peripheral clock cycles.
N     * |[7:4]   |RFITL     |RX FIFO Interrupt (RDAINT) Trigger Level (Only Available In UART0)
N     * |        |          |When the number of bytes in the receive FIFO equals the RFITL then the RDAIF will be set (if RDAIEN in UART_INTEN register is enable, an interrupt will generated).
N     * |        |          |0000 = RX FIFO Interrupt Trigger Level is 1 byte.
N     * |        |          |0001 = RX FIFO Interrupt Trigger Level is 4 bytes.
N     * |        |          |0010 = RX FIFO Interrupt Trigger Level is 8 bytes.
N     * |        |          |0011 = RX FIFO Interrupt Trigger Level is 14 bytes.
N     * |        |          |Other = Reserved.
N     * |[8]     |RXOFF     |Receiver Disable Register (Only Available In UART0)
N     * |        |          |The receiver is disabled or not (setting 1 to disable the receiver).
N     * |        |          |0 = Receiver Enabled.
N     * |        |          |1 = Receiver Disabled.
N     * |        |          |Note: This field is used for RS-485 Normal Multi-drop mode.
N     * |        |          |It should be programmed before RS-485_NMM (UART_ALTCTL [8]) is programme.
N     * |[19:16] |RTSTRGLV  |RTS Trigger Level (For Auto-flow Control Use) (Only Available In UART0)
N     * |        |          |0000 = RTS Trigger Level is 1 byte.
N     * |        |          |0001 = RTS Trigger Level is 4 bytes.
N     * |        |          |0010 = RTS Trigger Level is 8 bytes.
N     * |        |          |0011 = RTS Trigger Level is 14 bytes.
N     * |        |          |Other = Reserved.
N     * |        |          |Note: This field is used for RTS auto-flow control.
N    */
N    __IO uint32_t FIFO;
X    volatile uint32_t FIFO;
N
N    /**
N     * LINE
N     * ===================================================================================================
N     * Offset: 0x0C  UART Line Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |WLS       |Word Length Select Bit
N     * |        |          |00 = Word length is 5-bit.
N     * |        |          |01 = Word length is 6-bit.
N     * |        |          |10 = Word length is 7-bit.
N     * |        |          |11 = Word length is 8-bit.
N     * |[2]     |NSB       |Number of "STOP Bit"
N     * |        |          |0 = One "STOP bit" is generated in the transmitted data.
N     * |        |          |1 = When select 5-bit word length, 1.5 "STOP bit" is generated in the transmitted data.
N     * |        |          |When select 6-, 7- and 8-bit word length, 2 "STOP bit" is generated in the transmitted data.
N     * |[3]     |PBE       |Parity Bit Enable Bit
N     * |        |          |0 = No parity bit.
N     * |        |          |1 = Parity bit is generated on each outgoing character and is checked on each incoming data.
N     * |[4]     |EPE       |Even Parity Enable Bit
N     * |        |          |0 = Odd number of logic 1's is transmitted and checked in each word.
N     * |        |          |1 = Even number of logic 1's is transmitted and checked in each word.
N     * |        |          |This bit has effect only when PBE (UART_LINE[3]) is set.
N     * |[5]     |SPE       |Stick Parity Enable Bit
N     * |        |          |0 = Stick parity Disabled.
N     * |        |          |1 = If PBE (UART_LINE[3]) and EPE (UART_LINE[4]) are logic 1, the parity bit is transmitted and checked as logic 0.
N     * |        |          |If PBE (UART_LINE[3]) is 1 and EPE (UART_LINE[4]) is 0 then the parity bit is transmitted and checked as .
N     * |[6]     |BCB       |Break Control Bit
N     * |        |          |When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0).
N     * |        |          |This bit acts only on TX and has no effect on the transmitter logic.
N     * |        |          |0 = Break control Disabled.
N     * |        |          |1 = Break control Enabled.
N    */
N    __IO uint32_t LINE;
X    volatile uint32_t LINE;
N
N    /**
N     * MODEM
N     * ===================================================================================================
N     * Offset: 0x10  UART Modem Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |RTS       |RTS (Request-to-send) Signal Control
N     * |        |          |This bit is direct control internal RTS signal active or not, and then drive the RTS pin output with RTSACTLV bit configuration.
N     * |        |          |0 = RTS signal is active.
N     * |        |          |1 = RTS signal is inactive.
N     * |        |          |Note1: This RTS signal control bit is not effective when RTS auto-flow control is enabled in UART function mode.
N     * |        |          |Note2: This RTS signal control bit is not effective when RS-485 auto direction mode (AUD) is enabled in RS-485 function mode.
N     * |[9]     |RTSACTLV  |RTS Pin Active Level
N     * |        |          |This bit defines the active level state of RTS pin output.
N     * |        |          |0 = RTS pin output is high level active.
N     * |        |          |1 = RTS pin output is low level active. (Default)
N     * |        |          |Note1: Refer to Figure 6.10-13 and Figure 6.10-14 UART function mode.
N     * |        |          |Note2: Refer to Figure 6.10-17 and Figure 6.10-18 for RS-485 function mode.
N     * |[13]    |RTSSTS    |RTS Pin State (Read Only)
N     * |        |          |This bit mirror from RTS pin output of voltage logic status.
N     * |        |          |0 = RTS pin output is low level voltage logic state.
N     * |        |          |1 = RTS pin output is high level voltage logic state.
N    */
N    __IO uint32_t MODEM;
X    volatile uint32_t MODEM;
N
N    /**
N     * MODEMSTS
N     * ===================================================================================================
N     * Offset: 0x14  UART Modem Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CTSDETF   |Detect CTS State Change Flag
N     * |        |          |This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when MODEMIEN (UART_INTEN [3]) is set to 1.
N     * |        |          |0 = CTS input has not change state.
N     * |        |          |1 = CTS input has change state.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[4]     |CTSSTS    |CTS Pin Status (Read Only)
N     * |        |          |This bit mirror from CTS pin input of voltage logic status.
N     * |        |          |0 = CTS pin input is low level voltage logic state.
N     * |        |          |1 = CTS pin input is high level voltage logic state.
N     * |        |          |Note: This bit echoes when UART Controller peripheral clock is enabled, and CTS multi-function port is selected.
N     * |[8]     |CTSACTLV  |CTS Pin Active Level
N     * |        |          |This bit defines the active level state of CTS pin input.
N     * |        |          |0 = CTS pin input is high level active.
N     * |        |          |1 = CTS pin input is low level active. (Default)
N    */
N    __IO uint32_t MODEMSTS;
X    volatile uint32_t MODEMSTS;
N
N    /**
N     * FIFOSTS
N     * ===================================================================================================
N     * Offset: 0x18  UART FIFO Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RXOVIF    |RX Overflow Error Interrupt Flag
N     * |        |          |This bit is set when RX FIFO overflow.
N     * |        |          |If the number of bytes of received data is greater than RX_FIFO (UART_DAT) size, 16 bytes this bit will be set.
N     * |        |          |0 = RX FIFO did not overflow.
N     * |        |          |1 = RX FIFO overflowed.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[3]     |ADDRDETF  |RS-485 Address Byte Detection Flag (Only Available In UART0)
N     * |        |          |This bit is set to 1 while ADDRDEN (UART_ALTCTL[15]) is set to 1 to enable Address detection mode and receive detect a data with an address bit (bit 9 = 1).
N     * |        |          |Note1: This field is used for RS-485 function mode.
N     * |        |          |Note2: This bit is cleared by writing 1 to it.
N     * |[4]     |PEF       |Parity Error Flag (Read Only)
N     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "parity bit".
N     * |        |          |0 = No parity error is generated.
N     * |        |          |1 = Parity error is generate.
N     * |        |          |Note: This bit is read only, but can be cleared by writing '1' to it.
N     * |[5]     |FEF       |Framing Error Flag (Read Only)
N     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit follows the last data bit or parity bit is detected as logic 0).
N     * |        |          |0 = No framing error is generated.
N     * |        |          |1 = Framing error is generated.
N     * |        |          |Note: This bit is read only, but can be cleared by writing '1' to it .
N     * |[6]     |BIF       |Break Interrupt Flag (Read Only)
N     * |        |          |This bit is set to logic 1 whenever the received data input (RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits).
N     * |        |          |0 = No Break interrupt is generated.
N     * |        |          |1 = Break interrupt is generated.
N     * |        |          |Note: This bit is read only, but software can write 1 to clear it.
N     * |[13:8]  |RXPTR     |RX FIFO Pointer (Read Only)
N     * |        |          |This field indicates the RX FIFO Buffer Pointer.
N     * |        |          |When UART receives one byte from external device, RXPTR increases one.
N     * |        |          |When one byte of RX FIFO is read by CPU, RXPTR decreases on.
N     * |        |          |The Maximum value shown in RXPTR is 15.
N     * |        |          |When the using level of RX FIFO Buffer equal to 16, the RXFULL bit is set to 1 and RXPTR will show 0.
N     * |        |          |As one byte of RX FIFO is read by CPU, the RXFULL bit is cleared to 0 and RXPTR will show 1.
N     * |[14]    |RXEMPTY   |Receiver FIFO Empty (Read Only)
N     * |        |          |This bit initiate RX FIFO empty or not.
N     * |        |          |0 = RX FIFO is not empty.
N     * |        |          |1 = RX FIFO is empty.
N     * |        |          |Note: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high.
N     * |        |          |It will be cleared when UART receives any new data.
N     * |[15]    |RXFULL    |Receiver FIFO Full (Read Only)
N     * |        |          |This bit initiates RX FIFO full or not.
N     * |        |          |0 = RX FIFO is not full.
N     * |        |          |1 = RX FIFO is full.
N     * |        |          |Note: This bit is set when the number of usage in RX FIFO Buffer is equal to 16, otherwise is cleared by hardware.
N     * |[21:16] |TXPTR     |TX FIFO Pointer (Read Only)
N     * |        |          |This field indicates the TX FIFO Buffer Pointer.
N     * |        |          |When CPU writes one byte into UART_DAT, TXPTR increases one.
N     * |        |          |When one byte of TX FIFO is transferred to Transmitter Shift Register, TXPTR decreases on.
N     * |        |          |The Maximum value shown in TXPTR is 15.
N     * |        |          |When the using level of TX FIFO Buffer equal to 16, the TXFULL bit is set to 1 and TXPTR will show 0.
N     * |        |          |As one byte of TX FIFO is transferred to Transmitter Shift Register, the TXFULL bit is cleared to 0 and TXPTR will show 1.
N     * |[22]    |TXEMPTY   |Transmitter FIFO Empty (Read Only)
N     * |        |          |This bit indicates TX FIFO empty or not.
N     * |        |          |0 = TX FIFO is not empty.
N     * |        |          |1 = TX FIFO is empty.
N     * |        |          |Note: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high.
N     * |        |          |It will be cleared when writing data into THR (TX FIFO not empty).
N     * |[23]    |TXFULL    |Transmitter FIFO Full (Read Only)
N     * |        |          |This bit indicates TX FIFO full or not.
N     * |        |          |0 = TX FIFO is not full.
N     * |        |          |1 = TX FIFO is full.
N     * |        |          |Note: This bit is set when the number of usage in TX FIFO Buffer is equal to 16, otherwise is cleared by hardware.
N     * |[24]    |TXOVIF    |TX Overflow Error Interrupt Flag
N     * |        |          |If TX FIFO (UART_DAT) is full, an additional write to UART_DAT will cause this bit to
N     * |        |          |logic 1.
N     * |        |          |0 = TX FIFO did not overflow.
N     * |        |          |1 = TX FIFO overflowed.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[28]    |TXEMPTYF  |Transmitter Empty Flag (Read Only)
N     * |        |          |This bit is set by hardware when TX FIFO (UART_DAT) is empty and the STOP bit of the last byte has been transmitted.
N     * |        |          |0 = TX FIFO is not empty.
N     * |        |          |1 = TX FIFO is empty.
N     * |        |          |Note: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.
N    */
N    __IO uint32_t FIFOSTS;
X    volatile uint32_t FIFOSTS;
N
N    /**
N     * INTSTS
N     * ===================================================================================================
N     * Offset: 0x1C  UART Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDAIF     |Receive Data Available Interrupt Flag (Read Only)
N     * |        |          |When the number of bytes in the RX FIFO equals the RFITL(UART_FIFO[7:4]) then the RDAIF(UART_INTSTS[0]) will be set.
N     * |        |          |If RDAIEN (UART_INTEN [0]) is enabled, the RDA interrupt will be generate.
N     * |        |          |0 = No RDA interrupt flag is generated.
N     * |        |          |1 = RDA interrupt flag is generated.
N     * |        |          |Note: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL (UART_FIFO[7:4])).
N     * |[1]     |THREIF    |Transmit Holding Register Empty Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register.
N     * |        |          |If THREIEN (UART_INTEN [1]) is enabled, the THRE interrupt will be generate.
N     * |        |          |0 = No THRE interrupt flag is generated.
N     * |        |          |1 = THRE interrupt flag is generated.
N     * |        |          |Note: This bit is read only and it will be cleared when writing data into UART_DAT (TX FIFO not empty).
N     * |[2]     |RLSIF     |Receive Line Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the RX receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set).
N     * |        |          |If RLSIEN (UART_INTEN [2]) is enabled, the RLS interrupt will be generate.
N     * |        |          |0 = No RLS interrupt flag is generated.
N     * |        |          |1 = RLS interrupt flag is generated.
N     * |        |          |Note1: In RS-485 function mode, this field is set including "receiver detects and receives address byte character (bit 9 = 1) bit".
N     * |        |          |At the same time, the bit of ADDRDETF (UART_FIFOSTS[3]) is also set.
N     * |        |          |(Only Available in UART0).
N     * |        |          |Note2: This bit is read only and reset to 0 when all bits of BIF (UART_FIFOSTS[6]), FEF (UART_FIFOSTS[5]), PEF (UART_FIFOSTS[4]) and ADDRDETF (UART_FIFOSTS[3]) are cleared.
N     * |        |          |(Only Available in UART0).
N     * |[3]     |MODEMIF   |MODEM Interrupt Flag (Read Only) (Only Available In UART0)
N     * |        |          |This bit is set when the CTS pin has state change (CTSDETF (UART_MODEMSTS[0]) = 1).
N     * |        |          |If MODEMIEN (UART_INTEN[3]) is enabled, the Modem interrupt will be generate.
N     * |        |          |0 = No Modem interrupt flag is generated.
N     * |        |          |1 = Modem interrupt flag is generated.
N     * |        |          |Note: This bit is read only and reset to 0 when bit CTSDETF (UART_MODEMSTS[0]) is cleared by a write 1 on CTSDETF (UART_MODEMSTS[0]).
N     * |[4]     |RXTOIF    |Time-out Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC (UARTTOUT[7:0]).
N     * |        |          |If RXTOIEN (UART_INTEN [4]) is enabled, the Tout interrupt will be generate.
N     * |        |          |0 = No Time-out interrupt flag is generated.
N     * |        |          |1 = Time-out interrupt flag is generated.
N     * |        |          |Note: This bit is read only and user can read UART_DAT (RX is in active) to clear it.
N     * |[5]     |BUFERRIF  |Buffer Error Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the TX/RX FIFO overflow flag (TXOVIF (UART_FIFOSTS[24]) or RXOVIF(UART_FIFOSTS[0])) is set.
N     * |        |          |When BUFERRIF (UART_INTSTS[5]) is set, the transfer is not correct.
N     * |        |          |If BUFERRIEN (UART_INTEN[5]) is enabled, the buffer error interrupt will be generate.
N     * |        |          |0 = No buffer error interrupt flag is generated.
N     * |        |          |1 = Buffer error interrupt flag is generated.
N     * |        |          |Note: This bit is read only and reset to 0 when all bits of TXOVIF (UART_FIFOSTS[24]) and RXOVIF (UART_FIFOSTS[0]) are cleared.
N     * |[8]     |RDAINT    |Receive Data Available Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if RDAIEN (UART_INTEN[0]) and RDAIF (UART_INTSTS[0]) are both set to 1.
N     * |        |          |0 = No RDA interrupt is generated.
N     * |        |          |1 = RDA interrupt is generated.
N     * |[9]     |THREINT   |Transmit Holding Register Empty Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if THREIEN (UART_INTEN[1]) and THREIF (UART_INTSTS[1]) are both set to 1.
N     * |        |          |0 = No THRE interrupt is generated.
N     * |        |          |1 = THRE interrupt is generated.
N     * |[10]    |RLSINT    |Receive Line Status Interrupt (Read Only)
N     * |        |          |This bit is set if RLSIEN (UART_INTEN[2]) and RLSIF (UART_INTSTS[2]) are both set to 1.
N     * |        |          |0 = No RLS interrupt is generated.
N     * |        |          |1 = RLS interrupt is generated.
N     * |[11]    |MODEMINT  |MODEM Status Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if MODEMIEN (UART_INTEN[3]) and MODENIF (UART_INTSTS[3]) are both set to 1.
N     * |        |          |0 = No Modem interrupt is generated.
N     * |        |          |1 = Modem interrupt is generated.
N     * |[12]    |RXTOINT   |Time-out Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if RXTOIEN (UART_INTEN[4]) and RXTOIF (UART_INTSTS[4]) are both set to 1.
N     * |        |          |0 = No Time-out interrupt is generated.
N     * |        |          |1 = Time-out interrupt is generated.
N     * |[13]    |BUFERRINT |Buffer Error Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if BUFERRIEN (UART_INTEN[5]) and BUFERRIF (UART_INTSTS[5]) are both set to 1.
N     * |        |          |0 = No buffer error interrupt is generated.
N     * |        |          |1 = buffer error interrupt is generated.
N     * |[16]    |CTSWKIF   |NCTS Wake-up Interrupt Flag (Read Only) (Only Available In UART0)
N     * |        |          |0 = Chip stays in power-down state.
N     * |        |          |1 = Chip wake-up from power-down state by nCTS wake-up.
N     * |        |          |Note1: If WKCTSIEN (UART_IER[9])is enabled, the wake-up interrupt is generated.
N     * |        |          |Note2: This bit is read only, but can be cleared by writing '1' to it.
N    */
N    __IO  uint32_t INTSTS;
X    volatile  uint32_t INTSTS;
N
N    /**
N     * TOUT
N     * ===================================================================================================
N     * Offset: 0x20  UART Time-out Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |TOIC      |Time-out Interrupt Comparator
N     * |        |          |The time-out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word.
N     * |        |          |Once the content of time-out counter (TOUT_CNT) is equal to that of time-out interrupt comparator (TOIC), a receiver time-out interrupt (RXTOINT) is generated if RXTOIEN (UART_INTEN[4]) is enabled.
N     * |        |          |A new incoming data word or RX FIFO empty clears RXTOINT.
N     * |        |          |In order to avoid receiver time-out interrupt generation immediately during one character is being received, TOIC value should be set between 40 and 255.
N     * |        |          |So, for example, if TOIC is set with 40, the time-out interrupt is generated after four characters are not received when 1 stop bit and no parity check is set for UART transfe.
N     * |[15:8]  |DLY       |TX Delay Time Value
N     * |        |          |This field is used to program the transfer delay time between the last stop bit and next start bit.
N     * |        |          |The Unit is bit tim.
N    */
N    __IO uint32_t TOUT;
X    volatile uint32_t TOUT;
N
N    /**
N     * BAUD
N     * ===================================================================================================
N     * Offset: 0x24  UART Baud Rate Divisor Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |BRD       |Baud Rate Divider
N     * |        |          |The field indicates the baud rate divider.
N     * |[27:24] |EDIVM1    |Divider X
N     * |        |          |The baud rate divider M = X+1.
N     * |[28]    |BAUDM0    |Divider X Equal 1
N     * |        |          |0 = Divider M = X (the equation of M = X+1, but EDIVM1[27:24] must >= 8).
N     * |        |          |1 = Divider M = 1 (the equation of M = 1, but BRD [15:0] must >= 8).
N     * |        |          |Note: Refer to section "UART Controller Baud Rate Generator" for more information.
N     * |[29]    |BAUDM1    |Divider X Enable Bit
N     * |        |          |The BRD = Baud Rate Divider, and the baud rate equation is:
N     * |        |          |Baud Rate = Clock / [M * (BRD + 2)], The default value of M is 16.
N     * |        |          |0 = Divider X Disabled (the equation of M = 16).
N     * |        |          |1 = Divider X Enabled (the equation of M = X+1, but EDIVM1 [27:24] must >= 8).
N     * |        |          |Note: In IrDA mode, this bit must be disabled.
N    */
N    __IO uint32_t BAUD;
X    volatile uint32_t BAUD;
N
N    /**
N     * IRDA
N     * ===================================================================================================
N     * Offset: 0x28  UART IrDA Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |TXEN      |IrDA Receiver/Transmitter Selection Enable Bit
N     * |        |          |0 = IrDA Transmitter Disabled and Receiver Enabled. (Default)
N     * |        |          |1 = IrDA Transmitter Enabled and Receiver Disabled.
N     * |[5]     |TXINV     |IrDA Inverse Transmitting Output Signal
N     * |        |          |0 = None inverse transmitting signal. (Default)
N     * |        |          |1 = Inverse transmitting output signal.
N     * |[6]     |RXINV     |IrDA Inverse Receive Input Signal
N     * |        |          |0 = None inverse receiving input signal.
N     * |        |          |1 = Inverse receiving input signal. (Default)
N    */
N    __IO uint32_t IRDA;
X    volatile uint32_t IRDA;
N
N    /**
N     * ALTCTL
N     * ===================================================================================================
N     * Offset: 0x2C  UART Alternate Control/Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8]     |RS485_NMM |RS-485 Normal Multi-drop Operation Mode (NMM) Control
N     * |        |          |0 = RS-485 Normal Multi-drop Operation Mode (NMM) Disabled.
N     * |        |          |1 = RS-485 Normal Multi-drop Operation Mode (NMM) Enabled.
N     * |        |          |Note: It cannot be active with RS485_AAD operation mode.
N     * |[9]     |RS485_AAD |RS-485 Auto Address Detection Operation Mode (AAD)
N     * |        |          |0 = RS-485 Auto Address Detection Operation Mode (AAD) Disabled.
N     * |        |          |1 = RS-485 Auto Address Detection Operation Mode (AAD) Enabled.
N     * |        |          |Note: It cannot be active with RS485_NMM operation mode.
N     * |[10]    |RS485_AUD |RS-485 Auto Direction Mode (AUD) Control
N     * |        |          |0 = RS-485 Auto Direction Function Mode (AUD) Disabled.
N     * |        |          |1 = RS-485 Auto Direction Function Mode (AUD) Enabled.
N     * |        |          |Note: It cannot be active with RS485_NMM operation mode.
N     * |[15]    |ADDRDEN   |RS-485 Address Detection Enable Bit
N     * |        |          |This bit is used to enable RS-485 Address Detection mode.
N     * |        |          |0 = RS-485 address detection mode Disabled.
N     * |        |          |1 = RS-485 address detection mode Enabled.
N     * |        |          |Note: This field is used for RS-485 any operation mode.
N     * |[31:24] |ADDRMV    |Address Match Values
N     * |        |          |This field contains the RS-485 address match values.
N     * |        |          |Note: This field is used for RS-485 auto address detection mode.
N    */
N    __IO uint32_t ALTCTL;
X    volatile uint32_t ALTCTL;
N
N    /**
N     * FUNSEL
N     * ===================================================================================================
N     * Offset: 0x30  UART Function Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |FUN_SEL   |Function Selection
N     * |        |          |00 = UART function mode.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = IrDA function mode. (Only Available in UART0)
N     * |        |          |11 = RS-485 function mode. (Only Available in UART0)
N    */
N    __IO uint32_t FUNSEL;
X    volatile uint32_t FUNSEL;
N
N} UART_T;
N
N/**
N    @addtogroup UART_CONST UART Bit Field Definition
N    Constant Definitions for UART Controller
N@{ */
N
N#define UART_DAT_DAT_Pos                 (0)                                               /*!< UART_T::DAT: DAT Position                 */
N#define UART_DAT_DAT_Msk                 (0xfful << UART_DAT_DAT_Pos)                      /*!< UART_T::DAT: DAT Mask                     */
N
N#define UART_INTEN_RDAIEN_Pos            (0)                                               /*!< UART_T::INTEN: RDAIEN Position            */
N#define UART_INTEN_RDAIEN_Msk            (0x1ul << UART_INTEN_RDAIEN_Pos)                  /*!< UART_T::INTEN: RDAIEN Mask                */
N
N#define UART_INTEN_THREIEN_Pos           (1)                                               /*!< UART_T::INTEN: THREIEN Position           */
N#define UART_INTEN_THREIEN_Msk           (0x1ul << UART_INTEN_THREIEN_Pos)                 /*!< UART_T::INTEN: THREIEN Mask               */
N
N#define UART_INTEN_RLSIEN_Pos            (2)                                               /*!< UART_T::INTEN: RLSIEN Position            */
N#define UART_INTEN_RLSIEN_Msk            (0x1ul << UART_INTEN_RLSIEN_Pos)                  /*!< UART_T::INTEN: RLSIEN Mask                */
N
N#define UART_INTEN_MODEMIEN_Pos          (3)                                               /*!< UART_T::INTEN: MODEMIEN Position          */
N#define UART_INTEN_MODEMIEN_Msk          (0x1ul << UART_INTEN_MODEMIEN_Pos)                /*!< UART_T::INTEN: MODEMIEN Mask              */
N
N#define UART_INTEN_RXTOIEN_Pos           (4)                                               /*!< UART_T::INTEN: RXTOIEN Position           */
N#define UART_INTEN_RXTOIEN_Msk           (0x1ul << UART_INTEN_RXTOIEN_Pos)                 /*!< UART_T::INTEN: RXTOIEN Mask               */
N
N#define UART_INTEN_BUFERRIEN_Pos         (5)                                               /*!< UART_T::INTEN: BUFERRIEN Position         */
N#define UART_INTEN_BUFERRIEN_Msk         (0x1ul << UART_INTEN_BUFERRIEN_Pos)               /*!< UART_T::INTEN: BUFERRIEN Mask             */
N
N#define UART_INTEN_WKCTSIEN_Pos          (9)                                               /*!< UART_T::INTEN: WKCTSIEN Position          */
N#define UART_INTEN_WKCTSIEN_Msk          (0x1ul << UART_INTEN_WKCTSIEN_Pos)                /*!< UART_T::INTEN: WKCTSIEN Mask              */
N
N#define UART_INTEN_TOCNTEN_Pos           (11)                                              /*!< UART_T::INTEN: TOCNTEN Position           */
N#define UART_INTEN_TOCNTEN_Msk           (0x1ul << UART_INTEN_TOCNTEN_Pos)                 /*!< UART_T::INTEN: TOCNTEN Mask               */
N
N#define UART_INTEN_ATORTSEN_Pos          (12)                                              /*!< UART_T::INTEN: ATORTSEN Position          */
N#define UART_INTEN_ATORTSEN_Msk          (0x1ul << UART_INTEN_ATORTSEN_Pos)                /*!< UART_T::INTEN: ATORTSEN Mask              */
N
N#define UART_INTEN_ATOCTSEN_Pos          (13)                                              /*!< UART_T::INTEN: ATOCTSEN Position          */
N#define UART_INTEN_ATOCTSEN_Msk          (0x1ul << UART_INTEN_ATOCTSEN_Pos)                /*!< UART_T::INTEN: ATOCTSEN Mask              */
N
N#define UART_FIFO_RXRST_Pos              (1)                                               /*!< UART_T::FIFO: RXRST Position              */
N#define UART_FIFO_RXRST_Msk              (0x1ul << UART_FIFO_RXRST_Pos)                    /*!< UART_T::FIFO: RXRST Mask                  */
N
N#define UART_FIFO_TXRST_Pos              (2)                                               /*!< UART_T::FIFO: TXRST Position              */
N#define UART_FIFO_TXRST_Msk              (0x1ul << UART_FIFO_TXRST_Pos)                    /*!< UART_T::FIFO: TXRST Mask                  */
N
N#define UART_FIFO_RFITL_Pos              (4)                                               /*!< UART_T::FIFO: RFITL Position              */
N#define UART_FIFO_RFITL_Msk              (0xful << UART_FIFO_RFITL_Pos)                    /*!< UART_T::FIFO: RFITL Mask                  */
N
N#define UART_FIFO_RXOFF_Pos              (8)                                               /*!< UART_T::FIFO: RXOFF Position              */
N#define UART_FIFO_RXOFF_Msk              (0x1ul << UART_FIFO_RXOFF_Pos)                    /*!< UART_T::FIFO: RXOFF Mask                  */
N
N#define UART_FIFO_RTSTRGLV_Pos           (16)                                              /*!< UART_T::FIFO: RTSTRGLV Position           */
N#define UART_FIFO_RTSTRGLV_Msk           (0xful << UART_FIFO_RTSTRGLV_Pos)                 /*!< UART_T::FIFO: RTSTRGLV Mask               */
N
N#define UART_LINE_WLS_Pos                (0)                                               /*!< UART_T::LINE: WLS Position                */
N#define UART_LINE_WLS_Msk                (0x3ul << UART_LINE_WLS_Pos)                      /*!< UART_T::LINE: WLS Mask                    */
N
N#define UART_LINE_NSB_Pos                (2)                                               /*!< UART_T::LINE: NSB Position                */
N#define UART_LINE_NSB_Msk                (0x1ul << UART_LINE_NSB_Pos)                      /*!< UART_T::LINE: NSB Mask                    */
N
N#define UART_LINE_PBE_Pos                (3)                                               /*!< UART_T::LINE: PBE Position                */
N#define UART_LINE_PBE_Msk                (0x1ul << UART_LINE_PBE_Pos)                      /*!< UART_T::LINE: PBE Mask                    */
N
N#define UART_LINE_EPE_Pos                (4)                                               /*!< UART_T::LINE: EPE Position                */
N#define UART_LINE_EPE_Msk                (0x1ul << UART_LINE_EPE_Pos)                      /*!< UART_T::LINE: EPE Mask                    */
N
N#define UART_LINE_SPE_Pos                (5)                                               /*!< UART_T::LINE: SPE Position                */
N#define UART_LINE_SPE_Msk                (0x1ul << UART_LINE_SPE_Pos)                      /*!< UART_T::LINE: SPE Mask                    */
N
N#define UART_LINE_BCB_Pos                (6)                                               /*!< UART_T::LINE: BCB Position                */
N#define UART_LINE_BCB_Msk                (0x1ul << UART_LINE_BCB_Pos)                      /*!< UART_T::LINE: BCB Mask                    */
N
N#define UART_MODEM_RTS_Pos               (1)                                               /*!< UART_T::MODEM: RTS Position               */
N#define UART_MODEM_RTS_Msk               (0x1ul << UART_MODEM_RTS_Pos)                     /*!< UART_T::MODEM: RTS Mask                   */
N
N#define UART_MODEM_RTSACTLV_Pos          (9)                                               /*!< UART_T::MODEM: RTSACTLV Position          */
N#define UART_MODEM_RTSACTLV_Msk          (0x1ul << UART_MODEM_RTSACTLV_Pos)                /*!< UART_T::MODEM: RTSACTLV Mask              */
N
N#define UART_MODEM_RTSSTS_Pos            (13)                                              /*!< UART_T::MODEM: RTSSTS Position            */
N#define UART_MODEM_RTSSTS_Msk            (0x1ul << UART_MODEM_RTSSTS_Pos)                  /*!< UART_T::MODEM: RTSSTS Mask                */
N
N#define UART_MODEMSTS_CTSDETF_Pos        (0)                                               /*!< UART_T::MODEMSTS: CTSDETF Position        */
N#define UART_MODEMSTS_CTSDETF_Msk        (0x1ul << UART_MODEMSTS_CTSDETF_Pos)              /*!< UART_T::MODEMSTS: CTSDETF Mask            */
N
N#define UART_MODEMSTS_CTSSTS_Pos         (4)                                               /*!< UART_T::MODEMSTS: CTSSTS Position         */
N#define UART_MODEMSTS_CTSSTS_Msk         (0x1ul << UART_MODEMSTS_CTSSTS_Pos)               /*!< UART_T::MODEMSTS: CTSSTS Mask             */
N
N#define UART_MODEMSTS_CTSACTLV_Pos       (8)                                               /*!< UART_T::MODEMSTS: CTSACTLV Position       */
N#define UART_MODEMSTS_CTSACTLV_Msk       (0x1ul << UART_MODEMSTS_CTSACTLV_Pos)             /*!< UART_T::MODEMSTS: CTSACTLV Mask           */
N
N#define UART_FIFOSTS_RXOVIF_Pos          (0)                                               /*!< UART_T::FIFOSTS: RXOVIF Position          */
N#define UART_FIFOSTS_RXOVIF_Msk          (0x1ul << UART_FIFOSTS_RXOVIF_Pos)                /*!< UART_T::FIFOSTS: RXOVIF Mask              */
N
N#define UART_FIFOSTS_ADDRDETF_Pos        (3)                                               /*!< UART_T::FIFOSTS: ADDRDETF Position        */
N#define UART_FIFOSTS_ADDRDETF_Msk        (0x1ul << UART_FIFOSTS_ADDRDETF_Pos)              /*!< UART_T::FIFOSTS: ADDRDETF Mask            */
N
N#define UART_FIFOSTS_PEF_Pos             (4)                                               /*!< UART_T::FIFOSTS: PEF Position             */
N#define UART_FIFOSTS_PEF_Msk             (0x1ul << UART_FIFOSTS_PEF_Pos)                   /*!< UART_T::FIFOSTS: PEF Mask                 */
N
N#define UART_FIFOSTS_FEF_Pos             (5)                                               /*!< UART_T::FIFOSTS: FEF Position             */
N#define UART_FIFOSTS_FEF_Msk             (0x1ul << UART_FIFOSTS_FEF_Pos)                   /*!< UART_T::FIFOSTS: FEF Mask                 */
N
N#define UART_FIFOSTS_BIF_Pos             (6)                                               /*!< UART_T::FIFOSTS: BIF Position             */
N#define UART_FIFOSTS_BIF_Msk             (0x1ul << UART_FIFOSTS_BIF_Pos)                   /*!< UART_T::FIFOSTS: BIF Mask                 */
N
N#define UART_FIFOSTS_RXPTR_Pos           (8)                                               /*!< UART_T::FIFOSTS: RXPTR Position           */
N#define UART_FIFOSTS_RXPTR_Msk           (0x3ful << UART_FIFOSTS_RXPTR_Pos)                /*!< UART_T::FIFOSTS: RXPTR Mask               */
N
N#define UART_FIFOSTS_RXEMPTY_Pos         (14)                                              /*!< UART_T::FIFOSTS: RXEMPTY Position         */
N#define UART_FIFOSTS_RXEMPTY_Msk         (0x1ul << UART_FIFOSTS_RXEMPTY_Pos)               /*!< UART_T::FIFOSTS: RXEMPTY Mask             */
N
N#define UART_FIFOSTS_RXFULL_Pos          (15)                                              /*!< UART_T::FIFOSTS: RXFULL Position          */
N#define UART_FIFOSTS_RXFULL_Msk          (0x1ul << UART_FIFOSTS_RXFULL_Pos)                /*!< UART_T::FIFOSTS: RXFULL Mask              */
N
N#define UART_FIFOSTS_TXPTR_Pos           (16)                                              /*!< UART_T::FIFOSTS: TXPTR Position           */
N#define UART_FIFOSTS_TXPTR_Msk           (0x3ful << UART_FIFOSTS_TXPTR_Pos)                /*!< UART_T::FIFOSTS: TXPTR Mask               */
N
N#define UART_FIFOSTS_TXEMPTY_Pos         (22)                                              /*!< UART_T::FIFOSTS: TXEMPTY Position         */
N#define UART_FIFOSTS_TXEMPTY_Msk         (0x1ul << UART_FIFOSTS_TXEMPTY_Pos)               /*!< UART_T::FIFOSTS: TXEMPTY Mask             */
N
N#define UART_FIFOSTS_TXFULL_Pos          (23)                                              /*!< UART_T::FIFOSTS: TXFULL Position          */
N#define UART_FIFOSTS_TXFULL_Msk          (0x1ul << UART_FIFOSTS_TXFULL_Pos)                /*!< UART_T::FIFOSTS: TXFULL Mask              */
N
N#define UART_FIFOSTS_TXOVIF_Pos          (24)                                              /*!< UART_T::FIFOSTS: TXOVIF Position          */
N#define UART_FIFOSTS_TXOVIF_Msk          (0x1ul << UART_FIFOSTS_TXOVIF_Pos)                /*!< UART_T::FIFOSTS: TXOVIF Mask              */
N
N#define UART_FIFOSTS_TXEMPTYF_Pos        (28)                                              /*!< UART_T::FIFOSTS: TXEMPTYF Position        */
N#define UART_FIFOSTS_TXEMPTYF_Msk        (0x1ul << UART_FIFOSTS_TXEMPTYF_Pos)              /*!< UART_T::FIFOSTS: TXEMPTYF Mask            */
N
N#define UART_INTSTS_RDAIF_Pos            (0)                                               /*!< UART_T::INTSTS: RDAIF Position            */
N#define UART_INTSTS_RDAIF_Msk            (0x1ul << UART_INTSTS_RDAIF_Pos)                  /*!< UART_T::INTSTS: RDAIF Mask                */
N
N#define UART_INTSTS_THREIF_Pos           (1)                                               /*!< UART_T::INTSTS: THREIF Position           */
N#define UART_INTSTS_THREIF_Msk           (0x1ul << UART_INTSTS_THREIF_Pos)                 /*!< UART_T::INTSTS: THREIF Mask               */
N
N#define UART_INTSTS_RLSIF_Pos            (2)                                               /*!< UART_T::INTSTS: RLSIF Position            */
N#define UART_INTSTS_RLSIF_Msk            (0x1ul << UART_INTSTS_RLSIF_Pos)                  /*!< UART_T::INTSTS: RLSIF Mask                */
N
N#define UART_INTSTS_MODEMIF_Pos          (3)                                               /*!< UART_T::INTSTS: MODEMIF Position          */
N#define UART_INTSTS_MODEMIF_Msk          (0x1ul << UART_INTSTS_MODEMIF_Pos)                /*!< UART_T::INTSTS: MODEMIF Mask              */
N
N#define UART_INTSTS_RXTOIF_Pos           (4)                                               /*!< UART_T::INTSTS: RXTOIF Position           */
N#define UART_INTSTS_RXTOIF_Msk           (0x1ul << UART_INTSTS_RXTOIF_Pos)                 /*!< UART_T::INTSTS: RXTOIF Mask               */
N
N#define UART_INTSTS_BUFERRIF_Pos         (5)                                               /*!< UART_T::INTSTS: BUFERRIF Position         */
N#define UART_INTSTS_BUFERRIF_Msk         (0x1ul << UART_INTSTS_BUFERRIF_Pos)               /*!< UART_T::INTSTS: BUFERRIF Mask             */
N
N#define UART_INTSTS_RDAINT_Pos           (8)                                               /*!< UART_T::INTSTS: RDAINT Position           */
N#define UART_INTSTS_RDAINT_Msk           (0x1ul << UART_INTSTS_RDAINT_Pos)                 /*!< UART_T::INTSTS: RDAINT Mask               */
N
N#define UART_INTSTS_THREINT_Pos          (9)                                               /*!< UART_T::INTSTS: THREINT Position          */
N#define UART_INTSTS_THREINT_Msk          (0x1ul << UART_INTSTS_THREINT_Pos)                /*!< UART_T::INTSTS: THREINT Mask              */
N
N#define UART_INTSTS_RLSINT_Pos           (10)                                              /*!< UART_T::INTSTS: RLSINT Position           */
N#define UART_INTSTS_RLSINT_Msk           (0x1ul << UART_INTSTS_RLSINT_Pos)                 /*!< UART_T::INTSTS: RLSINT Mask               */
N
N#define UART_INTSTS_MODEMINT_Pos         (11)                                              /*!< UART_T::INTSTS: MODEMINT Position         */
N#define UART_INTSTS_MODEMINT_Msk         (0x1ul << UART_INTSTS_MODEMINT_Pos)               /*!< UART_T::INTSTS: MODEMINT Mask             */
N
N#define UART_INTSTS_RXTOINT_Pos          (12)                                              /*!< UART_T::INTSTS: RXTOINT Position          */
N#define UART_INTSTS_RXTOINT_Msk          (0x1ul << UART_INTSTS_RXTOINT_Pos)                /*!< UART_T::INTSTS: RXTOINT Mask              */
N
N#define UART_INTSTS_BUFERRINT_Pos        (13)                                              /*!< UART_T::INTSTS: BUFERRINT Position        */
N#define UART_INTSTS_BUFERRINT_Msk        (0x1ul << UART_INTSTS_BUFERRINT_Pos)              /*!< UART_T::INTSTS: BUFERRINT Mask            */
N
N#define UART_INTSTS_CTSWKIF_Pos          (16)                                              /*!< UART_T::INTSTS: CTSWKIF Position          */
N#define UART_INTSTS_CTSWKIF_Msk          (0x1ul << UART_INTSTS_CTSWKIF_Pos)                /*!< UART_T::INTSTS: CTSWKIF Mask              */
N
N#define UART_TOUT_TOIC_Pos               (0)                                               /*!< UART_T::TOUT: TOIC Position               */
N#define UART_TOUT_TOIC_Msk               (0xfful << UART_TOUT_TOIC_Pos)                    /*!< UART_T::TOUT: TOIC Mask                   */
N
N#define UART_TOUT_DLY_Pos                (8)                                               /*!< UART_T::TOUT: DLY Position                */
N#define UART_TOUT_DLY_Msk                (0xfful << UART_TOUT_DLY_Pos)                     /*!< UART_T::TOUT: DLY Mask                    */
N
N#define UART_BAUD_BRD_Pos                (0)                                               /*!< UART_T::BAUD: BRD Position                */
N#define UART_BAUD_BRD_Msk                (0xfffful << UART_BAUD_BRD_Pos)                   /*!< UART_T::BAUD: BRD Mask                    */
N
N#define UART_BAUD_EDIVM1_Pos             (24)                                              /*!< UART_T::BAUD: EDIVM1 Position             */
N#define UART_BAUD_EDIVM1_Msk             (0xful << UART_BAUD_EDIVM1_Pos)                   /*!< UART_T::BAUD: EDIVM1 Mask                 */
N
N#define UART_BAUD_BAUDM0_Pos             (28)                                              /*!< UART_T::BAUD: BAUDM0 Position             */
N#define UART_BAUD_BAUDM0_Msk             (0x1ul << UART_BAUD_BAUDM0_Pos)                   /*!< UART_T::BAUD: BAUDM0 Mask                 */
N
N#define UART_BAUD_BAUDM1_Pos             (29)                                              /*!< UART_T::BAUD: BAUDM1 Position             */
N#define UART_BAUD_BAUDM1_Msk             (0x1ul << UART_BAUD_BAUDM1_Pos)                   /*!< UART_T::BAUD: BAUDM1 Mask                 */
N
N#define UART_IRDA_TXEN_Pos               (1)                                               /*!< UART_T::IRDA: TXEN Position               */
N#define UART_IRDA_TXEN_Msk               (0x1ul << UART_IRDA_TXEN_Pos)                     /*!< UART_T::IRDA: TXEN Mask                   */
N
N#define UART_IRDA_TXINV_Pos              (5)                                               /*!< UART_T::IRDA: TXINV Position              */
N#define UART_IRDA_TXINV_Msk              (0x1ul << UART_IRDA_TXINV_Pos)                    /*!< UART_T::IRDA: TXINV Mask                  */
N
N#define UART_IRDA_RXINV_Pos              (6)                                               /*!< UART_T::IRDA: RXINV Position              */
N#define UART_IRDA_RXINV_Msk              (0x1ul << UART_IRDA_RXINV_Pos)                    /*!< UART_T::IRDA: RXINV Mask                  */
N
N#define UART_ALTCTL_RS485_NMM_Pos        (8)                                               /*!< UART_T::ALTCTL: RS485_NMM Position        */
N#define UART_ALTCTL_RS485_NMM_Msk        (0x1ul << UART_ALTCTL_RS485_NMM_Pos)              /*!< UART_T::ALTCTL: RS485_NMM Mask            */
N
N#define UART_ALTCTL_RS485_AAD_Pos        (9)                                               /*!< UART_T::ALTCTL: RS485_AAD Position        */
N#define UART_ALTCTL_RS485_AAD_Msk        (0x1ul << UART_ALTCTL_RS485_AAD_Pos)              /*!< UART_T::ALTCTL: RS485_AAD Mask            */
N
N#define UART_ALTCTL_RS485_AUD_Pos        (10)                                              /*!< UART_T::ALTCTL: RS485_AUD Position        */
N#define UART_ALTCTL_RS485_AUD_Msk        (0x1ul << UART_ALTCTL_RS485_AUD_Pos)              /*!< UART_T::ALTCTL: RS485_AUD Mask            */
N
N#define UART_ALTCTL_ADDRDEN_Pos          (15)                                              /*!< UART_T::ALTCTL: ADDRDEN Position          */
N#define UART_ALTCTL_ADDRDEN_Msk          (0x1ul << UART_ALTCTL_ADDRDEN_Pos)                /*!< UART_T::ALTCTL: ADDRDEN Mask              */
N
N#define UART_ALTCTL_ADDRMV_Pos           (24)                                              /*!< UART_T::ALTCTL: ADDRMV Position           */
N#define UART_ALTCTL_ADDRMV_Msk           (0xfful << UART_ALTCTL_ADDRMV_Pos)                /*!< UART_T::ALTCTL: ADDRMV Mask               */
N
N#define UART_FUNSEL_FUN_SEL_Pos          (0)                                               /*!< UART_T::FUNSEL: FUN_SEL Position          */
N#define UART_FUNSEL_FUN_SEL_Msk          (0x3ul << UART_FUNSEL_FUN_SEL_Pos)                /*!< UART_T::FUNSEL: FUN_SEL Mask              */
N
N/**@}*/ /* UART_CONST */
N/**@}*/ /* end of UART register group */
N
N
N
N/*---------------------- Watch Dog Timer Controller -------------------------*/
N/**
N    @addtogroup WDT Watch Dog Timer Controller(WDT)
N    Memory Mapped Structure for WDT Controller
N@{ */
N
Ntypedef struct {
N
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x00  WDT Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RSTCNT    |Reset WDT Up Counter (Write Protect)
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the internal 18-bit WDT up counter value.
N     * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |        |          |Note2: This bit will be automatically cleared by hardware.
N     * |[1]     |RSTEN     |WDT Time-out Reset Enable Bit (Write Protect)
N     * |        |          |Setting this bit will enable the WDT time-out reset function If the WDT up counter value has not been cleared after the specific WDT reset delay period expires.
N     * |        |          |0 = WDT time-out reset function Disabled.
N     * |        |          |1 = WDT time-out reset function Enabled.
N     * |        |          |Note: This bit is write-protected. Refer to the SYS_REGLCTL register.
N     * |[2]     |RSTF      |WDT Time-out Reset Flag
N     * |        |          |This bit indicates the system has been reset by WDT time-out reset or not.
N     * |        |          |0 = WDT time-out reset did not occur.
N     * |        |          |1 = WDT time-out reset occurred.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[3]     |IF        |WDT Time-out Interrupt Flag
N     * |        |          |This bit will be set to 1 while WDT up counter value reaches the selected WDT time-out interval
N     * |        |          |0 = WDT time-out interrupt did not occur.
N     * |        |          |1 = WDT time-out interrupt occurred.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[4]     |WKEN      |WDT Time-out Wake-up Function Control (Write Protect)
N     * |        |          |If this bit is set to 1, while WDT time-out interrupt flag IF (WDT_CTL[3]) is generated to 1 and interrupt enable bit INTEN (WDT_CTL[6]) is enabled, the WDT time-out interrupt signal will generate a wake-up trigger event to chip.
N     * |        |          |0 = Wake-up trigger event Disabled if WDT time-out interrupt signal generated.
N     * |        |          |1 = Wake-up trigger event Enabled if WDT time-out interrupt signal generated.
N     * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |        |          |Note2: Chip can be woken-up by WDT time-out interrupt signal generated only if WDT clock source is selected to LIRC or LXT.
N     * |[5]     |WKF       |WDT Time-out Wake-up Flag (Write Protect)
N     * |        |          |This bit indicates the interrupt wake-up flag status of WDT
N     * |        |          |0 = WDT does not cause chip wake-up.
N     * |        |          |1 = Chip wake-up from Idle or Power-down mode if WDT time-out interrupt signal generated.
N     * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |        |          |Note2: This bit is cleared by writing 1 to it.
N     * |[6]     |INTEN     |WDT Time-out Interrupt Enable Bit (Write Protect)
N     * |        |          |If this bit is enabled, the WDT time-out interrupt signal is generated and inform to CPU.
N     * |        |          |0 = WDT time-out interrupt Disabled.
N     * |        |          |1 = WDT time-out interrupt Enabled.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[7]     |WDTEN     |WDT Enable Bit (Write Protect)
N     * |        |          |0 = WDT Disabled (This action will reset the internal up counter value).
N     * |        |          |1 = WDT Enabled.
N     * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |        |          |Note2: If CWDTEN[2:0] (combined by Config0[31] and Config0[4:3]) bits is not configure to 111, this bit is forced as 1 and user cannot change this bit to 0.
N     * |[10:8]  |TOUTSEL   |WDT Time-out Interval Selection (Write Protect)
N     * |        |          |These three bits select the time-out interval period for the WDT.
N     * |        |          |000 = 2^4 * WDT_CLK.
N     * |        |          |001 = 2^6 * WDT_CLK.
N     * |        |          |010 = 2^8 * WDT_CLK.
N     * |        |          |011 = 2^10 * WDT_CLK.
N     * |        |          |100 = 2^12 * WDT_CLK.
N     * |        |          |101 = 2^14 * WDT_CLK.
N     * |        |          |110 = 2^16 * WDT_CLK.
N     * |        |          |111 = 2^18 * WDT_CLK.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Bit (Write Protect)
N     * |        |          |0 = ICE debug mode acknowledgement affects WDT counting.
N     * |        |          |WDT up counter will be held while CPU is held by ICE.
N     * |        |          |1 = ICE debug mode acknowledgement Disabled.
N     * |        |          |WDT up counter will keep going no matter CPU is held by ICE or not.
N     * |        |          |Note: This bit is write protected. Refer to the SYS_REGLCTL register.
N    */
N    __IO uint32_t CTL;
X    volatile uint32_t CTL;
N
N    /**
N     * ALTCTL
N     * ===================================================================================================
N     * Offset: 0x04  WDT Alternative Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |RSTDSEL   |WDT Reset Delay Selection (Write Protect)
N     * |        |          |When WDT time-out happened, user has a time named WDT Reset Delay Period to clear WDT counter by setting RSTCNT (WDT_CTL[0]) to prevent WDT time-out reset happened.
N     * |        |          |User can select a suitable setting of RSTDSEL for different WDT Reset Delay Period.
N     * |        |          |00 = WDT Reset Delay Period is 1026 * WDT_CLK.
N     * |        |          |01 = WDT Reset Delay Period is 130 * WDT_CLK.
N     * |        |          |10 = WDT Reset Delay Period is 18 * WDT_CLK.
N     * |        |          |11 = WDT Reset Delay Period is 3 * WDT_CLK.
N     * |        |          |Note1: This bit is write protected. Refer to the SYS_REGLCTL register.
N     * |        |          |Note2: This register will be reset to 0 if WDT time-out reset happened.
N    */
N    __IO uint32_t ALTCTL;
X    volatile uint32_t ALTCTL;
N
N} WDT_T;
N
N/**
N    @addtogroup WDT_CONST WDT Bit Field Definition
N    Constant Definitions for WDT Controller
N@{ */
N
N#define WDT_CTL_RSTCNT_Pos               (0)                                               /*!< WDT_T::CTL: RSTCNT Position               */
N#define WDT_CTL_RSTCNT_Msk               (0x1ul << WDT_CTL_RSTCNT_Pos)                     /*!< WDT_T::CTL: RSTCNT Mask                   */
N
N#define WDT_CTL_RSTEN_Pos                (1)                                               /*!< WDT_T::CTL: RSTEN Position                */
N#define WDT_CTL_RSTEN_Msk                (0x1ul << WDT_CTL_RSTEN_Pos)                      /*!< WDT_T::CTL: RSTEN Mask                    */
N
N#define WDT_CTL_RSTF_Pos                 (2)                                               /*!< WDT_T::CTL: RSTF Position                 */
N#define WDT_CTL_RSTF_Msk                 (0x1ul << WDT_CTL_RSTF_Pos)                       /*!< WDT_T::CTL: RSTF Mask                     */
N
N#define WDT_CTL_IF_Pos                   (3)                                               /*!< WDT_T::CTL: IF Position                   */
N#define WDT_CTL_IF_Msk                   (0x1ul << WDT_CTL_IF_Pos)                         /*!< WDT_T::CTL: IF Mask                       */
N
N#define WDT_CTL_WKEN_Pos                 (4)                                               /*!< WDT_T::CTL: WKEN Position                 */
N#define WDT_CTL_WKEN_Msk                 (0x1ul << WDT_CTL_WKEN_Pos)                       /*!< WDT_T::CTL: WKEN Mask                     */
N
N#define WDT_CTL_WKF_Pos                  (5)                                               /*!< WDT_T::CTL: WKF Position                  */
N#define WDT_CTL_WKF_Msk                  (0x1ul << WDT_CTL_WKF_Pos)                        /*!< WDT_T::CTL: WKF Mask                      */
N
N#define WDT_CTL_INTEN_Pos                (6)                                               /*!< WDT_T::CTL: INTEN Position                */
N#define WDT_CTL_INTEN_Msk                (0x1ul << WDT_CTL_INTEN_Pos)                      /*!< WDT_T::CTL: INTEN Mask                    */
N
N#define WDT_CTL_WDTEN_Pos                (7)                                               /*!< WDT_T::CTL: WDTEN Position                */
N#define WDT_CTL_WDTEN_Msk                (0x1ul << WDT_CTL_WDTEN_Pos)                      /*!< WDT_T::CTL: WDTEN Mask                    */
N
N#define WDT_CTL_TOUTSEL_Pos              (8)                                               /*!< WDT_T::CTL: TOUTSEL Position              */
N#define WDT_CTL_TOUTSEL_Msk              (0x7ul << WDT_CTL_TOUTSEL_Pos)                    /*!< WDT_T::CTL: TOUTSEL Mask                  */
N
N#define WDT_CTL_ICEDEBUG_Pos             (31)                                              /*!< WDT_T::CTL: ICEDEBUG Position             */
N#define WDT_CTL_ICEDEBUG_Msk             (0x1ul << WDT_CTL_ICEDEBUG_Pos)                   /*!< WDT_T::CTL: ICEDEBUG Mask                 */
N
N#define WDT_ALTCTL_RSTDSEL_Pos           (0)                                               /*!< WDT_T::ALTCTL: RSTDSEL Position           */
N#define WDT_ALTCTL_RSTDSEL_Msk           (0x3ul << WDT_ALTCTL_RSTDSEL_Pos)                 /*!< WDT_T::ALTCTL: RSTDSEL Mask               */
N
N/**@}*/ /* WDT_CONST */
N/**@}*/ /* end of WDT register group */
N
N
N/*---------------------- Window Watchdog Timer -------------------------*/
N/**
N    @addtogroup WWDT Window Watchdog Timer(WWDT)
N    Memory Mapped Structure for WWDT Controller
N@{ */
N
Ntypedef struct {
N
N
N    /**
N     * RLDCNT
N     * ===================================================================================================
N     * Offset: 0x00  WWDT Reload Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |RLDCNT    |WWDT Reload Counter Register
N     * |        |          |Writing 0x00005AA5 to this register will reload the WWDT counter value to 0x3F.
N     * |        |          |Note: User can only write WWDT_RLDCNT register to reload WWDT counter value when current WWDT counter value between 0 and CMPDAT (WWDT_CTL[21:16]).
N     * |        |          |If user writes WWDT_RLDCNT when current WWDT counter value is larger than CMPDAT, WWDT reset signal will generate immediately.
N    */
N    __O  uint32_t RLDCNT;
X    volatile  uint32_t RLDCNT;
N
N    /**
N     * CTL
N     * ===================================================================================================
N     * Offset: 0x04  WWDT Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WWDTEN    |WWDT Enable Bit
N     * |        |          |Set this bit to enable WWDT counter counting.
N     * |        |          |0 = WWDT counter is stopped.
N     * |        |          |1 = WWDT counter is starting counting.
N     * |[1]     |INTEN     |WWDT Interrupt Enable Bit
N     * |        |          |If this bit is enabled, the WWDT counter compare match interrupt signal is generated and inform to CPU.
N     * |        |          |0 = WWDT counter compare match interrupt Disabled.
N     * |        |          |1 = WWDT counter compare match interrupt Enabled.
N     * |[11:8]  |PSCSEL    |WWDT Counter Prescale Period Select Bits
N     * |        |          |0000 = Pre-scale is 1; Max time-out period is 1 * 64 * WWDT_CLK.
N     * |        |          |0001 = Pre-scale is 2; Max time-out period is 2 * 64 * WWDT_CLK.
N     * |        |          |0010 = Pre-scale is 4; Max time-out period is 4 * 64 * WWDT_CLK.
N     * |        |          |0011 = Pre-scale is 8; Max time-out period is 8 * 64 * WWDT_CLK.
N     * |        |          |0100 = Pre-scale is 16; Max time-out period is 16 * 64 * WWDT_CLK.
N     * |        |          |0101 = Pre-scale is 32; Max time-out period is 32 * 64 * WWDT_CLK.
N     * |        |          |0110 = Pre-scale is 64; Max time-out period is 64 * 64 * WWDT_CLK.
N     * |        |          |0111 = Pre-scale is 128; Max time-out period is 128 * 64 * WWDT_CLK.
N     * |        |          |1000 = Pre-scale is 192; Max time-out period is 192 * 64 * WWDT_CLK.
N     * |        |          |1001 = Pre-scale is 256; Max time-out period is 256 * 64 * WWDT_CLK.
N     * |        |          |1010 = Pre-scale is 384; Max time-out period is 384 * 64 * WWDT_CLK.
N     * |        |          |1011 = Pre-scale is 512; Max time-out period is 512 * 64 * WWDT_CLK.
N     * |        |          |1100 = Pre-scale is 768; Max time-out period is 768 * 64 * WWDT_CLK.
N     * |        |          |1101 = Pre-scale is 1024; Max time-out period is 1024 * 64 * WWDT_CLK.
N     * |        |          |1110 = Pre-scale is 1536; Max time-out period is 1536 * 64 * WWDT_CLK.
N     * |        |          |1111 = Pre-scale is 2048; Max time-out period is 2048 * 64 * WWDT_CLK.
N     * |[21:16] |CMPDAT    |WWDT Window Compare Bits
N     * |        |          |Set this register to adjust the valid reload window.
N     * |        |          |Note: User can only write WWDT_RLDCNT register to reload WWDT counter value when current WWDT counter value between 0 and CMPDAT.
N     * |        |          |If user writes WWDT_RLDCNT register when current WWDT counter value larger than CMPDAT, WWDT reset signal will generate immediately.
N     * |[31]    |ICEDEBUG  |ICE Debug Mode Acknowledge Disable Bit
N     * |        |          |0 = ICE debug mode acknowledgement effects WWDT counting.
N     * |        |          |WWDT down counter will be held while CPU is held by ICE.
N     * |        |          |1 = ICE debug mode acknowledgement Disabled.
N     * |        |          |WWDT down counter will keep going no matter CPU is held by ICE or not.
N    */
N    __IO uint32_t CTL;
X    volatile uint32_t CTL;
N
N    /**
N     * STATUS
N     * ===================================================================================================
N     * Offset: 0x08  WWDT Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WWDTIF    |WWDT Compare Match Interrupt Flag
N     * |        |          |This bit indicates the interrupt flag status of WWDT while WWDT counter value matches CMPDAT (WWDT_CTL[21:16]).
N     * |        |          |0 = No effect.
N     * |        |          |1 = WWDT counter value matches CMPDAT.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[1]     |WWDTRF    |WWDT Timer-out Reset Flag
N     * |        |          |This bit indicates the system has been reset by WWDT time-out reset or not.
N     * |        |          |0 = WWDT time-out reset did not occur.
N     * |        |          |1 = WWDT time-out reset occurred.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N    */
N    __IO uint32_t STATUS;
X    volatile uint32_t STATUS;
N
N    /**
N     * CNT
N     * ===================================================================================================
N     * Offset: 0x0C  WWDT Counter Value Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |CNTDAT    |WWDT Counter Value
N     * |        |          |CNTDAT will be updated continuously to monitor 6-bit WWDT down counter value.
N    */
N    __I  uint32_t CNT;
X    volatile const  uint32_t CNT;
N
N} WWDT_T;
N
N/**
N    @addtogroup WWDT_CONST WWDT Bit Field Definition
N    Constant Definitions for WWDT Controller
N@{ */
N
N#define WWDT_RLDCNT_RLDCNT_Pos           (0)                                               /*!< WWDT_T::RLDCNT: RLDCNT Position           */
N#define WWDT_RLDCNT_RLDCNT_Msk           (0xfffffffful << WWDT_RLDCNT_RLDCNT_Pos)          /*!< WWDT_T::RLDCNT: RLDCNT Mask               */
N
N#define WWDT_CTL_WWDTEN_Pos              (0)                                               /*!< WWDT_T::CTL: WWDTEN Position              */
N#define WWDT_CTL_WWDTEN_Msk              (0x1ul << WWDT_CTL_WWDTEN_Pos)                    /*!< WWDT_T::CTL: WWDTEN Mask                  */
N
N#define WWDT_CTL_INTEN_Pos               (1)                                               /*!< WWDT_T::CTL: INTEN Position               */
N#define WWDT_CTL_INTEN_Msk               (0x1ul << WWDT_CTL_INTEN_Pos)                     /*!< WWDT_T::CTL: INTEN Mask                   */
N
N#define WWDT_CTL_PSCSEL_Pos              (8)                                               /*!< WWDT_T::CTL: PSCSEL Position              */
N#define WWDT_CTL_PSCSEL_Msk              (0xful << WWDT_CTL_PSCSEL_Pos)                    /*!< WWDT_T::CTL: PSCSEL Mask                  */
N
N#define WWDT_CTL_CMPDAT_Pos              (16)                                              /*!< WWDT_T::CTL: CMPDAT Position              */
N#define WWDT_CTL_CMPDAT_Msk              (0x3ful << WWDT_CTL_CMPDAT_Pos)                   /*!< WWDT_T::CTL: CMPDAT Mask                  */
N
N#define WWDT_CTL_ICEDEBUG_Pos            (31)                                              /*!< WWDT_T::CTL: ICEDEBUG Position            */
N#define WWDT_CTL_ICEDEBUG_Msk            (0x1ul << WWDT_CTL_ICEDEBUG_Pos)                  /*!< WWDT_T::CTL: ICEDEBUG Mask                */
N
N#define WWDT_STATUS_WWDTIF_Pos           (0)                                               /*!< WWDT_T::STATUS: WWDTIF Position           */
N#define WWDT_STATUS_WWDTIF_Msk           (0x1ul << WWDT_STATUS_WWDTIF_Pos)                 /*!< WWDT_T::STATUS: WWDTIF Mask               */
N
N#define WWDT_STATUS_WWDTRF_Pos           (1)                                               /*!< WWDT_T::STATUS: WWDTRF Position           */
N#define WWDT_STATUS_WWDTRF_Msk           (0x1ul << WWDT_STATUS_WWDTRF_Pos)                 /*!< WWDT_T::STATUS: WWDTRF Mask               */
N
N#define WWDT_CNT_CNTDAT_Pos              (0)                                               /*!< WWDT_T::CNT: CNTDAT Position              */
N#define WWDT_CNT_CNTDAT_Msk              (0x3ful << WWDT_CNT_CNTDAT_Pos)                   /*!< WWDT_T::CNT: CNTDAT Mask                  */
N
N/**@}*/ /* WWDT_CONST */
N/**@}*/ /* end of WWDT register group */
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma no_anon_unions
N#endif
N
N/** @addtogroup Mini58_PERIPHERAL_MEM_MAP Mini58 Peripheral Memory Map
N  Memory Mapped Structure for Mini58 Series Peripheral
N  @{
N */
N/* Peripheral and SRAM base address */
N#define FLASH_BASE            ((uint32_t)0x00000000)    ///< Flash base address
N#define SRAM_BASE             ((uint32_t)0x20000000)    ///< SRAM base address
N#define APB1PERIPH_BASE       ((uint32_t)0x40000000)    ///< APB1 base address
N#define APB2PERIPH_BASE       ((uint32_t)0x40100000)    ///< APB2 base address
N#define AHBPERIPH_BASE        ((uint32_t)0x50000000)    ///< AHB base address
N
N/* Peripheral memory map */
N#define WDT_BASE              (APB1PERIPH_BASE + 0x04000)    ///< WDT register base address
N#define WWDT_BASE             (APB1PERIPH_BASE + 0x04100)    ///< WWDT register base address
N#define TIMER0_BASE           (APB1PERIPH_BASE + 0x10000)    ///< TIMER0 register base address
N#define TIMER1_BASE           (APB1PERIPH_BASE + 0x10020)    ///< TIMER1 register base address
N#define I2C0_BASE             (APB1PERIPH_BASE + 0x20000)    ///< I2C0 register base address
N#define I2C1_BASE             (APB2PERIPH_BASE + 0x20000)    ///< I2C1 register base address
N#define SPI_BASE              (APB1PERIPH_BASE + 0x30000)    ///< SPI register base address
N#define PWM_BASE              (APB1PERIPH_BASE + 0x40000)    ///< PWM register base address
N#define UART0_BASE            (APB1PERIPH_BASE + 0x50000)    ///< UART0 register base address
N#define UART1_BASE            (APB2PERIPH_BASE + 0x50000)    ///< UART1 register base address
N#define ACMP_BASE             (APB1PERIPH_BASE + 0xD0000)    ///< ACMP register base address
N#define ADC_BASE              (APB1PERIPH_BASE + 0xE0000)    ///< ADC register base address
N
N#define SYS_BASE              (AHBPERIPH_BASE + 0x00000)    ///< SYS register base address
N#define CLK_BASE              (AHBPERIPH_BASE + 0x00200)    ///< CLK register base address
N#define INTR_BASE             (AHBPERIPH_BASE + 0x00300)    ///< INT register base address
N#define P0_BASE               (AHBPERIPH_BASE + 0x04000)    ///< GPIO Port 0 register base address
N#define P1_BASE               (AHBPERIPH_BASE + 0x04040)    ///< GPIO Port 1 register base address
N#define P2_BASE               (AHBPERIPH_BASE + 0x04080)    ///< GPIO Port 2 register base address
N#define P3_BASE               (AHBPERIPH_BASE + 0x040C0)    ///< GPIO Port 3 register base address
N#define P4_BASE               (AHBPERIPH_BASE + 0x04100)    ///< GPIO Port 4 register base address
N#define P5_BASE               (AHBPERIPH_BASE + 0x04140)    ///< GPIO Port 5 register base address
N#define GPIO_DBNCECON_BASE    (AHBPERIPH_BASE + 0x04180)    ///< GPIO De-bounce register vase
N#define GPIO_PIN_DATA_BASE    (AHBPERIPH_BASE + 0x04200)    ///< GPIO pin data register base address
N#define GPIOBIT0_BASE         (AHBPERIPH_BASE + 0x04200)    ///< GPIO Port 0 bit access register base address
N#define GPIOBIT1_BASE         (AHBPERIPH_BASE + 0x04220)    ///< GPIO Port 1 bit access register base address
N#define GPIOBIT2_BASE         (AHBPERIPH_BASE + 0x04240)    ///< GPIO Port 2 bit access register base address
N#define GPIOBIT3_BASE         (AHBPERIPH_BASE + 0x04260)    ///< GPIO Port 3 bit access register base address
N#define GPIOBIT4_BASE         (AHBPERIPH_BASE + 0x04280)    ///< GPIO Port 4 bit access register base address
N#define GPIOBIT5_BASE         (AHBPERIPH_BASE + 0x042A0)    ///< GPIO Port 5 bit access register base address
N#define FMC_BASE              (AHBPERIPH_BASE + 0x0C000)    ///< FMC register base address
N
N
N/*@}*/ /* end of group Mini58_PERIPHERAL_MEM_MAP */
N
N
N/** @addtogroup Mini58_PERIPHERAL_DECLARATION Mini58 Peripheral Declaration
N  The Declaration of Mini58 Series Peripheral
N  @{
N */
N#define WDT                   ((WDT_T *) WDT_BASE)              ///< Pointer to WDT register structure
N#define WWDT                  ((WWDT_T *) WWDT_BASE)            ///< Pointer to WWDT register structure
N#define TIMER0                ((TIMER_T *) TIMER0_BASE)         ///< Pointer to Timer 0 register structure
N#define TIMER1                ((TIMER_T *) TIMER1_BASE)         ///< Pointer to Timer 1 register structure
N#define I2C                   ((I2C_T *) I2C0_BASE)             ///< Pointer to I2C0 register structure
N#define I2C0                  ((I2C_T *) I2C0_BASE)             ///< Pointer to I2C0 register structure
N#define I2C1                  ((I2C_T *) I2C1_BASE)             ///< Pointer to I2C1 register structure
N#define SPI                   ((SPI_T *) SPI_BASE)              ///< Pointer to SPI register structure
N#define SPI0                  ((SPI_T *) SPI_BASE)              ///< Pointer to SPI register structure
N#define PWM                   ((PWM_T *) PWM_BASE)              ///< Pointer to PWM register structure
N#define UART                  ((UART_T *) UART0_BASE)           ///< Pointer to UART0 register structure
N#define UART0                 ((UART_T *) UART0_BASE)           ///< Pointer to UART0 register structure
N#define UART1                 ((UART_T *) UART1_BASE)           ///< Pointer to UART1 register structure
N#define ADC                   ((ADC_T *) ADC_BASE)              ///< Pointer to ADC register structure
N#define ACMP                  ((ACMP_T *) ACMP_BASE)            ///< Pointer to ACMP register structure
N
N#define SYS                   ((SYS_T *) SYS_BASE)              ///< Pointer to SYS register structure
N#define CLK                   ((CLK_T *) CLK_BASE)              ///< Pointer to CLK register structure
N#define INTR                  ((INTR_T *) INTR_BASE)            ///< Pointer to INT register structure
N#define P0                    ((GPIO_T *) P0_BASE)              ///< Pointer to GPIO port 0 register structure
N#define P1                    ((GPIO_T *) P1_BASE)              ///< Pointer to GPIO port 1 register structure
N#define P2                    ((GPIO_T *) P2_BASE)              ///< Pointer to GPIO port 2 register structure
N#define P3                    ((GPIO_T *) P3_BASE)              ///< Pointer to GPIO port 3 register structure
N#define P4                    ((GPIO_T *) P4_BASE)              ///< Pointer to GPIO port 4 register structure
N#define P5                    ((GPIO_T *) P5_BASE)              ///< Pointer to GPIO port 5 register structure
N#define GPIO                  ((GPIO_DB_T *) GPIO_DBNCECON_BASE)  ///< Pointer to GPIO de-bounce register structure
N#define FMC                   ((FMC_T *) FMC_BASE)              ///< Pointer to FMC register structure
N
N/*@}*/ /* end of group Mini58_PERIPHERAL_DECLARATION */
N/*@}*/ /* end of group Mini58_Peripherals */
N
N/** @addtogroup Mini58_IO_ROUTINE Mini58 I/O Routines
N  The Declaration of Mini58 I/O Routines
N  @{
N */
N
Ntypedef volatile unsigned char  vu8;        ///< Define 8-bit unsigned volatile data type
Ntypedef volatile unsigned short vu16;       ///< Define 16-bit unsigned volatile data type
Ntypedef volatile unsigned long  vu32;       ///< Define 32-bit unsigned volatile data type
N
N/**
N  * @brief Get a 8-bit unsigned value from specified address
N  * @param[in] addr Address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified address
N  */
N#define M8(addr)  (*((vu8  *) (addr)))
N
N/**
N  * @brief Get a 16-bit unsigned value from specified address
N  * @param[in] addr Address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified address
N  * @note The input address must be 16-bit aligned
N  */
N#define M16(addr) (*((vu16 *) (addr)))
N
N/**
N  * @brief Get a 32-bit unsigned value from specified address
N  * @param[in] addr Address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified address
N  * @note The input address must be 32-bit aligned
N  */
N#define M32(addr) (*((vu32 *) (addr)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outpw(port,value)     *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inpw(port)            (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outps(port,value)     *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inps(port)            (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outpb(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inpb(port)            (*((volatile unsigned char *)(port)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outp32(port,value)    *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inp32(port)           (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outp16(port,value)    *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inp16(port)           (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outp8(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inp8(port)            (*((volatile unsigned char *)(port)))
N
N
N/*@}*/ /* end of group Mini58_IO_ROUTINE */
N
N/******************************************************************************/
N/*                Legacy Constants                                            */
N/******************************************************************************/
N/** @addtogroup Mini58_legacy_Constants Mini58 Legacy Constants
N  Mini58 Legacy Constants
N  @{
N*/
N
N#ifndef NULL
S#define NULL           (0)      ///< NULL pointer
N#endif
N
N#define TRUE           (1)      ///< Boolean true, define to use in API parameters or return value
N#define FALSE          (0)      ///< Boolean false, define to use in API parameters or return value
N
N#define ENABLE         (1)      ///< Enable, define to use in API parameters
N#define DISABLE        (0)      ///< Disable, define to use in API parameters
N
N/* Define one bit mask */
N#define BIT0     (0x00000001)       ///< Bit 0 mask of an 32 bit integer
N#define BIT1     (0x00000002)       ///< Bit 1 mask of an 32 bit integer
N#define BIT2     (0x00000004)       ///< Bit 2 mask of an 32 bit integer
N#define BIT3     (0x00000008)       ///< Bit 3 mask of an 32 bit integer
N#define BIT4     (0x00000010)       ///< Bit 4 mask of an 32 bit integer
N#define BIT5     (0x00000020)       ///< Bit 5 mask of an 32 bit integer
N#define BIT6     (0x00000040)       ///< Bit 6 mask of an 32 bit integer
N#define BIT7     (0x00000080)       ///< Bit 7 mask of an 32 bit integer
N#define BIT8     (0x00000100)       ///< Bit 8 mask of an 32 bit integer
N#define BIT9     (0x00000200)       ///< Bit 9 mask of an 32 bit integer
N#define BIT10    (0x00000400)       ///< Bit 10 mask of an 32 bit integer
N#define BIT11    (0x00000800)       ///< Bit 11 mask of an 32 bit integer
N#define BIT12    (0x00001000)       ///< Bit 12 mask of an 32 bit integer
N#define BIT13    (0x00002000)       ///< Bit 13 mask of an 32 bit integer
N#define BIT14    (0x00004000)       ///< Bit 14 mask of an 32 bit integer
N#define BIT15    (0x00008000)       ///< Bit 15 mask of an 32 bit integer
N#define BIT16    (0x00010000)       ///< Bit 16 mask of an 32 bit integer
N#define BIT17    (0x00020000)       ///< Bit 17 mask of an 32 bit integer
N#define BIT18    (0x00040000)       ///< Bit 18 mask of an 32 bit integer
N#define BIT19    (0x00080000)       ///< Bit 19 mask of an 32 bit integer
N#define BIT20    (0x00100000)       ///< Bit 20 mask of an 32 bit integer
N#define BIT21    (0x00200000)       ///< Bit 21 mask of an 32 bit integer
N#define BIT22    (0x00400000)       ///< Bit 22 mask of an 32 bit integer
N#define BIT23    (0x00800000)       ///< Bit 23 mask of an 32 bit integer
N#define BIT24    (0x01000000)       ///< Bit 24 mask of an 32 bit integer
N#define BIT25    (0x02000000)       ///< Bit 25 mask of an 32 bit integer
N#define BIT26    (0x04000000)       ///< Bit 26 mask of an 32 bit integer
N#define BIT27    (0x08000000)       ///< Bit 27 mask of an 32 bit integer
N#define BIT28    (0x10000000)       ///< Bit 28 mask of an 32 bit integer
N#define BIT29    (0x20000000)       ///< Bit 29 mask of an 32 bit integer
N#define BIT30    (0x40000000)       ///< Bit 30 mask of an 32 bit integer
N#define BIT31    (0x80000000)       ///< Bit 31 mask of an 32 bit integer
N
N/* Byte Mask Definitions */
N#define BYTE0_Msk              (0x000000FF)         ///< Mask to get bit0~bit7 from a 32 bit integer
N#define BYTE1_Msk              (0x0000FF00)         ///< Mask to get bit8~bit15 from a 32 bit integer
N#define BYTE2_Msk              (0x00FF0000)         ///< Mask to get bit16~bit23 from a 32 bit integer
N#define BYTE3_Msk              (0xFF000000)         ///< Mask to get bit24~bit31 from a 32 bit integer
N
N#define GET_BYTE0(u32Param)    ((u32Param & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
N#define GET_BYTE1(u32Param)    ((u32Param & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
N#define GET_BYTE2(u32Param)    ((u32Param & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
N#define GET_BYTE3(u32Param)    ((u32Param & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
N
N/*@}*/ /* end of group Mini58_legacy_Constants */
N
N/*@}*/ /* end of group Mini58_Definitions */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N/******************************************************************************/
N/*                         Peripheral header files                            */
N/******************************************************************************/
N#include "sys.h"
L 1 "..\Library\StdDriver\inc\sys.h" 1
N/**************************************************************************//**
N * @file     sys.h
N * @version  V1.00
N * $Revision: 15 $
N * $Date: 15/06/04 5:18p $ 
N * @brief    Mini58 series SYS driver header file
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __SYS_H__
N#define __SYS_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N    
N/** @addtogroup Mini58_Device_Driver Mini58 Device Driver
N  @{
N*/
N
N/** @addtogroup Mini58_SYS_Driver SYS Driver
N  @{
N*/
N
N/** @addtogroup Mini58_SYS_EXPORTED_CONSTANTS SYS Exported Constants
N  @{
N*/    
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Module Reset Control Resister constant definitions.                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_RST  ((0x4<<24) | SYS_IPRST1_ADCRST_Pos    ) /*!< ADC  reset is one of the SYS_ResetModule parameter */
N#define ACMP_RST ((0x4<<24) | SYS_IPRST1_ACMPRST_Pos   ) /*!< ACMP reset is one of the SYS_ResetModule parameter */
N#define PWM0_RST  ((0x4<<24) | SYS_IPRST1_PWM0RST_Pos    ) /*!< PWM  reset is one of the SYS_ResetModule parameter */
N#define UART0_RST ((0x4<<24) | SYS_IPRST1_UART0RST_Pos ) /*!< UART0 reset is one of the SYS_ResetModule parameter */
N#define UART1_RST ((0x4<<24) | SYS_IPRST1_UART1RST_Pos ) /*!< UART1 reset is one of the SYS_ResetModule parameter */
N#define SPI0_RST ((0x4<<24) | SYS_IPRST1_SPI0RST_Pos    ) /*!< SPI  reset is one of the SYS_ResetModule parameter */
N#define I2C0_RST ((0x4<<24) | SYS_IPRST1_I2C0RST_Pos  ) /*!< I2C0  reset is one of the SYS_ResetModule parameter */
N#define I2C1_RST ((0x4<<24) | SYS_IPRST1_I2C1RST_Pos  ) /*!< I2C1  reset is one of the SYS_ResetModule parameter */
N#define TMR1_RST ((0x4<<24) | SYS_IPRST1_TMR1RST_Pos   ) /*!< TMR1 reset is one of the SYS_ResetModule parameter */
N#define TMR0_RST ((0x4<<24) | SYS_IPRST1_TMR0RST_Pos   ) /*!< TMR0 reset is one of the SYS_ResetModule parameter */
N#define GPIO_RST ((0x4<<24) | SYS_IPRST1_GPIORST_Pos   ) /*!< GPIO reset is one of the SYS_ResetModule parameter */
N    
N    
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Brown Out Detector Threshold Voltage Selection constant definitions.                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYS_BODCTL_BOD_RST_EN             (1UL<<SYS_BODCTL_BODRSTEN_Pos)     /*!< Brown-out Reset Enable */
N#define SYS_BODCTL_BOD_INTERRUPT_EN       (0UL<<SYS_BODCTL_BODRSTEN_Pos)     /*!< Brown-out Interrupt Enable */
N#define SYS_BODCTL_BODVL_4_4V             (3UL<<SYS_BODCTL_BODVL_Pos)     /*!< Setting Brown Out Detector Threshold Voltage as 4.4V */ 
N#define SYS_BODCTL_BODVL_3_7V             (2UL<<SYS_BODCTL_BODVL_Pos)     /*!< Setting Brown Out Detector Threshold Voltage as 3.7V */
N#define SYS_BODCTL_BODVL_2_7V             (1UL<<SYS_BODCTL_BODVL_Pos)     /*!< Setting Brown Out Detector Threshold Voltage as 2.7V */
N#define SYS_BODCTL_BODVL_2_2V             (0UL<<SYS_BODCTL_BODVL_Pos)     /*!< Setting Brown Out Detector Threshold Voltage as 2.2V */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Multi-Function constant definitions.                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYS_MFP_TYPE_Msk(bit)       (1UL << ((bit) +16)) /*!< TYPE mask for Multiple Function Port */
N#define SYS_MFP_ALT_Msk(bit)        (1UL << ((bit) + 8)) /*!< ALT mask for Multiple Function Port */
N#define SYS_MFP_MFP_Msk(bit)        (1UL << ((bit)    )) /*!< MFP mask for Multiple Function Port */
N                                                                                         
N#define SYS_MFP_P00_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P00_UART0_nCTS       0x00000100UL     /*!< Clear to Send input pin for UART0.               */
N#define SYS_MFP_P00_UART0_TXD        0x00000101UL     /*!< Data transmitter output pin for UART0.           */
N#define SYS_MFP_P00_Msk              0x00000101UL     /*!< P0_MFP pin 0 mask                                */
N                                                       
N#define SYS_MFP_P01_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P01_SPI0_SS          0x00000002UL     /*!< 1st SPI0 slave select pin.                       */
N#define SYS_MFP_P01_UART0_nRTS       0x00000200UL     /*!< Request to Send output pin for UART0.            */
N#define SYS_MFP_P01_UART0_RXD        0x00000202UL     /*!< Data receiver input pin for UART0.               */
N#define SYS_MFP_P01_Msk              0x00000202UL     /*!< P0_MFP pin 1 mask                                */
N                                                        
N#define SYS_MFP_P04_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P04_PWM0_CH5         0x00001010UL     /*!< PWM0 channel5 output/capture input.              */
N#define SYS_MFP_P04_SPI0_SS          0x00001000UL     /*!< 1st SPI0 slave select pin.                       */
N#define SYS_MFP_P04_Msk              0x00001010UL     /*!< P0_MFP pin 4 mask                                */
N                                                        
N#define SYS_MFP_P05_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P05_PWM0_CH4         0x00002020UL     /*!< PWM0 channel4 output/capture input.              */
N#define SYS_MFP_P05_SPI0_MOSI        0x00002000UL     /*!< 1st SPI0 MOSI (Master Out, Slave In) pin.        */
N#define SYS_MFP_P05_Msk              0x00002020UL     /*!< P0_MFP pin 5 mask                                */
N                                                        
N#define SYS_MFP_P06_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P06_PWM0_CH1         0x00004040UL     /*!< PWM0 channel1 output/capture input.              */
N#define SYS_MFP_P06_SPI0_MISO        0x00004000UL     /*!< 1st SPI0 MISO (Master In, Slave Out) pin.        */
N#define SYS_MFP_P06_Msk              0x00004040UL     /*!< P0_MFP pin 6 mask                                */
N                                                        
N#define SYS_MFP_P07_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P07_PWM0_CH0         0x00008080UL     /*!< PWM0 channel0 output/capture input.              */
N#define SYS_MFP_P07_SPI0_CLK         0x00008000UL     /*!< SPI0 serial clock pin.                           */
N#define SYS_MFP_P07_Msk              0x00008080UL     /*!< P0_MFP pin 7 mask                                */
N                                                        
N#define SYS_MFP_P10_ACMP0_P1         0x00000101UL     /*!< Analog comparator0 positive input pin.           */
N#define SYS_MFP_P10_ADC_CH1          0x00000001UL     /*!< ADC channel1 analog input.                       */
N#define SYS_MFP_P10_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P10_Msk              0x00000101UL     /*!< P1_MFP pin 0 mask                                */
N                                                        
N#define SYS_MFP_P12_ACMP0_P2         0x00000404UL     /*!< Analog comparator0 positive input pin.           */
N#define SYS_MFP_P12_ADC_CH2          0x00000004UL     /*!< ADC channel2 analog input.                       */
N#define SYS_MFP_P12_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P12_UART0_RXD        0x00000400UL     /*!< Data receiver input pin for UART0.               */
N#define SYS_MFP_P12_PWM0_CH0         0x04000000UL     /*!< PWM0 channel0 output/capture input.              */
N#define SYS_MFP_P12_Msk              0x04000404UL     /*!< P1_MFP pin 2 mask                                */
N                                                        
N#define SYS_MFP_P13_ACMP0_P3         0x00000808UL     /*!< Analog comparator0 positive input pin.           */
N#define SYS_MFP_P13_ADC_CH3          0x00000008UL     /*!< ADC channel3 analog input.                       */
N#define SYS_MFP_P13_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P13_UART0_TXD        0x00000800UL     /*!< Data transmitter output pin for UART0.           */
N#define SYS_MFP_P13_PWM0_CH1         0x08000000UL     /*!< PWM0 channel1 output/capture input.              */
N#define SYS_MFP_P13_Msk              0x08000808UL     /*!< P1_MFP pin 3 mask                                */
N                                                        
N#define SYS_MFP_P14_ACMP0_N          0x00001010UL     /*!< Analog comparator0 negative input pin.           */
N#define SYS_MFP_P14_ADC_CH4          0x00000010UL     /*!< ADC channel4 analog input.                       */
N#define SYS_MFP_P14_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P14_UART1_RXD        0x00001000UL     /*!< Data receiver input pin for UART1.               */
N#define SYS_MFP_P14_PWM0_CH4         0x10000000UL     /*!< PWM0 channel4 output/capture input.              */
N#define SYS_MFP_P14_Msk              0x10001010UL     /*!< P1_MFP pin 4 mask                                */
N                                                        
N#define SYS_MFP_P15_ACMP0_P0         0x00002020UL     /*!< Analog comparator0 positive input pin.           */
N#define SYS_MFP_P15_ADC_CH5          0x00000020UL     /*!< ADC channel5 analog input.                       */
N#define SYS_MFP_P15_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P15_UART1_TXD        0x00002000UL     /*!< Data transmitter output pin for UART1.           */
N#define SYS_MFP_P15_Msk              0x00002020UL     /*!< P1_MFP pin 5 mask                                */
N                                                        
N#define SYS_MFP_P22_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P22_I2C1_SCL         0x00000404UL     /*!< I2C1 clock pin.                                  */
N#define SYS_MFP_P22_PWM0_CH0         0x00000400UL     /*!< PWM0 channel0 output/capture input.              */
N#define SYS_MFP_P22_Msk              0x00000404UL     /*!< P2_MFP pin 2 mask                                */
N                                                     
N#define SYS_MFP_P23_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P23_I2C1_SDA         0x00000808UL     /*!< I2C1 data input/output pin.                      */
N#define SYS_MFP_P23_PWM0_CH1         0x00000800UL     /*!< PWM0 channel1 output/capture input.              */
N#define SYS_MFP_P23_Msk              0x00000808UL     /*!< P2_MFP pin 3 mask                                */
N                                                        
N#define SYS_MFP_P24_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P24_PWM0_CH2         0x00001000UL     /*!< PWM0 channel2 output/capture input.              */
N#define SYS_MFP_P24_UART1_RXD        0x00000010UL     /*!< Data receiver input pin for UART1.               */
N#define SYS_MFP_P24_Msk              0x00001010UL     /*!< P2_MFP pin 4 mask                                */
N                                                        
N#define SYS_MFP_P25_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P25_PWM0_CH3         0x00002000UL     /*!< PWM0 channel3 output/capture input.              */
N#define SYS_MFP_P25_UART1_TXD        0x00000020UL     /*!< Data transmitter output pin for UART1.           */
N#define SYS_MFP_P25_Msk              0x00002020UL     /*!< P2_MFP pin 5 mask                                */
N                                                        
N#define SYS_MFP_P26_ACMP1_O          0x00004040UL     /*!< Analog ccomparator1 output.                      */
N#define SYS_MFP_P26_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P26_PWM0_CH4         0x00004000UL     /*!< PWM0 channel4 output/capture input.              */
N#define SYS_MFP_P26_Msk              0x00004040UL     /*!< P2_MFP pin 6 mask                                */
N                                                        
N#define SYS_MFP_P30_ACMP1_N          0x00000100UL     /*!< Analog comparator1 negative input pin.           */
N#define SYS_MFP_P30_ADC_CH6          0x00000101UL     /*!< ADC channel6 analog input.                       */
N#define SYS_MFP_P30_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P30_Msk              0x00000101UL     /*!< P3_MFP pin 0 mask                                */
N                                                        
N#define SYS_MFP_P31_ACMP1_P0         0x00000200UL     /*!< Analog comparator1 positive input pin.           */
N#define SYS_MFP_P31_ADC_CH7          0x00000202UL     /*!< ADC channel7 analog input.                       */
N#define SYS_MFP_P31_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P31_Msk              0x00000202UL     /*!< P3_MFP pin 1 mask                                */
N                                                        
N#define SYS_MFP_P32_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P32_INT0             0x00000004UL     /*!< External interrupt0 input pin.                   */
N#define SYS_MFP_P32_STADC            0x00000404UL     /*!< ADC external trigger input.                      */
N#define SYS_MFP_P32_TM0_EXT          0x00000400UL     /*!< Timer0 external capture input.                   */
N#define SYS_MFP_P32_ACMP1_P1         0x04000000UL     /*!< Analog comparator1 positive input pin.           */
N#define SYS_MFP_P32_Msk              0x04000404UL     /*!< P3_MFP pin 2 mask                                */
N                                                        
N#define SYS_MFP_P34_ACMP1_P2         0x00001010UL     /*!< Analog comparator1 positive input pin.           */
N#define SYS_MFP_P34_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P34_I2C0_SDA         0x00001000UL     /*!< I2C0 data input/output pin.                      */
N#define SYS_MFP_P34_TM0_CNT_OUT      0x00000010UL     /*!< Timer0  event counter input/toggle output.       */
N#define SYS_MFP_P34_Msk              0x00001010UL     /*!< P3_MFP pin 4 mask                                */
N                                                        
N#define SYS_MFP_P35_ACMP1_P3         0x00002020UL     /*!< Analog comparator1 positive input pin.           */
N#define SYS_MFP_P35_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P35_I2C0_SCL         0x00002000UL     /*!< I2C0 clock pin.                                  */
N#define SYS_MFP_P35_TM1_CNT_OUT      0x00000020UL     /*!< Timer1  event counter input/toggle output.       */
N#define SYS_MFP_P35_Msk              0x00002020UL     /*!< P3_MFP pin 5 mask                                */
N                                                        
N#define SYS_MFP_P36_ACMP0_O          0x00004040UL     /*!< Analog ccomparator0 output.                      */
N#define SYS_MFP_P36_CLKO             0x00004000UL     /*!< Clock output.                                    */
N#define SYS_MFP_P36_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P36_TM1_EXT          0x00000040UL     /*!< Timer1 external capture input.                   */
N#define SYS_MFP_P36_Msk              0x00004040UL     /*!< P3_MFP pin 6 mask                                */
N                                                        
N#define SYS_MFP_P46_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P46_ICE_CLK          0x00000040UL     /*!< Serial wired debugger clock pin.                 */
N#define SYS_MFP_P46_UART1_RXD        0x00004000UL     /*!< Data receiver input pin for UART1.               */
N#define SYS_MFP_P46_Msk              0x00004040UL     /*!< P4_MFP pin 6 mask                                */
N                                                        
N#define SYS_MFP_P47_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P47_ICE_DAT          0x00000080UL     /*!< Serial wired debugger data pin.                  */
N#define SYS_MFP_P47_UART1_TXD        0x00008000UL     /*!< Data transmitter output pin for UART1.           */
N#define SYS_MFP_P47_Msk              0x00008080UL     /*!< P4_MFP pin 7 mask                                */
N                                                        
N#define SYS_MFP_P50_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P50_I2C1_SDA         0x00000100UL     /*!< I2C1 data input/output pin.                      */
N#define SYS_MFP_P50_UART0_TXD        0x00000101UL     /*!< Data transmitter output pin for UART0.           */
N#define SYS_MFP_P50_XT1_IN           0x00000001UL     /*!< External 4~24 MHz (high speed) crystal input pin. */
N#define SYS_MFP_P50_Msk              0x00000101UL     /*!< P5_MFP pin 0 mask                                */
N                                                        
N#define SYS_MFP_P51_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P51_I2C1_SCL         0x00000200UL     /*!< I2C1 clock pin.                                  */
N#define SYS_MFP_P51_UART0_RXD        0x00000202UL     /*!< Data receiver input pin for UART0.               */
N#define SYS_MFP_P51_XT1_OUT          0x00000002UL     /*!< External 4~24 MHz (high speed) crystal output pin. */
N#define SYS_MFP_P51_Msk              0x00000202UL     /*!< P5_MFP pin 1 mask                                */
N                                                        
N#define SYS_MFP_P52_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P52_INT1             0x00000004UL     /*!< External interrupt1 input pin.                   */
N#define SYS_MFP_P52_Msk              0x00000404UL     /*!< P5_MFP pin 2 mask                                */
N                                                        
N#define SYS_MFP_P53_ADC_CH0          0x00000008UL     /*!< ADC channel0 analog input.                       */
N#define SYS_MFP_P53_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P53_Msk              0x00000808UL     /*!< P5_MFP pin 3 mask                                */
N                                                        
N#define SYS_MFP_P54_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P54_Msk              0x00001010UL     /*!< P5_MFP pin 4 mask                                */
N                                                        
N#define SYS_MFP_P55_GPIO             0x00000000UL     /*!< General purpose digital I/O pin.                 */
N#define SYS_MFP_P55_Msk              0x00002020UL     /*!< P5_MFP pin 5 mask                                */
N
N
N/*@}*/ /* end of group Mini58_SYS_EXPORTED_CONSTANTS */
N
N/** @addtogroup Mini58_SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N/**
N  * @brief      Clear Brown-out detector interrupt flag
N  * @param      None
N  * @return     None
N  * @details    This macro clear Brown-out detector interrupt flag.
N  */
N#define SYS_CLEAR_BOD_INT_FLAG()        (SYS->BODCTL |= SYS_BODCTL_BODIF_Msk)
N
N/**
N  * @brief      Set Brown-out detector function to normal mode
N  * @param      None
N  * @return     None
N  * @details    This macro set Brown-out detector to normal mode.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_CLEAR_BOD_LPM()             (SYS->BODCTL &= ~SYS_BODCTL_BODLPM_Msk)
N
N/**
N  * @brief      Disable Brown-out detector function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Brown-out detector function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_DISABLE_BOD()               (SYS->BODCTL = (SYS->BODCTL &~(SYS_BODCTL_BODVL_Msk|SYS_BODCTL_BODEN_Msk))|SYS_BODCTL_BODVL_Msk)
N
N/**
N  * @brief      Enable Brown-out detector function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detector function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_ENABLE_BOD()                (SYS->BODCTL = (SYS->BODCTL | SYS_BODCTL_BODEN_Msk))
N
N/**
N  * @brief      Get Brown-out detector interrupt flag
N  * @param      None
N  * @retval     0   Brown-out detect interrupt flag is not set.
N  * @retval     >=1 Brown-out detect interrupt flag is set.
N  * @details    This macro get Brown-out detector interrupt flag.
N  */
N#define SYS_GET_BOD_INT_FLAG()          (SYS->BODCTL & SYS_BODCTL_BODIF_Msk)
N
N/**
N  * @brief      Get Brown-out detector status
N  * @param      None
N  * @retval     0   System voltage is higher than BOD threshold voltage setting or BOD function is disabled.
N  * @retval     >=1 System voltage is lower than BOD threshold voltage setting.
N  * @details    This macro get Brown-out detector output status.
N  *             If the BOD function is disabled, this function always return 0.
N  */
N#define SYS_GET_BOD_OUTPUT()            (SYS->BODCTL & SYS_BODCTL_BODOUT_Msk)
N
N/**
N  * @brief      Enable Brown-out detector interrupt function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detector interrupt function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_DISABLE_BOD_RST()           (SYS->BODCTL &= ~SYS_BODCTL_BODRSTEN_Msk)
N
N/**
N  * @brief      Enable Brown-out detector reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detect reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_ENABLE_BOD_RST()            (SYS->BODCTL |= SYS_BODCTL_BODRSTEN_Msk)
N
N/**
N  * @brief      Set Brown-out detector function low power mode
N  * @param      None
N  * @return     None
N  * @details    This macro set Brown-out detector to low power mode.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_SET_BOD_LPM()               (SYS->BODCTL |= SYS_BODCTL_BODLPM_Msk)
N
N/**
N  * @brief      Set Brown-out detector voltage level
N  * @param[in]  u32Level is Brown-out voltage level. Including :
N  *             - \ref SYS_BODCTL_BODVL_4_4V
N  *             - \ref SYS_BODCTL_BODVL_3_7V
N  *             - \ref SYS_BODCTL_BODVL_2_7V
N  *             - \ref SYS_BODCTL_BODVL_2_2V
N  * @return     None
N  * @details    This macro set Brown-out detector voltage level.
N  *             The write-protection function should be disabled before using this macro.
N  */
N#define SYS_SET_BOD_LEVEL(u32Level)     (SYS->BODCTL = (SYS->BODCTL & ~SYS_BODCTL_BODVL_Msk) | (u32Level))
N
N/**
N  * @brief      Get reset source is from Brown-out detector reset
N  * @param      None
N  * @retval     0   Previous reset source is not from Brown-out detector reset
N  * @retval     >=1 Previous reset source is from Brown-out detector reset
N  * @details    This macro get previous reset source is from Brown-out detect reset or not.
N  */
N#define SYS_IS_BOD_RST()                (SYS->RSTSTS & SYS_RSTSTS_BODRF_Msk)
N
N/**
N  * @brief      Get reset source is from CPU reset
N  * @param      None
N  * @retval     0   Previous reset source is not from CPU reset
N  * @retval     >=1 Previous reset source is from CPU reset
N  * @details    This macro get previous reset source is from CPU reset.
N  */
N#define SYS_IS_CPU_RST()                (SYS->RSTSTS & SYS_RSTSTS_CPURF_Msk)
N
N/**
N  * @brief      Get reset source is from Power-on Reset
N  * @param      None
N  * @retval     0   Previous reset source is not from Power-on Reset
N  * @retval     >=1 Previous reset source is from Power-on Reset
N  * @details    This macro get previous reset source is from Power-on Reset.
N  */
N#define SYS_IS_POR_RST()                (SYS->RSTSTS & SYS_RSTSTS_PORF_Msk)
N
N/**
N  * @brief      Get reset source is from reset pin reset
N  * @param      None
N  * @retval     0   Previous reset source is not from reset pin reset
N  * @retval     >=1 Previous reset source is from reset pin reset
N  * @details    This macro get previous reset source is from reset pin reset.
N  */
N#define SYS_IS_RSTPIN_RST()             (SYS->RSTSTS & SYS_RSTSTS_PINRF_Msk)
N
N/**
N  * @brief      Get reset source is from system reset
N  * @param      None
N  * @retval     0   Previous reset source is not from system reset
N  * @retval     >=1 Previous reset source is from system reset
N  * @details    This macro get previous reset source is from system reset.
N  */
N#define SYS_IS_SYSTEM_RST()             (SYS->RSTSTS & SYS_RSTSTS_SYSRF_Msk)
N
N/**
N  * @brief      Get reset source is from window watch dog reset
N  * @param      None
N  * @retval     0   Previous reset source is not from window watch dog reset
N  * @retval     >=1 Previous reset source is from window watch dog reset
N  * @details    This macro get previous reset source is from window watch dog reset.
N  */
N#define SYS_IS_WDT_RST()                (SYS->RSTSTS & SYS_RSTSTS_WDTRF_Msk)
N
N/**
N  * @brief      Disable Power-on Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Power-on Reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_DISABLE_POR()               (SYS->PORCTL = 0x5AA5)
N
N/**
N  * @brief      Enable Power-on Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Power-on Reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_ENABLE_POR()                (SYS->PORCTL = 0)
N
N/**
N  * @brief      Clear reset source flag
N  * @param[in]  u32RstSrc is reset source. Including :
N  *             - \ref SYS_RSTSTS_PORF_Msk
N  *             - \ref SYS_RSTSTS_PINRF_Msk
N  *             - \ref SYS_RSTSTS_WDTRF_Msk
N  *             - \ref SYS_RSTSTS_BODRF_Msk
N  *             - \ref SYS_RSTSTS_SYSRF_Msk
N  *             - \ref SYS_RSTSTS_CPURF_Msk
N  *             - \ref SYS_RSTSTS_CPULKRF_Msk
N  * @return     None
N  * @details    This macro clear reset source flag.
N  */
N#define SYS_CLEAR_RST_SOURCE(u32RstSrc) ((SYS->RSTSTS) = (u32RstSrc) )
N
N
N/**
N  * @brief      Disable register write-protection function
N  * @param      None
N  * @return     None
N  * @details    This function disable register write-protection function.
N  *             To unlock the protected register to allow write access.
N  */
N__STATIC_INLINE void SYS_UnlockReg(void)
Xstatic __inline void SYS_UnlockReg(void)
N{
N    do
N    {
N        SYS->REGLCTL = 0x59;
X        ((SYS_T *) (((uint32_t)0x50000000) + 0x00000))->REGLCTL = 0x59;
N        SYS->REGLCTL = 0x16;
X        ((SYS_T *) (((uint32_t)0x50000000) + 0x00000))->REGLCTL = 0x16;
N        SYS->REGLCTL = 0x88;
X        ((SYS_T *) (((uint32_t)0x50000000) + 0x00000))->REGLCTL = 0x88;
N    }
N    while(SYS->REGLCTL == 0);
X    while(((SYS_T *) (((uint32_t)0x50000000) + 0x00000))->REGLCTL == 0);
N}
N
N/**
N  * @brief      Enable register write-protection function
N  * @param      None
N  * @return     None
N  * @details    This function is used to enable register write-protection function.
N  *             To lock the protected register to forbid write access.
N  */
N__STATIC_INLINE void SYS_LockReg(void)
Xstatic __inline void SYS_LockReg(void)
N{
N    SYS->REGLCTL = 0;
X    ((SYS_T *) (((uint32_t)0x50000000) + 0x00000))->REGLCTL = 0;
N}
N    
Nvoid SYS_ClearResetSrc(uint32_t u32Src);
Nuint32_t SYS_GetBODStatus(void);
Nuint32_t SYS_GetResetSrc(void);
Nuint32_t SYS_IsRegLocked(void);
Nuint32_t  SYS_ReadPDID(void);
Nvoid SYS_ResetChip(void);
Nvoid SYS_ResetCPU(void);
Nvoid SYS_ResetModule(uint32_t u32ModuleIndex);
Nvoid SYS_EnableBOD(int32_t i32Mode, uint32_t u32BODLevel);
Nvoid SYS_DisableBOD(void);    
N
N/*@}*/ /* end of group Mini58_SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group Mini58_SYS_Driver */
N
N/*@}*/ /* end of group Mini58_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SYS_H__
L 11937 "..\Library\Device\Nuvoton\Mini58Series\Include\Mini58Series.h" 2
N#include "clk.h"
L 1 "..\Library\StdDriver\inc\clk.h" 1
N/**************************************************************************//**
N * @file     clk.h
N * @version  V1.00
N * $Revision: 16 $
N * $Date: 15/06/05 9:38a $ 
N * @brief    Mini58 series CLK driver header file
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __CLK_H__
N#define __CLK_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Mini58_Device_Driver Mini58 Device Driver
N  @{
N*/
N
N/** @addtogroup Mini58_CLK_Driver CLK Driver
N  @{
N*/
N
N
N
N/** @addtogroup Mini58_CLK_EXPORTED_CONSTANTS CLK Exported Constants
N  @{
N*/
N
N#define FREQ_25MHZ         25000000
N#define FREQ_50MHZ         50000000
N#define FREQ_72MHZ         72000000
N#define FREQ_100MHZ        100000000
N#define FREQ_200MHZ        200000000
N#define FREQ_250MHZ        250000000
N#define FREQ_500MHZ        500000000
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PWRCTL constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_PWRCTL_XTL12M              0x01UL /*!< Setting External Crystal Oscillator as 12MHz         */
N#define CLK_PWRCTL_XTLEN_HXT           0x01UL /*!< Setting External Crystal Oscillator as 12MHz         */
N#define CLK_PWRCTL_XTL32K              0x02UL /*!< Setting External Crystal Oscillator as 32KHz         */
N#define CLK_PWRCTL_XTLEN_LXT           0x02UL /*!< Setting External Crystal Oscillator as 32KHz         */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL0 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL0_HCLKSEL_XTAL          0x00UL /*!< Setting clock source as external XTAL */
N#define CLK_CLKSEL0_HCLKSEL_HXT           0x00UL /*!< Setting clock source as external HXT */
N#define CLK_CLKSEL0_HCLKSEL_LXT           0x00UL /*!< Setting clock source as external LXT */
N#define CLK_CLKSEL0_HCLKSEL_PLL           0x02UL /*!< Setting clock source as PLL */
N#define CLK_CLKSEL0_HCLKSEL_LIRC          0x03UL /*!< Setting clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL0_HCLKSEL_HIRC          0x07UL /*!< Setting clock source as internal RC clock */
N#define CLK_CLKSEL0_STCLKSEL_XTAL         0x00UL /*!< Setting clock source as external XTAL */ 
N#define CLK_CLKSEL0_STCLKSEL_XTAL_DIV2    0x10UL /*!< Setting clock source as external XTAL/2 */
N#define CLK_CLKSEL0_STCLKSEL_HCLK_DIV2    0x18UL /*!< Setting clock source as HCLK/2 */
N#define CLK_CLKSEL0_STCLKSEL_HIRC_DIV2    0x38UL /*!< Setting clock source as internal RC clock/2 */
N#define CLK_CLKSEL0_STCLKSEL_HCLK         0x08UL /*!< Setting clock source as HCLK */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL1 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL1_WDTSEL_XTAL          0x00000000UL /*!< Setting WDT clock source as external XTAL */ 
N#define CLK_CLKSEL1_WDTSEL_HCLK_DIV2048  0x00000002UL /*!< Setting WDT clock source as HCLK/2048 */
N#define CLK_CLKSEL1_WDTSEL_IRC10K        0x00000003UL /*!< Setting WDT clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_WDTSEL_LIRC          0x00000003UL /*!< Setting WDT clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_ADCSEL_XTAL          0x00000000UL /*!< Setting ADC clock source as external XTAL */
N#define CLK_CLKSEL1_ADCSEL_PLL           0x00000004UL /*!< Setting ADC clock source as PLL */
N#define CLK_CLKSEL1_ADCSEL_HCLK          0x00000008UL /*!< Setting ADC clock source as HCLK */
N#define CLK_CLKSEL1_ADCSEL_HIRC          0x0000000CUL /*!< Setting ADC clock source as internal RC clock */
N#define CLK_CLKSEL1_SPISEL_XTAL          0x00000000UL /*!< Setting SPI clock source as HXT or LXT */
N#define CLK_CLKSEL1_SPISEL_HCLK          0x00000010UL /*!< Setting SPI clock source as HCLK */
N#define CLK_CLKSEL1_SPISEL_PLL           0x00000020UL /*!< Setting SPI clock source as PLL */
N#define CLK_CLKSEL1_TMR0SEL_XTAL         0x00000000UL /*!< Setting Timer 0 clock source as external XTAL */
N#define CLK_CLKSEL1_TMR0SEL_LIRC         0x00000100UL /*!< Setting Timer 0 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR0SEL_HCLK         0x00000200UL /*!< Setting Timer 0 clock source as HCLK */
N#define CLK_CLKSEL1_TMR0SEL_TM0          0x00000300UL /*!< Setting Timer 0 clock source as external trigger */
N#define CLK_CLKSEL1_TMR0SEL_HIRC         0x00000700UL /*!< Setting Timer 0 clock source as internal RC clock */
N#define CLK_CLKSEL1_TMR1SEL_XTAL         0x00000000UL /*!< Setting Timer 1 clock source as external XTAL */
N#define CLK_CLKSEL1_TMR1SEL_LIRC         0x00001000UL /*!< Setting Timer 1 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR1SEL_HCLK         0x00002000UL /*!< Setting Timer 1 clock source as HCLK */
N#define CLK_CLKSEL1_TMR1SEL_TM1          0x00003000UL /*!< Setting Timer 1 clock source as external trigger */
N#define CLK_CLKSEL1_TMR1SEL_HIRC         0x00007000UL /*!< Setting Timer 1 clock source as internal RC clock */
N#define CLK_CLKSEL1_UARTSEL_XTAL         0x00000000UL /*!< Setting UART clock source as external XTAL */
N#define CLK_CLKSEL1_UARTSEL_PLL          0x01000000UL /*!< Setting UART clock source as external PLL */
N#define CLK_CLKSEL1_UARTSEL_HIRC         0x02000000UL /*!< Setting UART clock source as external internal RC clock */
N#define CLK_CLKSEL1_PWMCH01SEL_HCLK      0x20000000UL /*!< Setting PWM01 clock source as external HCLK */
N#define CLK_CLKSEL1_PWMCH23SEL_HCLK      0x80000000UL /*!< Setting PWM23 clock source as external HCLK */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL2 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL2_CLKOSEL_XTAL        0x00000000UL /*!< Setting CLKODIV clock source as external XTAL */ 
N#define CLK_CLKSEL2_CLKOSEL_HXT         0x00000000UL /*!< Setting CLKODIV clock source as external XTAL */ 
N#define CLK_CLKSEL2_CLKOSEL_LXT         0x00000000UL /*!< Setting CLKODIV clock source as external XTAL */ 
N#define CLK_CLKSEL2_CLKOSEL_LIRC        0x00000004UL /*!< Setting CLKODIV clock source as LIRC */ 
N#define CLK_CLKSEL2_CLKOSEL_HCLK        0x00000008UL /*!< Setting CLKODIV clock source as HCLK */
N#define CLK_CLKSEL2_CLKOSEL_HIRC        0x0000000CUL /*!< Setting CLKODIV clock source as internal RC clock */
N#define CLK_CLKSEL2_PWMCH45SEL_HCLK     0x00000020UL /*!< Setting PWMCH45 clock source as HCLK */
N#define CLK_CLKSEL2_WWDTSEL_HCLK_DIV2048   0x00020000UL /*!< Setting WWDT clock source as HCLK/2048 */ 
N#define CLK_CLKSEL2_WWDTSEL_LIRC           0x00030000UL /*!< Setting WWDT clock source as internal RC clock */ 
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKDIV constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKDIV_ADC(x)  (((x)-1) << 16) /*!< CLKDIV Setting for ADC clock divider. It could be 1~256 */ 
N#define CLK_CLKDIV_UART(x) (((x)-1) <<  8) /*!< CLKDIV Setting for UART clock divider. It could be 1~16 */ 
N#define CLK_CLKDIV_HCLK(x)  ((x)-1)        /*!< CLKDIV Setting for HCLK clock divider. It could be 1~16 */ 
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PLLCTL constant definitions. PLL = FIN * NF / NR / NO                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_PLLCTL_PLLSRC_HXT   0x00000000UL    /*!< For PLL clock source is HXT.  3.2MHz < FIN < 150MHz */
N#define CLK_PLLCTL_PLLSRC_HIRC  0x00080000UL    /*!< For PLL clock source is HIRC. 3.2MHz < FIN < 150MHz */
N
N#define CLK_PLLCTL_NF(x)        ((x)-2)         /*!< x must be constant and 2 <= x <= 513. 200MHz < FIN*NF/NR < 500MHz. (FIN*NF/NR > 250MHz is preferred.) */
N#define CLK_PLLCTL_NR(x)        (((x)-2)<<9)    /*!< x must be constant and 2 <= x <= 33.  1.6MHz < FIN/NR < 16MHz */
N
N#define CLK_PLLCTL_NO_1         0x0000UL        /*!< For output divider is 1 */
N#define CLK_PLLCTL_NO_2         0x4000UL        /*!< For output divider is 2 */
N#define CLK_PLLCTL_NO_4         0xC000UL        /*!< For output divider is 4 */
N
N#define CLK_PLLCTL_72MHz_HXT   (CLK_PLLCTL_PLLSRC_HXT  | CLK_PLLCTL_NR(2) | CLK_PLLCTL_NF( 24) | CLK_PLLCTL_NO_2) /*!< Predefined PLLCTL setting for  72MHz PLL output with HXT(12MHz X'tal) */
N#define CLK_PLLCTL_96MHz_HXT   (CLK_PLLCTL_PLLSRC_HXT  | CLK_PLLCTL_NR(2) | CLK_PLLCTL_NF( 32) | CLK_PLLCTL_NO_2) /*!< Predefined PLLCTL setting for  96MHz PLL output with HXT(12MHz X'tal) */
N#define CLK_PLLCTL_100MHz_HXT  (CLK_PLLCTL_PLLSRC_HXT  | CLK_PLLCTL_NR(3) | CLK_PLLCTL_NF( 50) | CLK_PLLCTL_NO_2) /*!< Predefined PLLCTL setting for 100MHz PLL output with HXT(12MHz X'tal) */	
N
N#define CLK_PLLCTL_72MHz_HIRC  (CLK_PLLCTL_PLLSRC_HIRC | CLK_PLLCTL_NR(4) | CLK_PLLCTL_NF( 26) | CLK_PLLCTL_NO_2) /*!< Predefined PLLCTL setting for 71.884800MHz PLL output with HIRC(22.1184MHz X'tal) */
N#define CLK_PLLCTL_96MHz_HIRC  (CLK_PLLCTL_PLLSRC_HIRC | CLK_PLLCTL_NR(13)| CLK_PLLCTL_NF(113) | CLK_PLLCTL_NO_2) /*!< Predefined PLLCTL setting for 96.129968MHz PLL output with HIRC(22.1184MHz X'tal) */
N#define CLK_PLLCTL_100MHz_HIRC (CLK_PLLCTL_PLLSRC_HIRC | CLK_PLLCTL_NR(4) | CLK_PLLCTL_NF( 36) | CLK_PLLCTL_NO_2) /*!< Predefined PLLCTL setting for 99.532800MHz PLL output with HIRC(22.1184MHz X'tal) */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  MODULE constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/ 
N#define MODULE_APBCLK(x)                   ((x >>31) & 0x1)    /*!< Calculate APBCLK offset on MODULE index */ 
N#define MODULE_CLKSEL(x)                   ((x >>29) & 0x3)    /*!< Calculate CLKSEL offset on MODULE index */ 
N#define MODULE_CLKSEL_Msk(x)               ((x >>25) & 0xf)    /*!< Calculate CLKSEL mask offset on MODULE index */ 
N#define MODULE_CLKSEL_Pos(x)               ((x >>20) & 0x1f)   /*!< Calculate CLKSEL position offset on MODULE index */ 
N#define MODULE_CLKDIV(x)                   ((x >>18) & 0x3)    /*!< Calculate APBCLK CLKDIV on MODULE index */ 
N#define MODULE_CLKDIV_Msk(x)               ((x >>10) & 0xff)   /*!< Calculate CLKDIV mask offset on MODULE index */ 
N#define MODULE_CLKDIV_Pos(x)               ((x >>5 ) & 0x1f)   /*!< Calculate CLKDIV position offset on MODULE index */ 
N#define MODULE_IP_EN_Pos(x)                ((x >>0 ) & 0x1f)   /*!< Calculate APBCLK offset on MODULE index */ 
N#define MODULE_NoMsk                       0x0                 /*!< Not mask on MODULE index */ 
N#define NA                                 MODULE_NoMsk        /*!< Not Available */
N
N#define MODULE_APBCLK_ENC(x)        (((x) & 0x01) << 31)   /*!< MODULE index, 0x0:AHBCLK, 0x1:APBCLK */
N#define MODULE_CLKSEL_ENC(x)        (((x) & 0x03) << 29)   /*!< CLKSEL offset on MODULE index, 0x0:CLKSEL0, 0x1:CLKSEL1 0x3 CLKSEL2*/
N#define MODULE_CLKSEL_Msk_ENC(x)    (((x) & 0x0f) << 25)   /*!< CLKSEL mask offset on MODULE index */
N#define MODULE_CLKSEL_Pos_ENC(x)    (((x) & 0x1f) << 20)   /*!< CLKSEL position offset on MODULE index */
N#define MODULE_CLKDIV_ENC(x)        (((x) & 0x03) << 18)   /*!< APBCLK CLKDIV on MODULE index, 0x0:CLKDIV */
N#define MODULE_CLKDIV_Msk_ENC(x)    (((x) & 0xff) << 10)   /*!< CLKDIV mask offset on MODULE index */
N#define MODULE_CLKDIV_Pos_ENC(x)    (((x) & 0x1f) <<  5)   /*!< CLKDIV position offset on MODULE index */
N#define MODULE_IP_EN_Pos_ENC(x)     (((x) & 0x1f) <<  0)   /*!< APBCLK offset on MODULE index */
N/*-------------------------------------------------------------------------------------------------------------------------------*/        
N/*   APBCLK(1) | CLKSEL(2) | CLKSEL_Msk(4) |    CLKSEL_Pos(5)    | CLKDIV(2) | CLKDIV_Msk(8) |     CLKDIV_Pos(5)  |  IP_EN_Pos(5)*/
N/*-------------------------------------------------------------------------------------------------------------------------------*/
N#define ISP_MODULE       (( 0UL<<31)|( 0<<29)|( MODULE_NoMsk<<25)|( 0<<20)|( 0<<18)|( MODULE_NoMsk<<10)|( 0<<5)|( 2<<0)) /*!< ISP Module  \hideinitializer */
N#define WDT_MODULE       (( 1UL<<31)|( 1<<29)|(            3<<25)|( 0<<20)|( 0<<18)|( MODULE_NoMsk<<10)|( 0<<5)|( 0<<0)) /*!< WDT Module  \hideinitializer */
N#define TMR0_MODULE      (( 1UL<<31)|( 1<<29)|(            7<<25)|( 8<<20)|( 0<<18)|( MODULE_NoMsk<<10)|( 0<<5)|( 2<<0)) /*!< TMR0 Module  \hideinitializer */
N#define TMR1_MODULE      (( 1UL<<31)|( 1<<29)|(            7<<25)|(12<<20)|( 0<<18)|( MODULE_NoMsk<<10)|( 0<<5)|( 3<<0)) /*!< TMR1 Module  \hideinitializer */
N#define CLKO_MODULE      (( 1UL<<31)|( 3<<29)|(            3<<25)|( 2<<20)|( 0<<18)|( MODULE_NoMsk<<10)|( 0<<5)|( 6<<0)) /*!< CLKO Module  \hideinitializer */
N#define I2C0_MODULE      (( 1UL<<31)|( 0<<29)|( MODULE_NoMsk<<25)|( 0<<20)|( 0<<18)|( MODULE_NoMsk<<10)|( 0<<5)|( 8<<0)) /*!< I2C0 Module  \hideinitializer */
N#define I2C1_MODULE      (( 1UL<<31)|( 0<<29)|( MODULE_NoMsk<<25)|( 0<<20)|( 0<<18)|( MODULE_NoMsk<<10)|( 0<<5)|( 9<<0)) /*!< I2C1 Module  \hideinitializer */
N#define SPI0_MODULE      (( 1UL<<31)|( 1<<29)|(            3<<25)|( 4<<20)|( 0<<18)|( MODULE_NoMsk<<10)|( 0<<5)|(12<<0)) /*!< SPI Module  \hideinitializer */
N#define UART0_MODULE     (( 1UL<<31)|( 1<<29)|(            3<<25)|(24<<20)|( 0<<18)|(          0xF<<10)|( 8<<5)|(16<<0)) /*!< UART0 Module  \hideinitializer */
N#define UART1_MODULE     (( 1UL<<31)|( 1<<29)|(            3<<25)|(24<<20)|( 0<<18)|(          0xF<<10)|( 8<<5)|(17<<0)) /*!< UART1 Module  \hideinitializer */
N#define PWMCH01_MODULE   (( 1UL<<31)|( 1<<29)|(            3<<25)|(28<<20)|( 0<<18)|( MODULE_NoMsk<<10)|( 0<<5)|(20<<0)) /*!< PWMCH01 Module  \hideinitializer */
N#define PWMCH23_MODULE   (( 1UL<<31)|( 1<<29)|(            3<<25)|(30<<20)|( 0<<18)|( MODULE_NoMsk<<10)|( 0<<5)|(21<<0)) /*!< PWMCH23 Module  \hideinitializer */
N#define PWMCH45_MODULE   (( 1UL<<31)|( 3<<29)|(            3<<25)|( 4<<20)|( 0<<18)|( MODULE_NoMsk<<10)|( 0<<5)|(22<<0)) /*!< PWMCH45 Module  \hideinitializer */
N#define ADC_MODULE       (( 1UL<<31)|( 1<<29)|(            3<<25)|( 2<<20)|( 0<<18)|(         0xFF<<10)|(16<<5)|(28<<0)) /*!< ADC Module  \hideinitializer */
N#define ACMP_MODULE      (( 1UL<<31)|( 0<<29)|( MODULE_NoMsk<<25)|( 0<<20)|( 0<<18)|( MODULE_NoMsk<<10)|( 0<<5)|(30<<0)) /*!< ACMP Module  \hideinitializer */
N#define WWDT_MODULE      (( 1UL<<31)|( 3<<29)|(            3<<25)|(16<<20)|( 0<<18)|( MODULE_NoMsk<<10)|( 0<<5)|( 0<<0)) /*!< WWDT Module  \hideinitializer */
N
N
N
N/*@}*/ /* end of group Mini58_CLK_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup Mini58_CLK_EXPORTED_FUNCTIONS CLK Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Get PLL clock frequency
N  * @param      None
N  * @return     PLL frequency
N  * @details    This function get PLL frequency. The frequency unit is Hz.
N  */
N__STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
Xstatic __inline uint32_t CLK_GetPLLClockFreq(void)
N{
N    uint32_t u32PllFreq = 0, u32PllReg;
N    uint32_t u32FIN, u32NF, u32NR, u32NO;
N    uint8_t au8NoTbl[4] = {1, 2, 2, 4};
N
N    u32PllReg = CLK->PLLCTL;
X    u32PllReg = ((CLK_T *) (((uint32_t)0x50000000) + 0x00200))->PLLCTL;
N
N    if(u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
X    if(u32PllReg & ((0x1ul << (16)) | (0x1ul << (18))))
N        return 0;           /* PLL is in power down mode or fix low */
N
N    if(u32PllReg & CLK_PLLCTL_PLLSRC_HIRC)
X    if(u32PllReg & 0x00080000UL)
N        u32FIN = __HIRC;    /* PLL source clock from HIRC */
X        u32FIN = (22118400UL);     
N    else
N        u32FIN = __XTAL;     /* PLL source clock from HXT */
X        u32FIN = (12000000UL);      
N
N    if(u32PllReg & CLK_PLLCTL_BP_Msk)
X    if(u32PllReg & (0x1ul << (17)))
N        return u32FIN;      /* PLL is in bypass mode */
N
N    /* PLL is output enabled in normal work mode */
N    u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
X    u32NO = au8NoTbl[((u32PllReg & (0x3ul << (14))) >> (14))];
N    u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
X    u32NF = ((u32PllReg & (0x1fful << (0))) >> (0)) + 2;
N    u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
X    u32NR = ((u32PllReg & (0x1ful << (9))) >> (9)) + 2;
N
N    /* u32FIN is shifted 2 bits to avoid overflow */
N    u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
N
N    return u32PllFreq;
N}
N
Nvoid CLK_DisableCKO(void);
Nvoid CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En);
Nvoid CLK_PowerDown(void);
Nvoid CLK_Idle(void);
Nuint32_t CLK_GetHXTFreq(void);
Nuint32_t CLK_GetLXTFreq(void);
Nuint32_t CLK_GetHCLKFreq(void);
Nuint32_t CLK_GetCPUFreq(void);
Nuint32_t CLK_SetCoreClock(uint32_t u32Hclk);
Nvoid CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetSysTickClockSrc(uint32_t u32ClkSrc);
Nvoid CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count);
Nvoid CLK_DisableSysTick(void);
Nvoid CLK_EnableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_DisableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_EnableModuleClock(uint32_t u32ModuleIdx);
Nvoid CLK_DisableModuleClock(uint32_t u32ModuleIdx);
Nvoid CLK_SysTickDelay(uint32_t us);
Nuint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq);
Nvoid CLK_DisablePLL(void);
Nuint32_t CLK_WaitClockReady(uint32_t u32ClkMask);
N
N
N
N/*@}*/ /* end of group Mini58_CLK_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group Mini58_CLK_Driver */
N
N/*@}*/ /* end of group Mini58_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__CLK_H__
N
N/*** (C) COPYRIGHT 2015 Nuvoton Technology Corp. ***/
L 11938 "..\Library\Device\Nuvoton\Mini58Series\Include\Mini58Series.h" 2
N#include "acmp.h"
L 1 "..\Library\StdDriver\inc\acmp.h" 1
N/**************************************************************************//**
N * @file     acmp.h
N * @version  V1.00
N * $Revision: 4 $
N * $Date: 15/05/26 5:56p $
N * @brief    Mini58 series Analog Comparator(ACMP) driver header file
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __ACMP_H__
N#define __ACMP_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Mini58_Device_Driver Mini58 Device Driver
N  @{
N*/
N
N/** @addtogroup Mini58_ACMP_Driver ACMP Driver
N  @{
N*/
N
N/** @addtogroup Mini58_ACMP_EXPORTED_CONSTANTS ACMP Exported Constants
N  @{
N*/
N
N
N#define ACMP_VNEG_PIN                  (0xFFUL)                         ///< Selecting the voltage of ACMP negative input pin as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_BANDGAP              (0x00UL)                         ///< Selecting band-gap voltage as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_4_OVER_24_VDD        (0x80UL)                         ///< Selecting 4/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_5_OVER_24_VDD        (0x81UL)                         ///< Selecting 5/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_6_OVER_24_VDD        (0x82UL)                         ///< Selecting 6/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_7_OVER_24_VDD        (0x83UL)                         ///< Selecting 7/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_8_OVER_24_VDD        (0x84UL)                         ///< Selecting 8/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_9_OVER_24_VDD        (0x85UL)                         ///< Selecting 9/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_10_OVER_24_VDD       (0x86UL)                         ///< Selecting 10/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_11_OVER_24_VDD       (0x87UL)                         ///< Selecting 11/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_12_OVER_24_VDD       (0x88UL)                         ///< Selecting 12/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_13_OVER_24_VDD       (0x89UL)                         ///< Selecting 13/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_14_OVER_24_VDD       (0x8AUL)                         ///< Selecting 14/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_15_OVER_24_VDD       (0x8BUL)                         ///< Selecting 15/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_16_OVER_24_VDD       (0x8CUL)                         ///< Selecting 16/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_17_OVER_24_VDD       (0x8DUL)                         ///< Selecting 17/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_18_OVER_24_VDD       (0x8EUL)                         ///< Selecting 18/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_19_OVER_24_VDD       (0x8FUL)                         ///< Selecting 19/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_HYSTERESIS_ENABLE         (1UL << ACMP_CTL_HYSSEL_Pos)     ///< Enable hysteresis function \hideinitializer
N#define ACMP_HYSTERESIS_DISABLE        (0UL)                            ///< Disable hysteresis function \hideinitializer
N#define ACMP_CH0_POSPIN_P15            (0UL)                            ///< Selecting P1.5 as ACMP Channel 0 positive input pin \hideinitializer
N#define ACMP_CH0_POSPIN_P10            (1UL << ACMP_CTL_POSSEL_Pos)     ///< Selecting P1.0 as ACMP Channel 0 positive input pin \hideinitializer
N#define ACMP_CH0_POSPIN_P12            (2UL << ACMP_CTL_POSSEL_Pos)     ///< Selecting P1.2 as ACMP Channel 0 positive input pin \hideinitializer
N#define ACMP_CH0_POSPIN_P13            (3UL << ACMP_CTL_POSSEL_Pos)     ///< Selecting P1.3 as ACMP Channel 0 positive input pin \hideinitializer
N#define ACMP_CH1_POSPIN_P31            (0UL)                            ///< Selecting P3.1 as ACMP Channel 1 positive input pin \hideinitializer
N#define ACMP_CH1_POSPIN_P32            (1UL << ACMP_CTL_POSSEL_Pos)     ///< Selecting P3.2 as ACMP Channel 1 positive input pin \hideinitializer
N#define ACMP_CH1_POSPIN_P34            (2UL << ACMP_CTL_POSSEL_Pos)     ///< Selecting P3.4 as ACMP Channel 1 positive input pin \hideinitializer
N#define ACMP_CH1_POSPIN_P35            (3UL << ACMP_CTL_POSSEL_Pos)     ///< Selecting P3.5 as ACMP Channel 1 positive input pin \hideinitializer
N#define ACMP_FILTSEL_OFF               (0UL)                            ///<  Comparator output filter function is disabled \hideinitializer
N#define ACMP_FILTSEL_1PCLK             (1UL << ACMP_CTL_FILTSEL_Pos)    ///<  Comparator output filter is sampled 1 consecutive PCLK \hideinitializer
N#define ACMP_FILTSEL_2PCLK             (2UL << ACMP_CTL_FILTSEL_Pos)    ///<  Comparator output filter is sampled 2 consecutive PCLKs \hideinitializer
N#define ACMP_FILTSEL_4PCLK             (3UL << ACMP_CTL_FILTSEL_Pos)    ///<  Comparator output filter is sampled 4 consecutive PCLKs \hideinitializer
N#define ACMP_FILTSEL_8PCLK             (4UL << ACMP_CTL_FILTSEL_Pos)    ///<  Comparator output filter is sampled 8 consecutive PCLKs \hideinitializer
N#define ACMP_FILTSEL_16PCLK            (5UL << ACMP_CTL_FILTSEL_Pos)    ///<  Comparator output filter is sampled 16 consecutive PCLKs \hideinitializer
N#define ACMP_FILTSEL_32PCLK            (6UL << ACMP_CTL_FILTSEL_Pos)    ///<  Comparator output filter is sampled 32 consecutive PCLKs \hideinitializer
N#define ACMP_FILTSEL_64PCLK            (7UL << ACMP_CTL_FILTSEL_Pos)    ///<  Comparator output filter is sampled 64 consecutive PCLKs \hideinitializer
N#define ACMP_FILTSEL_128PCLK           (8UL << ACMP_CTL_FILTSEL_Pos)    ///<  Comparator output filter is sampled 128 consecutive PCLKs \hideinitializer
N#define ACMP_FILTSEL_256PCLK           (9UL << ACMP_CTL_FILTSEL_Pos)    ///<  Comparator output filter is sampled 256 consecutive PCLKs \hideinitializer
N#define ACMP_FILTSEL_512PCLK           (10UL << ACMP_CTL_FILTSEL_Pos)   ///<  Comparator output filter is sampled 512 consecutive PCLKs \hideinitializer
N
N/*@}*/ /* end of group Mini58_ACMP_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup Mini58_ACMP_EXPORTED_FUNCTIONS ACMP Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro is used to select ACMP negative input source
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @param[in] u32Src is comparator negative input selection.  Including :
N  *                  - \ref ACMP_VNEG_PIN
N  *                  - \ref ACMP_VNEG_BANDGAP
N  *                  - \ref ACMP_VNEG_4_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_5_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_6_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_7_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_8_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_9_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_10_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_11_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_12_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_13_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_14_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_15_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_16_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_17_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_18_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_19_OVER_24_VDD
N  *
N  * @return None
N  * @note The V- setting is shared by both comparators if input source is not coming from PIN
N  * \hideinitializer
N  */
N#define ACMP_SET_NEG_SRC(acmp, u32ChNum, u32Src) do{\
N                                                     if(u32Src == ACMP_VNEG_PIN)\
N                                                         ACMP->CTL[u32ChNum] &= ~ACMP_CTL_NEGSEL_Msk;\
N                                                     else {\
N                                                         ACMP->CTL[u32ChNum] |= ACMP_CTL_NEGSEL_Msk;\
N                                                         ACMP->VREF = u32Src;\
N                                                     }\
N                                                 }while(0)
X#define ACMP_SET_NEG_SRC(acmp, u32ChNum, u32Src) do{                                                     if(u32Src == ACMP_VNEG_PIN)                                                         ACMP->CTL[u32ChNum] &= ~ACMP_CTL_NEGSEL_Msk;                                                     else {                                                         ACMP->CTL[u32ChNum] |= ACMP_CTL_NEGSEL_Msk;                                                         ACMP->VREF = u32Src;                                                     }                                                 }while(0)
N
N/**
N  * @brief This macro is used to enable hysteresis function
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return None
N  * \hideinitializer
N  */
N#define ACMP_ENABLE_HYSTERESIS(acmp, u32ChNum) (ACMP->CTL[u32ChNum] |= ACMP_CTL_HYSSEL_Msk)
N
N/**
N  * @brief This macro is used to disable hysteresis function
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return None
N  * \hideinitializer
N  */
N#define ACMP_DISABLE_HYSTERESIS(acmp, u32ChNum) (ACMP->CTL[u32ChNum] &= ~ACMP_CTL_HYSSEL_Msk)
N
N/**
N  * @brief This macro is used to enable interrupt
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return None
N  * \hideinitializer
N  */
N#define ACMP_ENABLE_INT(acmp, u32ChNum) (ACMP->CTL[u32ChNum] |= ACMP_CTL_ACMPIE_Msk)
N
N/**
N  * @brief This macro is used to disable interrupt
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return None
N  * \hideinitializer
N  */
N#define ACMP_DISABLE_INT(acmp, u32ChNum) (ACMP->CTL[u32ChNum] &= ~ACMP_CTL_ACMPIE_Msk)
N
N
N/**
N  * @brief This macro is used to enable ACMP
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * \hideinitializer
N  */
N#define ACMP_ENABLE(acmp, u32ChNum) (ACMP->CTL[u32ChNum] |= ACMP_CTL_ACMPEN_Msk)
N
N/**
N  * @brief This macro is used to disable ACMP
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return None
N  * \hideinitializer
N  */
N#define ACMP_DISABLE(acmp, u32ChNum) (ACMP->CTL[u32ChNum] &= ~ACMP_CTL_ACMPEN_Msk)
N
N/**
N  * @brief This macro is used to get ACMP output value
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return  1 or 0
N  * \hideinitializer
N  */
N#define ACMP_GET_OUTPUT(acmp, u32ChNum) (ACMP->STATUS & (ACMP_STATUS_ACMPO0_Msk<<(u32ChNum))?1:0)
N
N/**
N  * @brief This macro is used to get ACMP interrupt flag
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return   ACMP interrupt occurred or not
N  * \hideinitializer
N  */
N#define ACMP_GET_INT_FLAG(acmp, u32ChNum) (ACMP->STATUS & (ACMP_STATUS_ACMPIF0_Msk<<(u32ChNum))?1:0)
N
N/**
N  * @brief This macro is used to clear ACMP interrupt flag
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return   None
N  * \hideinitializer
N  */
N#define ACMP_CLR_INT_FLAG(acmp, u32ChNum) (ACMP->STATUS = (ACMP_STATUS_ACMPIF0_Msk<<(u32ChNum)))
N
N/**
N  * @brief This macro is used to select the V+ pin of ACMP
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @param[in] u32Pin The input pin. For channel 0, valid values are \ref ACMP_CH0_POSPIN_P15,
N  *            \ref ACMP_CH0_POSPIN_P10, \ref ACMP_CH0_POSPIN_P12, and \ref ACMP_CH0_POSPIN_P13. For
N  *            channel 1, valid values are , \ref ACMP_CH1_POSPIN_P31, \ref ACMP_CH1_POSPIN_P32,
N  *            \ref ACMP_CH1_POSPIN_P34, and \ref ACMP_CH1_POSPIN_P35.
N  * @return   None
N  * @note   Except this setting, multi-function pin also needs to be configured
N  * \hideinitializer
N  */
N#define ACMP_SELECT_P(acmp, u32ChNum, u32Pin)  (ACMP->CTL[u32ChNum] = (ACMP->CTL[u32ChNum] & ~ACMP_CTL_POSSEL_Msk) | (u32Pin))
N/**
N  * @brief This macro is used to set the level of CRV(Comparator Reference Voltage)
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32Level CRV level, possible values are
N  *                  - \ref ACMP_VNEG_4_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_5_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_6_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_7_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_8_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_9_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_10_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_11_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_12_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_13_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_14_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_15_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_16_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_17_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_18_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_19_OVER_24_VDD
N  * @return   None
N  * \hideinitializer
N  */
N#define ACMP_CRV_SEL(acmp, u32Level) (ACMP->VREF = (ACMP->VREF & ~ACMP_VREF_CRVCTL_Msk) | ((u32Level) & ~ACMP_VREF_IREFSEL_Msk))
N/**
N  * @brief This macro is used to enable CRV(Comparator Reference Voltage)
N  * @param[in] acmp The base address of ACMP module
N  * @return   None
N  * \hideinitializer
N  */
N#define ACMP_ENABLE_CRV(acmp) (ACMP->VREF |= ACMP_VREF_IREFSEL_Msk)
N/**
N  * @brief This macro is used to disable CRV(Comparator Reference Voltage)
N  * @param[in] acmp The base address of ACMP module
N  * @return   None
N  * \hideinitializer
N  */
N#define ACMP_DISABLE_CRV(acmp) (ACMP->VREF &= ~ACMP_VREF_IREFSEL_Msk)
N
N/**
N  * @brief This macro is used to enable ACMP falling edge trigger Timer/PWM
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return   None
N  * \hideinitializer
N  */
N#define ACMP_ENABLE_FALLING_EDGE_TRIGGER(acmp, u32ChNum) (ACMP->CTL[u32ChNum] |= ACMP_CTL_FTRGEN_Msk)
N
N/**
N  * @brief This macro is used to disable ACMP falling edge trigger Timer/PWM
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return   None
N  * \hideinitializer
N  */
N#define ACMP_DISABLE_FALLING_EDGE_TRIGGER(acmp, u32ChNum) (ACMP->CTL[u32ChNum] &= ~ACMP_CTL_FTRGEN_Msk)
N
N/**
N  * @brief This macro is used to enable ACMP rising edge trigger Timer/PWM
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return   None
N  * \hideinitializer
N  */
N#define ACMP_ENABLE_RISING_EDGE_TRIGGER(acmp, u32ChNum) (ACMP->CTL[u32ChNum] |= ACMP_CTL_RTRGEN_Msk)
N
N/**
N  * @brief This macro is used to disable ACMP rising edge trigger Timer/PWM
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return   None
N  * \hideinitializer
N  */
N#define ACMP_DISABLE_RISING_EDGE_TRIGGER(acmp, u32ChNum) (ACMP->CTL[u32ChNum] &= ~ACMP_CTL_RTRGEN_Msk)
N
N/**
N  * @brief This macro is used to set ACMP filter function
N  * @param[in] acmp The pointer of the specified ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @param[in] u32Cnt is comparator filter count setting.
N  *                  - \ref ACMP_FILTSEL_OFF
N  *                  - \ref ACMP_FILTSEL_1PCLK
N  *                  - \ref ACMP_FILTSEL_2PCLK
N  *                  - \ref ACMP_FILTSEL_4PCLK
N  *                  - \ref ACMP_FILTSEL_8PCLK
N  *                  - \ref ACMP_FILTSEL_16PCLK
N  *                  - \ref ACMP_FILTSEL_32PCLK
N  *                  - \ref ACMP_FILTSEL_64PCLK
N  *                  - \ref ACMP_FILTSEL_128PCLK
N  *                  - \ref ACMP_FILTSEL_256PCLK
N  *                  - \ref ACMP_FILTSEL_512PCLK
N  * @return None
N  * \hideinitializer
N  */
N#define ACMP_SET_FILTER(acmp, u32ChNum, u32Cnt) ((acmp)->CTL[(u32ChNum)] = ((acmp)->CTL[u32ChNum] & ~ACMP_CTL_FILTSEL_Msk) | (u32Cnt))
N
Nvoid ACMP_Open(ACMP_T *acmp, uint32_t u32ChNum, uint32_t u32NegSrc, uint32_t u32HysteresisEn);
Nvoid ACMP_Close(ACMP_T *acmp, uint32_t u32ChNum);
N
N/*@}*/ /* end of group Mini58_ACMP_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group Mini58_ACMP_Driver */
N
N/*@}*/ /* end of group Mini58_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__ACMP_H__
N
N/*** (C) COPYRIGHT 2015 Nuvoton Technology Corp. ***/
L 11939 "..\Library\Device\Nuvoton\Mini58Series\Include\Mini58Series.h" 2
N#include "adc.h"
L 1 "..\Library\StdDriver\inc\adc.h" 1
N/**************************************************************************//**
N * @file     adc.h
N * @version  V1.00
N * $Revision: 3 $
N * $Date: 15/06/03 9:34p $ 
N * @brief    Mini58 series ADC driver header file
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __ADC_H__
N#define __ADC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Mini58_Device_Driver Mini58 Device Driver
N  @{
N*/
N
N/** @addtogroup Mini58_ADC_Driver ADC Driver
N  @{
N*/
N
N/** @addtogroup Mini58_ADC_EXPORTED_CONSTANTS ADC Exported Constants
N  @{
N*/
N
N#define ADC_CH7_EXT                     (0UL)                       		/*!< Use external input pin as ADC channel 7 source */
N#define ADC_CH7_BGP                     (ADC_CHEN_CH7SEL_Msk)       		/*!< Use internal band-gap voltage (VBG) as channel 7 source. */
N#define ADC_CMP0_LESS_THAN               (0UL << ADC_CMP0_CMPCOND_Pos)	/*!< ADC compare condition less than */
N#define ADC_CMP1_LESS_THAN               (0UL << ADC_CMP1_CMPCOND_Pos)	/*!< ADC compare condition less than */
N#define ADC_CMP0_GREATER_OR_EQUAL_TO     (1ul << ADC_CMP0_CMPCOND_Pos)	/*!< ADC compare condition greater or equal to */
N#define ADC_CMP1_GREATER_OR_EQUAL_TO     (1ul << ADC_CMP1_CMPCOND_Pos)	/*!< ADC compare condition greater or equal to */
N#define ADC_TRIGGER_BY_EXT_PIN          (0UL)                       		/*!< ADC trigger by STADC (P3.2) pin */
N#define ADC_TRIGGER_BY_PWM              (ADC_CTL_HWTRGSEL_Msk)      		/*!< ADC trigger by PWM events */
N#define ADC_FALLING_EDGE_TRIGGER        (0UL)                       		/*!< External pin falling edge trigger ADC */
N#define ADC_RISING_EDGE_TRIGGER         (ADC_CTL_HWTRGCOND_Msk)     		/*!< External pin rising edge trigger ADC */
N#define ADC_ADIF_INT                    (ADC_STATUS_ADIF_Msk)       		/*!< ADC convert complete interrupt */
N#define ADC_CMP0_INT                    (ADC_STATUS_ADCMPF0_Msk)    		/*!< ADC comparator 0 interrupt */
N#define ADC_CMP1_INT                    (ADC_STATUS_ADCMPF1_Msk)    		/*!< ADC comparator 0 interrupt */
N#define ADC_SAMPLE_CLOCK_0              (0UL)                       		/*!< ADC sample time is 0 ADC clock */
N#define ADC_SAMPLE_CLOCK_1              (1UL)                       		/*!< ADC sample time is 1 ADC clock */
N#define ADC_SAMPLE_CLOCK_2              (2UL)                       		/*!< ADC sample time is 2 ADC clock */
N#define ADC_SAMPLE_CLOCK_4              (3UL)                       		/*!< ADC sample time is 4 ADC clock */
N#define ADC_SAMPLE_CLOCK_8              (4UL)                       		/*!< ADC sample time is 8 ADC clock */
N#define ADC_SAMPLE_CLOCK_16             (5UL)                       		/*!< ADC sample time is 16 ADC clock */
N#define ADC_SAMPLE_CLOCK_32             (6UL)                       		/*!< ADC sample time is 32 ADC clock */
N#define ADC_SAMPLE_CLOCK_64             (7UL)                       		/*!< ADC sample time is 64 ADC clock */
N#define ADC_SAMPLE_CLOCK_128            (8UL)                       		/*!< ADC sample time is 128 ADC clock */
N#define ADC_SAMPLE_CLOCK_256            (9UL)                       		/*!< ADC sample time is 256 ADC clock */
N#define ADC_SAMPLE_CLOCK_512            (10UL)                      		/*!< ADC sample time is 512 ADC clock */
N#define ADC_SAMPLE_CLOCK_1024           (11UL)                      		/*!< ADC sample time is 1024 ADC clock */
N#define ADC_SEQMODE_TYPE_23SHUNT        (0UL)                       		/*!< ADC sequential mode 23-shunt type */
N#define ADC_SEQMODE_TYPE_1SHUNT         (1UL)                       		/*!< ADC sequential mode 1-shunt type */
N#define ADC_SEQMODE_MODESELECT_CH01     (0UL)                       		/*!< ADC channel 0 then channel 1 conversion */
N#define ADC_SEQMODE_MODESELECT_CH12     (1UL)                       		/*!< ADC channel 1 then channel 2 conversion */
N#define ADC_SEQMODE_MODESELECT_CH02     (2UL)                       		/*!< ADC channel 0 then channel 2 conversion */
N#define ADC_SEQMODE_PWM0_RISING		      (0UL)                       		/*!< ADC sequential mode PWM0 rising trigger ADC*/
N#define ADC_SEQMODE_PWM0_CENTER		      (1UL)                       		/*!< ADC sequential mode PWM0 center trigger ADC*/
N#define ADC_SEQMODE_PWM0_FALLING	      (2UL)                       		/*!< ADC sequential mode PWM0 falling trigger ADC*/
N#define ADC_SEQMODE_PWM0_PERIOD 	      (3UL)                       		/*!< ADC sequential mode PWM0 period trigger ADC*/
N#define ADC_SEQMODE_PWM2_RISING		      (4UL)                       		/*!< ADC sequential mode PWM2 rising trigger ADC*/
N#define ADC_SEQMODE_PWM2_CENTER		      (5UL)                       		/*!< ADC sequential mode PWM2 center trigger ADC*/
N#define ADC_SEQMODE_PWM2_FALLING	      (6UL)                       		/*!< ADC sequential mode PWM2 falling trigger ADC*/
N#define ADC_SEQMODE_PWM2_PERIOD 	      (7UL)                       		/*!< ADC sequential mode PWM2 period trigger ADC*/
N#define ADC_SEQMODE_PWM4_RISING		      (8UL)                       		/*!< ADC sequential mode PWM4 rising trigger ADC*/
N#define ADC_SEQMODE_PWM4_CENTER		      (9UL)                       		/*!< ADC sequential mode PWM4 center trigger ADC*/
N#define ADC_SEQMODE_PWM4_FALLING	      (10UL)                       		/*!< ADC sequential mode PWM4 falling trigger ADC*/
N#define ADC_SEQMODE_PWM4_PERIOD 	      (11UL)                       		/*!< ADC sequential mode PWM4 period trigger ADC*/
N/*@}*/ /* end of group Mini58_ADC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup Mini58_ADC_EXPORTED_FUNCTIONS ADC Exported Functions
N  @{
N*/
N
N
N/**
N  * @brief Configure the analog input source of channel 7
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32Source Decides the analog input source of channel 7, valid values are
N  *                     - \ref ADC_CH7_EXT
N  *                     - \ref ADC_CH7_BGP
N  * @return None
N  * @note While using VBG as channel 7 source, ADC module clock must /b not exceed 300kHz 
N  * \hideinitializer
N  */
N#define ADC_CONFIG_CH7(adc, u32Source) (ADC->CHEN = ((adc)->CHEN & ~ADC_CHEN_CH7SEL_Msk) | (u32Source))
N
N/**
N  * @brief Get the latest ADC conversion data
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum Currently not used
N  * @return  Latest ADC conversion data
N  * \hideinitializer
N  */
N#define ADC_GET_CONVERSION_DATA(adc, u32ChNum) ((adc)->DAT & ADC_DAT_RESULT_Msk)
N
N/**
N  * @brief Return the user-specified interrupt flags
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32Mask The combination of following interrupt status bits. Each bit corresponds to a interrupt status.
N  *                     - \ref ADC_ADIF_INT
N  *                     - \ref ADC_CMP0_INT
N  *                     - \ref ADC_CMP1_INT
N  * @return  User specified interrupt flags
N  * \hideinitializer
N  */
N#define ADC_GET_INT_FLAG(adc, u32Mask) ((adc)->STATUS & (u32Mask))
N
N/**
N  * @brief This macro clear the selected interrupt status bits
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32Mask The combination of following interrupt status bits. Each bit corresponds to a interrupt status.
N  *                     - \ref ADC_ADIF_INT
N  *                     - \ref ADC_CMP0_INT
N  *                     - \ref ADC_CMP1_INT
N  * @return  None
N  * \hideinitializer
N  */
N#define ADC_CLR_INT_FLAG(adc, u32Mask) ((adc)->STATUS = ((adc)->STATUS & ~(ADC_STATUS_ADIF_Msk | \
N                                                                       ADC_STATUS_ADCMPF0_Msk | \
N                                                                       ADC_STATUS_ADCMPF1_Msk)) | (u32Mask))
X#define ADC_CLR_INT_FLAG(adc, u32Mask) ((adc)->STATUS = ((adc)->STATUS & ~(ADC_STATUS_ADIF_Msk |                                                                        ADC_STATUS_ADCMPF0_Msk |                                                                        ADC_STATUS_ADCMPF1_Msk)) | (u32Mask))
N
N/**
N  * @brief Get the busy state of ADC
N  * @param[in] adc Base address of ADC module
N  * @return busy state of ADC
N  * @retval 0 ADC is not busy
N  * @retval 1 ADC is busy
N  * \hideinitializer
N  */
N#define ADC_IS_BUSY(adc) ((adc)->STATUS & ADC_STATUS_BUSY_Msk ? 1 : 0)
N     
N/**
N  * @brief Check if the ADC conversion data is over written or not
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum Currently not used
N  * @return Over run state of ADC data
N  * @retval 0 ADC data is not overrun
N  * @retval 1 ADC data is overrun
N  * \hideinitializer
N  */     
N#define ADC_IS_DATA_OVERRUN(adc, u32ChNum) ((adc)->STATUS & ADC_STATUS_OV_Msk ? 1 : 0)
N
N/**
N  * @brief Check if the ADC conversion data is valid or not
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum Currently not used
N  * @return Valid state of ADC data
N  * @retval 0 ADC data is not valid
N  * @retval 1 ADC data us valid
N  * \hideinitializer
N  */  
N#define ADC_IS_DATA_VALID(adc, u32ChNum) ((adc)->STATUS & ADC_STATUS_VALID_Msk ? 1 : 0)
N
N/**
N  * @brief Power down ADC module
N  * @param[in] adc Base address of ADC module
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_POWER_DOWN(adc) ((adc)->CTL &= ~ADC_CTL_ADCEN_Msk)
N
N/**
N  * @brief Power on ADC module
N  * @param[in] adc Base address of ADC module
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_POWER_ON(adc) ((adc)->CTL |= ADC_CTL_ADCEN_Msk)                                                        
N
N/**
N  * @brief Configure the comparator 0 and enable it
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum  Specifies the source channel, valid value are from 0 to 7
N  * @param[in] u32Condition Specifies the compare condition
N  *                     - \ref ADC_CMP0_LESS_THAN
N  *                     - \ref ADC_CMP0_GREATER_OR_EQUAL_TO
N  * @param[in] u32Data Specifies the compare value. Valid value are between 0 ~ 0x3FF
N  * @param[in] u32MatchCount Specifies the match count setting, valid values are between 1~16
N  * @return None
N  * @details For example, ADC_ENABLE_CMP0(ADC, 5, ADC_CMP_GREATER_OR_EQUAL_TO, 0x800, 10);
N  *          Means ADC will assert comparator 0 flag if channel 5 conversion result is 
N  *          greater or equal to 0x800 for 10 times continuously.
N  * \hideinitializer
N  */ 
N#define ADC_ENABLE_CMP0(adc, \
N                        u32ChNum, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) (ADC->CMP0 = ((u32ChNum) << ADC_CMP0_CMPCH_Pos) | \
N                                                                   (u32Condition) | \
N                                                                   ((u32Data) << ADC_CMP0_CMPDAT_Pos) | \
N                                                                   (((u32MatchCount) - 1) << ADC_CMP0_CMPMCNT_Pos) |\
N																																	 ADC_CMP0_ADCMPIE_Msk |\
N                                                                   ADC_CMP0_ADCMPEN_Msk) 
X#define ADC_ENABLE_CMP0(adc,                         u32ChNum,                         u32Condition,                         u32Data,                         u32MatchCount) (ADC->CMP0 = ((u32ChNum) << ADC_CMP0_CMPCH_Pos) |                                                                    (u32Condition) |                                                                    ((u32Data) << ADC_CMP0_CMPDAT_Pos) |                                                                    (((u32MatchCount) - 1) << ADC_CMP0_CMPMCNT_Pos) |																																	 ADC_CMP0_ADCMPIE_Msk |                                                                   ADC_CMP0_ADCMPEN_Msk) 
N																																	 
N/**
N  * @brief Disable comparator 0
N  * @param[in] adc Base address of ADC module
N  * \hideinitializer
N  */  
N#define ADC_DISABLE_CMP0(adc) ((adc)->CMP0 = 0)              
N
N/**
N  * @brief Configure the comparator 1 and enable it
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum  Specifies the source channel, valid value are from 0 to 7
N  * @param[in] u32Condition Specifies the compare condition
N  *                     - \ref ADC_CMP1_LESS_THAN
N  *                     - \ref ADC_CMP1_GREATER_OR_EQUAL_TO
N  * @param[in] u32Data Specifies the compare value. Valid value are between 0 ~ 0x3FF
N  * @param[in] u32MatchCount Specifies the match count setting, valid values are between 1~16
N  * @return None
N  * @details For example, ADC_ENABLE_CMP1(ADC, 5, ADC_CMP1_GREATER_OR_EQUAL_TO, 0x800, 10);
N  *          Means ADC will assert comparator 1 flag if channel 5 conversion result is 
N  *          greater or equal to 0x800 for 10 times continuously.
N  * \hideinitializer
N  */                     
N#define ADC_ENABLE_CMP1(adc, \
N                        u32ChNum, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) (ADC->CMP1 = ((u32ChNum) << ADC_CMP1_CMPCH_Pos) | \
N                                                                   (u32Condition) | \
N                                                                   ((u32Data) << ADC_CMP1_CMPDAT_Pos) | \
N                                                                   ((u32MatchCount - 1) << ADC_CMP1_CMPMCNT_Pos) |\
N                                                                   ADC_CMP1_ADCMPEN_Msk)  
X#define ADC_ENABLE_CMP1(adc,                         u32ChNum,                         u32Condition,                         u32Data,                         u32MatchCount) (ADC->CMP1 = ((u32ChNum) << ADC_CMP1_CMPCH_Pos) |                                                                    (u32Condition) |                                                                    ((u32Data) << ADC_CMP1_CMPDAT_Pos) |                                                                    ((u32MatchCount - 1) << ADC_CMP1_CMPMCNT_Pos) |                                                                   ADC_CMP1_ADCMPEN_Msk)  
N
N/**
N  * @brief Disable comparator 1
N  * @param[in] adc Base address of ADC module
N  * \hideinitializer
N  */                          
N#define ADC_DISABLE_CMP1(adc) ((adc)->CMP1 = 0)
N
N/**
N  * @brief Set ADC input channel. Enabled channel will be converted while ADC starts.
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32Mask  Channel enable bit. Each bit corresponds to a input channel. Bit 0 is channel 0, bit 1 is channel 1...
N  * @return None
N  * @note Mini58 series MCU ADC can only convert 1 channel at a time. If more than 1 channels are enabled, only channel
N  *       with smallest number will be convert.
N  * \hideinitializer
N  */   
N#define ADC_SET_INPUT_CHANNEL(adc, u32Mask) ((adc)->CHEN = (ADC->CHEN & ~ADC_CHEN_CHEN0_Msk) | (u32Mask))
N
N/**
N  * @brief Start the A/D conversion.
N  * @param[in] adc Base address of ADC module
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_START_CONV(adc) ((adc)->CTL |= ADC_CTL_SWTRG_Msk)
N
N/**
N  * @brief Stop the A/D conversion.
N  * @param[in] adc Base address of ADC module
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_STOP_CONV(adc) ((adc)->CTL &= ~ADC_CTL_SWTRG_Msk)
N
Nvoid ADC_Open(ADC_T *adc,
N               uint32_t u32InputMode, 
N               uint32_t u32OpMode,  
N               uint32_t u32ChMask);
Nvoid ADC_Close(ADC_T *adc);
Nvoid ADC_EnableHWTrigger(ADC_T *adc,
N                         uint32_t u32Source,
N                         uint32_t u32Param);
Nvoid ADC_DisableHWTrigger(ADC_T *adc);
Nvoid ADC_SetExtraSampleTime(ADC_T *adc,
N                            uint32_t u32ChNum,
N                            uint32_t u32SampleTime);
Nvoid ADC_EnableInt(ADC_T *adc, uint32_t u32Mask);
Nvoid ADC_DisableInt(ADC_T *adc, uint32_t u32Mask);
N                   
Nvoid ADC_SeqModeEnable(ADC_T *adc, uint32_t u32SeqTYPE, uint32_t u32ModeSel);
Nvoid ADC_SeqModeTriggerSrc(ADC_T *adc, uint32_t u32SeqModeTriSrc1, uint32_t u32SeqModeTriSrc2);
N
N/*@}*/ /* end of group Mini58_ADC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group Mini58_ADC_Driver */
N
N/*@}*/ /* end of group Mini58_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__ADC_H__
N
N/*** (C) COPYRIGHT 2015 Nuvoton Technology Corp. ***/
L 11940 "..\Library\Device\Nuvoton\Mini58Series\Include\Mini58Series.h" 2
N#include "fmc.h"
L 1 "..\Library\StdDriver\inc\fmc.h" 1
N/**************************************************************************//**
N * @file     FMC.h
N * @version  V1.00
N * $Revision: 5 $
N * $Date: 15/05/26 12:39p $
N * @brief    Mini58 series FMC driver header file
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N#ifndef __FMC_H__
N#define __FMC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N    
N/** @addtogroup Mini58_Device_Driver Mini58 Device Driver
N  @{
N*/
N
N/** @addtogroup Mini58_FMC_Driver FMC Driver
N  @{
N*/
N
N/** @addtogroup Mini58_FMC_EXPORTED_CONSTANTS FMC Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Base Address                                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_APROM_BASE          0x00000000UL    /*!< APROM  Base Address         */  
N#define FMC_APROM_END           0x00008000UL    /*!< APROM  End Address          */  
N#define FMC_LDROM_BASE          0x00100000UL    /*!< LDROM  Base Address         */
N#define FMC_LDROM_END           0x00100A00UL    /*!< LDROM  End Address          */
N#define FMC_SPROM_BASE          0x00200000UL    /*!< SPROM  Base Address         */
N#define FMC_SPROM_END           0x00200200UL    /*!< SPROM  End Address          */
N#define FMC_CONFIG_BASE         0x00300000UL    /*!< CONFIG Base Address         */
N
N#define FMC_FLASH_PAGE_SIZE     0x200           /*!< Flash Page Size (512 Bytes) */
N#define FMC_LDROM_SIZE          0xA00           /*!< LDROM Size (2 Kbytes)       */
N#define FMC_SPROM_SIZE          0x200           /*!< SPROM Size (512 bytes)      */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCMD constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCMD_READ         0x00            /*!< ISP Command: Read Flash                     */
N#define FMC_ISPCMD_READ_UID     0x04            /*!< ISP Command: Read Unique ID                 */
N#define FMC_ISPCMD_READ_CID     0x0B            /*!< ISP Command: Read Company ID                */
N#define FMC_ISPCMD_READ_PID     0x0C            /*!< ISP Command: Read Product ID                */
N#define FMC_ISPCMD_READ_CRC32   0x0D            /*!< ISP Command: Read CRC32 checksum            */
N#define FMC_ISPCMD_PROGRAM      0x21            /*!< ISP Command: Program Flash                  */
N#define FMC_ISPCMD_PAGE_ERASE   0x22            /*!< ISP Command: Page Erase Flash               */
N#define FMC_ISPCMD_CAL_CRC32    0x2D            /*!< ISP Command: Run CRC32 checksum calculation */
N#define FMC_ISPCMD_VECMAP       0x2E            /*!< ISP Command: Vector Page Remap              */
N
N
N/*@}*/ /* end of group Mini58_FMC_EXPORTED_CONSTANTS */
N
N/** @addtogroup Mini58_FMC_EXPORTED_FUNCTIONS FMC Exported Functions
N  @{
N*/
N
N#define FMC_SET_APROM_BOOT()        (FMC->ISPCTL &= ~FMC_ISPCTL_BS_Msk)         /*!< Select booting from APROM  */
N#define FMC_SET_LDROM_BOOT()        (FMC->ISPCTL |= FMC_ISPCTL_BS_Msk)          /*!< Select booting from LDROM  */
N#define FMC_DISABLE_AP_UPDATE()     (FMC->ISPCTL &= ~FMC_ISPCTL_APUEN_Msk)      /*!< Disable APROM update  */
N#define FMC_DISABLE_SP_UPDATE()     (FMC->ISPCTL &= ~FMC_ISPCTL_SPUEN_Msk)      /*!< Disable SPROM update  */
N#define FMC_DISABLE_CFG_UPDATE()    (FMC->ISPCTL &= ~FMC_ISPCTL_CFGUEN_Msk)     /*!< Disable User Config update  */
N#define FMC_DISABLE_LD_UPDATE()     (FMC->ISPCTL &= ~FMC_ISPCTL_LDUEN_Msk)      /*!< Disable LDROM update  */
N#define FMC_DISABLE_ISP()           (FMC->ISPCTL &= ~FMC_ISPCTL_ISPEN_Msk)      /*!< Disable ISP function  */
N#define FMC_ENABLE_AP_UPDATE()      (FMC->ISPCTL |=  FMC_ISPCTL_APUEN_Msk)      /*!< Enable APROM update  */
N#define FMC_ENABLE_SP_UPDATE()      (FMC->ISPCTL |=  FMC_ISPCTL_SPUEN_Msk)      /*!< Enable SPROM update  */
N#define FMC_ENABLE_LD_UPDATE()      (FMC->ISPCTL |=  FMC_ISPCTL_LDUEN_Msk)      /*!< Enable LDROM update  */
N#define FMC_ENABLE_CFG_UPDATE()     (FMC->ISPCTL |=  FMC_ISPCTL_CFGUEN_Msk)     /*!< Enable User Config update  */
N#define FMC_ENABLE_ISP()            (FMC->ISPCTL |=  FMC_ISPCTL_ISPEN_Msk)      /*!< Enable ISP function  */
N#define FMC_GET_FAIL_FLAG()         ((FMC->ISPCTL & FMC_ISPCTL_ISPFF_Msk) ? 1 : 0)  /*!< Get ISP fail flag  */
N
N
Nextern void FMC_Close(void);
Nextern int32_t FMC_Erase(uint32_t u32PageAddr);
Nextern int32_t FMC_GetBootSource(void);
Nextern void FMC_Open(void);
Nextern uint32_t FMC_Read (uint32_t u32Addr);
Nextern uint32_t FMC_ReadCID(void);
Nextern uint32_t FMC_ReadPID(void);
Nextern uint32_t FMC_ReadUCID(uint32_t u32Index);
Nextern uint32_t FMC_ReadUID(uint32_t u32Index);
Nextern uint32_t FMC_ReadDataFlashBaseAddr(void);
Nextern void FMC_SetVectorPageAddr(uint32_t u32PageAddr);
Nextern uint32_t FMC_GetVectorPageAddr(void);
Nextern void FMC_Write(uint32_t u32Addr, uint32_t u32Data);
Nextern int32_t FMC_ReadConfig(uint32_t *u32Config, uint32_t u32Count);
Nextern int32_t FMC_WriteConfig(uint32_t *u32Config, uint32_t u32Count);
Nextern int32_t FMC_GetCRC32Sum(uint32_t addr, uint32_t count, uint32_t *chksum);
N
N
N/*@}*/ /* end of group Mini58_FMC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group Mini58_FMC_Driver */
N
N/*@}*/ /* end of group Mini58_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif
N
L 11941 "..\Library\Device\Nuvoton\Mini58Series\Include\Mini58Series.h" 2
N#include "gpio.h"
L 1 "..\Library\StdDriver\inc\gpio.h" 1
N/**************************************************************************//**
N * @file     gpio.h
N * @version  V1.00
N * $Revision: 3 $
N * $Date: 15/06/11 4:13p $ 
N * @brief    Mini58 series GPIO driver header file
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __GPIO_H__
N#define __GPIO_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Mini58_Device_Driver Mini58 Device Driver
N  @{
N*/
N
N/** @addtogroup Mini58_GPIO_Driver GPIO Driver
N  @{
N*/
N
N/** @addtogroup Mini58_GPIO_EXPORTED_CONSTANTS GPIO Exported Constants
N  @{
N*/
N#define GPIO_PIN_MAX    8   /*!< Specify Maximum Pins of Each GPIO Port */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  MODE Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_MODE_INPUT              0x0UL                  /*!< Input Mode */
N#define GPIO_MODE_OUTPUT             0x1UL                  /*!< Output Mode */
N#define GPIO_MODE_OPEN_DRAIN         0x2UL                  /*!< Open-Drain Mode */
N#define GPIO_MODE_QUASI              0x3UL                  /*!< Quasi-bidirectional Mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO Interrupt Type Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INT_RISING             0x00010000UL /*!< Interrupt enable by Input Rising Edge */
N#define GPIO_INT_FALLING            0x00000001UL /*!< Interrupt enable by Input Falling Edge */
N#define GPIO_INT_BOTH_EDGE          0x00010001UL /*!< Interrupt enable by both Rising Edge and Falling Edge */
N#define GPIO_INT_HIGH               0x01010000UL /*!< Interrupt enable by Level-High */    
N#define GPIO_INT_LOW                0x01000001UL /*!< Interrupt enable by Level-Level */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  IMD Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INTTYPE_EDGE               0UL               /*!< INTTYPE Setting for Edge Trigger Mode */
N#define GPIO_INTTYPE_LEVEL              1UL               /*!< INTTYPE Setting for Edge Level Mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  DBNCECON Constant Definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_DBCTL_ICLK_ON           0x00000020UL /*!< DBCTL setting for all IO pins edge detection circuit is always active after reset */ 
N#define GPIO_DBCTL_ICLK_OFF          0x00000000UL /*!< DBCTL setting for edge detection circuit is active only if IO pin corresponding GPIOx_IEN bit is set to 1 */ 
N
N#define GPIO_DBCTL_DBCLKSRC_IRC10K   0x00000010UL /*!< DBCTL setting for de-bounce counter clock source is the internal 10 kHz */ 
N#define GPIO_DBCTL_DBCLKSRC_HCLK     0x00000000UL /*!< DBCTL setting for de-bounce counter clock source is the internal HCLK */ 
N
N#define GPIO_DBCTL_DBCLKSEL_1        0x00000000UL /*!< DBCTL setting for sampling cycle = 1 clocks */
N#define GPIO_DBCTL_DBCLKSEL_2        0x00000001UL /*!< DBCTL setting for sampling cycle = 2 clocks */
N#define GPIO_DBCTL_DBCLKSEL_4        0x00000002UL /*!< DBCTL setting for sampling cycle = 4 clocks */
N#define GPIO_DBCTL_DBCLKSEL_8        0x00000003UL /*!< DBCTL setting for sampling cycle = 8 clocks */
N#define GPIO_DBCTL_DBCLKSEL_16       0x00000004UL /*!< DBCTL setting for sampling cycle = 16 clocks */
N#define GPIO_DBCTL_DBCLKSEL_32       0x00000005UL /*!< DBCTL setting for sampling cycle = 32 clocks */
N#define GPIO_DBCTL_DBCLKSEL_64       0x00000006UL /*!< DBCTL setting for sampling cycle = 64 clocks */
N#define GPIO_DBCTL_DBCLKSEL_128      0x00000007UL /*!< DBCTL setting for sampling cycle = 128 clocks */
N#define GPIO_DBCTL_DBCLKSEL_256      0x00000008UL /*!< DBCTL setting for sampling cycle = 256 clocks */
N#define GPIO_DBCTL_DBCLKSEL_512      0x00000009UL /*!< DBCTL setting for sampling cycle = 512 clocks */
N#define GPIO_DBCTL_DBCLKSEL_1024     0x0000000AUL /*!< DBCTL setting for sampling cycle = 1024 clocks */
N#define GPIO_DBCTL_DBCLKSEL_2048     0x0000000BUL /*!< DBCTL setting for sampling cycle = 2048 clocks */
N#define GPIO_DBCTL_DBCLKSEL_4096     0x0000000CUL /*!< DBCTL setting for sampling cycle = 4096 clocks */
N#define GPIO_DBCTL_DBCLKSEL_8192     0x0000000DUL /*!< DBCTL setting for sampling cycle = 8192 clocks */
N#define GPIO_DBCTL_DBCLKSEL_16384    0x0000000EUL /*!< DBCTL setting for sampling cycle = 16384 clocks */
N#define GPIO_DBCTL_DBCLKSEL_32768    0x0000000FUL /*!< DBCTL setting for sampling cycle = 32768 clocks */
N
N/** Define GPIO Pin Data Input/Output. It could be used to control each I/O pin by pin address mapping.
N *  Example 1:
N *  
N *      P00 = 1; 
N *  
N *  It is used to set P0.0 to high;
N *  
N *  Example 2:
N *  
N *      if (P00)
N *          P00 = 0;
N *  
N *  If P0.0 pin status is high, then set P0.0 data output to low.
N */
N#define GPIO_PIN_ADDR(port, pin)    (*((volatile uint32_t *)((GPIOBIT0_BASE+(0x20*(port))) + ((pin)<<2)))) 
N#define P00             GPIO_PIN_ADDR(0, 0) /*!< Specify P00 Pin Data Input/Output */
N#define P01             GPIO_PIN_ADDR(0, 1) /*!< Specify P01 Pin Data Input/Output */
N#define P02             GPIO_PIN_ADDR(0, 2) /*!< Specify P02 Pin Data Input/Output */
N#define P03             GPIO_PIN_ADDR(0, 3) /*!< Specify P03 Pin Data Input/Output */
N#define P04             GPIO_PIN_ADDR(0, 4) /*!< Specify P04 Pin Data Input/Output */
N#define P05             GPIO_PIN_ADDR(0, 5) /*!< Specify P05 Pin Data Input/Output */
N#define P06             GPIO_PIN_ADDR(0, 6) /*!< Specify P06 Pin Data Input/Output */
N#define P07             GPIO_PIN_ADDR(0, 7) /*!< Specify P07 Pin Data Input/Output */
N#define P10             GPIO_PIN_ADDR(1, 0) /*!< Specify P10 Pin Data Input/Output */
N#define P11             GPIO_PIN_ADDR(1, 1) /*!< Specify P11 Pin Data Input/Output */
N#define P12             GPIO_PIN_ADDR(1, 2) /*!< Specify P12 Pin Data Input/Output */
N#define P13             GPIO_PIN_ADDR(1, 3) /*!< Specify P13 Pin Data Input/Output */
N#define P14             GPIO_PIN_ADDR(1, 4) /*!< Specify P14 Pin Data Input/Output */
N#define P15             GPIO_PIN_ADDR(1, 5) /*!< Specify P15 Pin Data Input/Output */
N#define P16             GPIO_PIN_ADDR(1, 6) /*!< Specify P16 Pin Data Input/Output */
N#define P17             GPIO_PIN_ADDR(1, 7) /*!< Specify P17 Pin Data Input/Output */
N#define P20             GPIO_PIN_ADDR(2, 0) /*!< Specify P20 Pin Data Input/Output */
N#define P21             GPIO_PIN_ADDR(2, 1) /*!< Specify P21 Pin Data Input/Output */
N#define P22             GPIO_PIN_ADDR(2, 2) /*!< Specify P22 Pin Data Input/Output */
N#define P23             GPIO_PIN_ADDR(2, 3) /*!< Specify P23 Pin Data Input/Output */
N#define P24             GPIO_PIN_ADDR(2, 4) /*!< Specify P24 Pin Data Input/Output */
N#define P25             GPIO_PIN_ADDR(2, 5) /*!< Specify P25 Pin Data Input/Output */
N#define P26             GPIO_PIN_ADDR(2, 6) /*!< Specify P26 Pin Data Input/Output */
N#define P27             GPIO_PIN_ADDR(2, 7) /*!< Specify P27 Pin Data Input/Output */
N#define P30             GPIO_PIN_ADDR(3, 0) /*!< Specify P30 Pin Data Input/Output */
N#define P31             GPIO_PIN_ADDR(3, 1) /*!< Specify P31 Pin Data Input/Output */
N#define P32             GPIO_PIN_ADDR(3, 2) /*!< Specify P32 Pin Data Input/Output */
N#define P33             GPIO_PIN_ADDR(3, 3) /*!< Specify P33 Pin Data Input/Output */
N#define P34             GPIO_PIN_ADDR(3, 4) /*!< Specify P34 Pin Data Input/Output */
N#define P35             GPIO_PIN_ADDR(3, 5) /*!< Specify P35 Pin Data Input/Output */
N#define P36             GPIO_PIN_ADDR(3, 6) /*!< Specify P36 Pin Data Input/Output */
N#define P37             GPIO_PIN_ADDR(3, 7) /*!< Specify P37 Pin Data Input/Output */
N#define P40             GPIO_PIN_ADDR(4, 0) /*!< Specify P40 Pin Data Input/Output */
N#define P41             GPIO_PIN_ADDR(4, 1) /*!< Specify P41 Pin Data Input/Output */
N#define P42             GPIO_PIN_ADDR(4, 2) /*!< Specify P42 Pin Data Input/Output */
N#define P43             GPIO_PIN_ADDR(4, 3) /*!< Specify P43 Pin Data Input/Output */
N#define P44             GPIO_PIN_ADDR(4, 4) /*!< Specify P44 Pin Data Input/Output */
N#define P45             GPIO_PIN_ADDR(4, 5) /*!< Specify P45 Pin Data Input/Output */
N#define P46             GPIO_PIN_ADDR(4, 6) /*!< Specify P46 Pin Data Input/Output */
N#define P47             GPIO_PIN_ADDR(4, 7) /*!< Specify P47 Pin Data Input/Output */
N#define P50             GPIO_PIN_ADDR(5, 0) /*!< Specify P50 Pin Data Input/Output */
N#define P51             GPIO_PIN_ADDR(5, 1) /*!< Specify P51 Pin Data Input/Output */
N#define P52             GPIO_PIN_ADDR(5, 2) /*!< Specify P52 Pin Data Input/Output */
N#define P53             GPIO_PIN_ADDR(5, 3) /*!< Specify P53 Pin Data Input/Output */
N#define P54             GPIO_PIN_ADDR(5, 4) /*!< Specify P54 Pin Data Input/Output */
N#define P55             GPIO_PIN_ADDR(5, 5) /*!< Specify P55 Pin Data Input/Output */
N
N/*@}*/ /* end of group Mini58_GPIO_EXPORTED_CONSTANTS */
N
N/** @addtogroup Mini58_GPIO_EXPORTED_FUNCTIONS GPIO Exported Functions
N  @{
N*/
N
N/**
N * @brief       Clear GPIO Pin Interrupt Flag
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \ref BIT0, \ref BIT1, \ref BIT2,.. \ref BIT7
N *
N * @return      None
N *
N * @details     Clear the interrupt status of specified GPIO pin.
N */
N#define GPIO_CLR_INT_FLAG(gpio, u32PinMask)   ((gpio)->INTSRC = u32PinMask)
N
N/**
N * @brief       Disable Pin De-bounce Function
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \ref BIT0, \ref BIT1, \ref BIT2,.. \ref BIT7
N *
N * @return      None
N *
N * @details     Disable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_DISABLE_DEBOUNCE(gpio, u32PinMask)   ((gpio)->DBEN &= ~u32PinMask)
N
N/**
N * @brief       Enable Pin De-bounce Function
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \ref BIT0, \ref BIT1, \ref BIT2,.. \ref BIT7
N *
N * @return      None
N *
N * @details     Enable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_ENABLE_DEBOUNCE(gpio, u32PinMask)    ((gpio)->DBEN |= u32PinMask)
N
N/**
N * @brief       Disable I/O Digital Input Path
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \ref BIT0, \ref BIT1, \ref BIT2,.. \ref BIT7
N *
N * @return      None
N *
N * @details     Disable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_DISABLE_DIGITAL_PATH(gpio, u32PinMask)   ((gpio)->DINOFF |= (u32PinMask << 16))
N
N/**
N * @brief       Enable I/O Digital Input Path
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \ref BIT0, \ref BIT1, \ref BIT2,.. \ref BIT7
N *
N * @return      None
N *
N * @details     Enable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_ENABLE_DIGITAL_PATH(gpio, u32PinMask)    ((gpio)->DINOFF &= ~(u32PinMask << 16))
N
N/**
N * @brief       Disable I/O DOUT mask
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \ref BIT0, \ref BIT1, \ref BIT2,.. \ref BIT7
N *
N * @return      None
N *
N * @details     Disable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_DISABLE_DOUT_MASK(gpio, u32PinMask)   ((gpio)->DATMSK &= ~u32PinMask)
N
N/**
N * @brief       Enable I/O DOUT mask
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \ref BIT0, \ref BIT1, \ref BIT2,.. \ref BIT7
N *
N * @return      None
N *
N * @details     Enable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_ENABLE_DOUT_MASK(gpio, u32PinMask)   ((gpio)->DATMSK |= u32PinMask)
N
N/**
N * @brief       Get GPIO Pin Interrupt Flag
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \ref BIT0, \ref BIT1, \ref BIT2,.. \ref BIT7
N *
N * @retval      0           No interrupt at specified GPIO pin
N * @retval      1           The specified GPIO pin generate an interrupt
N *
N * @details     Get the interrupt status of specified GPIO pin.
N */
N#define GPIO_GET_INT_FLAG(gpio, u32PinMask)   ((gpio)->INTSRC & u32PinMask)
N
N/**
N * @brief       Set De-bounce Sampling Cycle Time
N *
N * @param[in]   clksrc      The de-bounce counter clock source. It could be GPIO_DBCTL_DBCLKSRC_HCLK or GPIO_DBCTL_DBCLKSRC_IRC10K.
N * @param[in]   clksel      The de-bounce sampling cycle selection. It could be \n
N *                              - \ref GPIO_DBCTL_DBCLKSEL_1, \ref GPIO_DBCTL_DBCLKSEL_2, \ref GPIO_DBCTL_DBCLKSEL_4, \ref GPIO_DBCTL_DBCLKSEL_8, \n
N *                              - \ref GPIO_DBCTL_DBCLKSEL_16, \ref GPIO_DBCTL_DBCLKSEL_32, \ref GPIO_DBCTL_DBCLKSEL_64, \ref GPIO_DBCTL_DBCLKSEL_128, \n
N *                              - \ref GPIO_DBCTL_DBCLKSEL_256, \ref GPIO_DBCTL_DBCLKSEL_512, \ref GPIO_DBCTL_DBCLKSEL_1024, \ref GPIO_DBCTL_DBCLKSEL_2048, \n
N *                              - \ref GPIO_DBCTL_DBCLKSEL_4096, \ref GPIO_DBCTL_DBCLKSEL_8192, \ref GPIO_DBCTL_DBCLKSEL_16384, \ref GPIO_DBCTL_DBCLKSEL_32768.
N *
N * @return      None
N *
N * @details     Set the interrupt de-bounce sampling cycle time based on the debounce counter clock source. \n
N *              Example: GPIO_SET_DEBOUNCE_TIME(GPIO_DBCTL_DBCLKSRC_IRC10K, GPIO_DBCTL_DBCLKSEL_4). \n
N *              It's meaning the De-debounce counter clock source is internal 10 KHz and sampling cycle selection is 4. \n
N *              Then the target de-bounce sampling cycle time is (2^4)*(1/(10*1000)) s = 16*0.0001 s = 1600 us,
N *              and system will sampling interrupt input once per 1600 us.
N */
N#define GPIO_SET_DEBOUNCE_TIME(clksrc, clksel)  (GPIO->DBCTL = (GP_DBCTL_ICLKON_Msk | clksrc | clksel))
N
N/**
N * @brief       Get GPIO Port IN Data
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N *
N * @retval      The specified port data
N *
N * @details     Get the PIN register of specified GPIO port.
N */
N#define GPIO_GET_IN_DATA(gpio)   ((gpio)->PIN)
N
N/**
N * @brief       Set GPIO Port OUT Data
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   data        GPIO port data.
N *
N * @retval      None
N *
N * @details     Set the Data into specified GPIO port.
N */
N#define GPIO_SET_OUT_DATA(gpio, data)   ((gpio)->DOUT = (data))
N
N/**
N * @brief       Toggle Specified GPIO pin
N *
N * @param[in]   u32Pin       Pxy
N *
N * @retval      None
N *
N * @details     Toggle the specified GPIO pint.
N */
N#define GPIO_TOGGLE(u32Pin)   ((u32Pin) ^= 1)
N
N/**
N * @brief       Enable External GPIO interrupt 0
N *
N * @param[in]   gpio            GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32Pin          The pin of specified GPIO port.
N * @param[in]   u32IntAttribs   The interrupt attribute of specified GPIO pin. It could be \n
N *                              - \ref GPIO_INT_RISING, \ref GPIO_INT_FALLING, \ref GPIO_INT_BOTH_EDGE, \ref GPIO_INT_HIGH, \ref GPIO_INT_LOW.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_EnableEINT0    GPIO_EnableInt
N
N
N/**
N * @brief       Disable External GPIO interrupt 0
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32Pin      The pin of specified GPIO port. It could be 0 ~ 7.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_DisableEINT0   GPIO_DisableInt
N
N
N/**
N * @brief       Enable External GPIO interrupt 1
N *
N * @param[in]   gpio            GPIO port. It could \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32Pin          The pin of specified GPIO port.
N * @param[in]   u32IntAttribs   The interrupt attribute of specified GPIO pin. It could be \n
N *                              - \ref GPIO_INT_RISING, \ref GPIO_INT_FALLING, \ref GPIO_INT_BOTH_EDGE, \ref GPIO_INT_HIGH, \ref GPIO_INT_LOW.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_EnableEINT1    GPIO_EnableInt
N
N
N/**
N * @brief       Disable External GPIO interrupt 1
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32Pin      The pin of specified GPIO port. It could be 0 ~ 7.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_DisableEINT1   GPIO_DisableInt
N
N
Nvoid GPIO_SetMode(GPIO_T *gpio, uint32_t u32PinMask, uint32_t u32Mode);
Nvoid GPIO_EnableInt(GPIO_T *gpio, uint32_t u32Pin, uint32_t u32IntAttribs);
Nvoid GPIO_DisableInt(GPIO_T *gpio, uint32_t u32Pin);
N
N
N
N/*@}*/ /* end of group Mini58_GPIO_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group Mini58_GPIO_Driver */
N
N/*@}*/ /* end of group Mini58_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__GPIO_H__
N
N/*** (C) COPYRIGHT 2015 Nuvoton Technology Corp. ***/
L 11942 "..\Library\Device\Nuvoton\Mini58Series\Include\Mini58Series.h" 2
N#include "i2c.h"
L 1 "..\Library\StdDriver\inc\i2c.h" 1
N/**************************************************************************//**
N * @file     i2c.h
N * @version  V1.00
N * $Revision: 7 $
N * $Date: 15/12/31 1:36p $ 
N * @brief    Mini58 series I2C driver header file
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __I2C_H__
N#define __I2C_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Mini58_Device_Driver Mini58 Device Driver
N  @{
N*/
N
N/** @addtogroup Mini58_I2C_Driver I2C Driver
N  @{
N*/
N
N
N/** @addtogroup Mini58_I2C_EXPORTED_CONSTANTS I2C Exported Constants
N  @{
N*/
N
N#define I2C_STA 0x20    /*!< I2C START */
N#define I2C_STO 0x10    /*!< I2C STOP */
N#define I2C_SI  0x08    /*!< I2C SI */
N#define I2C_AA  0x04    /*!< I2C ACK */
N
N/*@}*/ /* end of group Mini58_I2C_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup Mini58_I2C_EXPORTED_FUNCTIONS I2C Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro sets the I2C control register at one time.
N  * @param[in] i2c is the base address of I2C module.
N  * @param[in] u8Ctrl is the register value of I2C control register.
N  * @return none
N  */
N#define I2C_SET_CONTROL_REG(i2c, u8Ctrl) ( (i2c)->CTL = ((i2c)->CTL & ~0x3c) | u8Ctrl )
N
N/**
N  * @brief This macro only set START bit to the control register of I2C module.
N  * @param[in] i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_START(i2c) ( (i2c)->CTL = ((i2c)->CTL & ~I2C_CTL_SI_Msk) | I2C_CTL_STA_Msk )
N
N/**
N  * @brief This macro only set STOP bit to the control register of I2C module.
N  * @param[in] i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_STOP(i2c) \
Ndo { \
N    (i2c)->CTL |= (I2C_CTL_SI_Msk | I2C_CTL_STO_Msk); \
N    while((i2c)->CTL & I2C_CTL_STO_Msk); \
N} while(0)
X#define I2C_STOP(i2c) do {     (i2c)->CTL |= (I2C_CTL_SI_Msk | I2C_CTL_STO_Msk);     while((i2c)->CTL & I2C_CTL_STO_Msk); } while(0)
N
N/**
N  * @brief This macro will return when I2C module is ready.
N  * @param[in] i2c is the base address of I2C module.
N  * @return none
N  */
N#define  I2C_WAIT_READY(i2c) while(!((i2c)->CTL & I2C_CTL_SI_Msk))
N
N/**
N  * @brief This macro disables the FIFO function.
N  * @param[in] i2c is the base address of I2C module.
N  * @return none
N  */
N#define  I2C_DISABLE_FIFO(i2c) ( (i2c)->CTL1 &= ~I2C_CTL1_TWOLVFIFO_Msk )
N
N/**
N  * @brief This macro enables the FIFO function.
N  * @param[in] i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_ENABLE_FIFO(i2c) ( (i2c)->CTL1 |= I2C_CTL1_TWOLVFIFO_Msk )
N
N/**
N  * @brief This macro disables clock stretch function.
N  * @param[in] i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_DISABLE_CLOCK_STRETCH(i2c) ( (i2c)->CTL1 &= ~I2C_CTL1_NSTRETCH_Msk )
N
N/**
N  * @brief This macro enables clock stretch function.
N  * @param[in] i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_ENABLE_CLOCK_STRETCH(i2c) ( (i2c)->CTL1 |= I2C_CTL1_NSTRETCH_Msk )
N
N/**
N  * @brief This macro disables over-run interrupt.
N  * @param[in] i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_DISABLE_OVERRUN_INT(i2c) ( (i2c)->CTL1 &= ~I2C_CTL1_OVIEN_Msk )
N
N/**
N  * @brief This macro enables over-run interrupt.
N  * @param[in] i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_ENABLE_OVERRUN_INT(i2c) ( (i2c)->CTL1 |= I2C_CTL1_OVIEN_Msk )
N
N/**
N  * @brief This macro enables under-run interrupt.
N  * @param[in] i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_ENABLE_UNDERRUN_INT(i2c) ( (i2c)->CTL1 |= I2C_CTL1_URIEN_Msk )
N
N/**
N  * @brief This macro disables under-run interrupt.
N  * @param[in] i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_DISABLE_UNDERRUN_INT(i2c) ( (i2c)->CTL1 &= ~I2C_CTL1_URIEN_Msk )
N
N/**
N  * @brief This macro returns the data stored in data register of I2C module.
N  * @param[in] i2c is the base address of I2C module.
N  * @return Data.
N  */
N#define I2C_GET_DATA(i2c) ( (i2c)->DAT )
N
N/**
N  * @brief This macro writes the data to data register of I2C module.
N  * @param[in] i2c is the base address of I2C module.
N  * @param[in] u8Data is the data which will be write to data register of I2C module.
N  * @return none
N  */
N#define I2C_SET_DATA(i2c, u8Data) ( (i2c)->DAT = u8Data )
N
N/**
N  * @brief This macro returns the status of I2C module.
N  * @param[in] i2c is the base address of I2C module.
N  * @return Status.
N  */
N#define I2C_GET_STATUS(i2c) ( (i2c)->STATUS )
N
N/**
N  * @brief This macro returns timeout flag.
N  * @param[in] i2c is the base address of I2C module.
N  * @return Status.
N  * @retval 0 Flag is not set.
N  * @retval 1 Flag is set.
N  */
N#define I2C_GET_TIMEOUT_FLAG(i2c) ( ((i2c)->TOCTL & I2C_TOCTL_TOIF_Msk) == I2C_TOCTL_TOIF_Msk ? 1:0  )
N
N/**
N  * @brief This macro returns wakeup flag.
N  * @param[in] i2c is the base address of I2C module.
N  * @return Status.
N  * @retval 0 Flag is not set.
N  * @retval 1 Flag is set.
N  */
N#define I2C_GET_WAKEUP_FLAG(i2c) ( ((i2c)->STATUS1 & I2C_STATUS1_WKIF_Msk) == I2C_STATUS1_WKIF_Msk ? 1:0  )
N
N/**
N  * @brief This macro clears wakeup flag.
N  * @param[in] i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_CLEAR_WAKEUP_FLAG(i2c)  ( (i2c)->STATUS1 = I2C_STATUS1_WKIF_Msk )
N
Nuint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock);
Nvoid I2C_Close(I2C_T *i2c);
Nvoid I2C_ClearTimeoutFlag(I2C_T *i2c);
Nvoid I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack);
Nvoid I2C_DisableInt(I2C_T *i2c);
Nvoid I2C_EnableInt(I2C_T *i2c);
Nuint32_t I2C_GetBusClockFreq(I2C_T *i2c);
Nuint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock);
Nuint32_t I2C_GetIntFlag(I2C_T *i2c);
Nuint32_t I2C_GetStatus(I2C_T *i2c);
Nuint32_t I2C_GetData(I2C_T *i2c);
Nvoid I2C_SetData(I2C_T *i2c, uint8_t u8Data);
Nvoid I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode);
Nvoid I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask);
Nvoid I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout);
Nvoid I2C_DisableTimeout(I2C_T *i2c);
Nvoid I2C_EnableWakeup(I2C_T *i2c);
Nvoid I2C_DisableWakeup(I2C_T *i2c);
N
N/*@}*/ /* end of group Mini58_I2C_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group Mini58_I2C_Driver */
N
N/*@}*/ /* end of group Mini58_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__I2C_H__
N
N/*** (C) COPYRIGHT 2015 Nuvoton Technology Corp. ***/
L 11943 "..\Library\Device\Nuvoton\Mini58Series\Include\Mini58Series.h" 2
N#include "pwm.h"
L 1 "..\Library\StdDriver\inc\pwm.h" 1
N/**************************************************************************//**
N * @file     pwm.h
N * @version  V1.00
N * $Revision: 6 $
N * $Date: 15/06/05 1:41p $ 
N * @brief    Mini58 series PWM driver header file
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __PWM_H__
N#define __PWM_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Mini58_Device_Driver Mini58 Device Driver
N  @{
N*/
N
N/** @addtogroup Mini58_PWM_Driver PWM Driver
N  @{
N*/
N
N/** @addtogroup Mini58_PWM_EXPORTED_CONSTANTS PWM Exported Constants
N  @{
N*/
N#define PWM_CHANNEL_NUM                     (6)   /*!< PWM channel number */
N#define PWM_CLK_DIV_1                       (4UL) /*!< PWM clock divide by 1 */
N#define PWM_CLK_DIV_2                       (0UL) /*!< PWM clock divide by 2 */
N#define PWM_CLK_DIV_4                       (1UL) /*!< PWM clock divide by 4 */
N#define PWM_CLK_DIV_8                       (2UL) /*!< PWM clock divide by 8 */
N#define PWM_CLK_DIV_16                      (3UL) /*!< PWM clock divide by 16 */
N#define PWM_EDGE_ALIGNED                    (0UL)                   		/*!< PWM working in edge aligned type */
N#define PWM_CENTER_ALIGNED                  (PWM_CTL_CNTTYPE_Msk)   		/*!< PWM working in center aligned type */
N#define PWM_TRIGGER_ADC_CNTR_IS_0           PWM_ADCTCTL0_ZPTRGEN0_Msk   /*!< PWM trigger ADC while counter matches 0 */
N#define PWM_TRIGGER_ADC_CNTR_IS_CMR_D       PWM_ADCTCTL0_CDTRGEN0_Msk   /*!< PWM trigger ADC while counter matches CMR during down count */
N#define PWM_TRIGGER_ADC_CNTR_IS_CNR         PWM_ADCTCTL0_CPTRGEN0_Msk   /*!< PWM trigger ADC while counter matches CNR */
N#define PWM_TRIGGER_ADC_CNTR_IS_CMR_U       PWM_ADCTCTL0_CUTRGEN0_Msk   /*!< PWM trigger ADC while counter matches CMR during up count  */
N#define PWM_FB0_EINT0       								(PWM_BRKCTL_BRK0EN_Msk)                              /*!< External interrupt 0 as fault brake 0 source */
N#define PWM_FB0_ACMP1       								(PWM_BRKCTL_BRK0EN_Msk | PWM_BRKCTL_BRK1SEL_Msk)     /*!< Comparator 1 as fault brake 0 source */
N#define PWM_FB1_EINT1       								(PWM_BRKCTL_BRK1EN_Msk)                              /*!< External interrupt 1 as fault brake 1 source */
N#define PWM_FB1_ACMP0       								(PWM_BRKCTL_BRK1EN_Msk | PWM_BRKCTL_BRK0SEL_Msk)     /*!< Comparator 0 as fault brake 1 source */
N#define PWM_PERIOD_INT_UNDERFLOW            (0)                                  /*!< PWM period interrupt trigger if counter underflow */
N#define PWM_PERIOD_INT_MATCH_CNR            (PWM_INTEN_PINTTYPE_Msk)             /*!< PWM period interrupt trigger if counter match CNR */
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PWM Group channel number constants definitions                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_CH0                             0x0                         /*!< PWM channel 0 */
N#define PWM_CH1                             0x1                         /*!< PWM channel 1 */
N#define PWM_CH2                             0x2                         /*!< PWM channel 2 */
N#define PWM_CH3                             0x3                         /*!< PWM channel 3 */
N#define PWM_CH4                             0x4                         /*!< PWM channel 4 */
N#define PWM_CH5                             0x5                         /*!< PWM channel 5 */
N
N/*@}*/ /* end of group Mini58_PWM_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup Mini58_PWM_EXPORTED_FUNCTIONS PWM Exported Functions
N  @{
N*/
N
N/**
N * @brief This macro enable complementary mode
N * @param[in] pwm The base address of PWM module
N * @return None
N * \hideinitializer
N */
N#define PWM_ENABLE_COMPLEMENTARY_MODE(pwm) ((pwm)->CTL = (PWM->CTL & ~PWM_CTL_MODE_Msk) |(1UL << PWM_CTL_MODE_Pos))
N
N/**
N * @brief This macro disable complementary mode, and enable independent mode.
N * @param[in] pwm The base address of PWM module
N * @return None
N * \hideinitializer
N */
N#define PWM_DISABLE_COMPLEMENTARY_MODE(pwm) ((pwm)->CTL &= ~PWM_CTL_MODE_Msk)
N
N/**
N * @brief This macro enable group mode
N * @param[in] pwm The base address of PWM module
N * @return None
N * \hideinitializer
N */
N#define PWM_ENABLE_GROUP_MODE(pwm) ((pwm)->CTL |= PWM_CTL_GROUPEN_Msk)
N
N/**
N * @brief This macro disable group mode
N * @param[in] pwm The base address of PWM module
N * @return None
N * \hideinitializer
N */
N#define PWM_DISABLE_GROUP_MODE(pwm) ((pwm)->CTL &= ~PWM_CTL_GROUPEN_Msk)
N
N/**
N * @brief This macro enable synchronous mode
N * @param[in] pwm The base address of PWM module
N * @return None
N * \hideinitializer
N */
N#define PWM_ENABLE_SYNC_MODE(pwm) (PWM->CTL = ((pwm)->CTL & ~PWM_CTL_MODE_Msk) |(2UL << PWM_CTL_MODE_Pos))
N 
N/**
N * @brief This macro disable synchronous mode, and enable independent mode.
N * @param[in] pwm The base address of PWM module
N * @return None
N * \hideinitializer
N */
N#define PWM_DISABLE_SYNC_MODE(pwm) ((pwm)->CTL &= ~PWM_CTL_MODE_Msk)
N
N/**
N * @brief This macro enable output inverter of specified channel(s)
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * \hideinitializer
N */
N#define PWM_ENABLE_OUTPUT_INVERTER(pwm, u32ChannelMask) \
N    do{ \
N        int i;\
N			  (pwm)->CTL &= ~(PWM_CTL_PINV0_Msk|PWM_CTL_PINV1_Msk|PWM_CTL_PINV2_Msk|PWM_CTL_PINV3_Msk|PWM_CTL_PINV4_Msk|PWM_CTL_PINV5_Msk);\
N        for(i = 0; i < 6; i++) { \
N            if((u32ChannelMask) & (1 << i)) \
N                (pwm)->CTL |= (1 << (PWM_CTL_PINV0_Pos + (i * 4))); \
N        } \
N    }while(0)
X#define PWM_ENABLE_OUTPUT_INVERTER(pwm, u32ChannelMask)     do{         int i;			  (pwm)->CTL &= ~(PWM_CTL_PINV0_Msk|PWM_CTL_PINV1_Msk|PWM_CTL_PINV2_Msk|PWM_CTL_PINV3_Msk|PWM_CTL_PINV4_Msk|PWM_CTL_PINV5_Msk);        for(i = 0; i < 6; i++) {             if((u32ChannelMask) & (1 << i))                 (pwm)->CTL |= (1 << (PWM_CTL_PINV0_Pos + (i * 4)));         }     }while(0)
N
N/**
N * @brief This macro set the prescaler of the selected channel
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32Prescaler Clock prescaler of specified channel. Valid values are between 1 ~ 0xFF
N * @return None
N * @note Every even channel N, and channel (N + 1) share a prescaler. So if channel 0 prescaler changed, 
N *       channel 1 will also be affected.
N * \hideinitializer
N */
N#define PWM_SET_PRESCALER(pwm, u32ChannelNum, u32Prescaler) \
N    ((pwm)->CLKPSC = ((pwm)->CLKPSC & ~(PWM_CLKPSC_CLKPSC01_Msk << (((u32ChannelNum) >> 1) * 8))) | ((u32Prescaler) << (((u32ChannelNum) >> 1) * 8))) 
X#define PWM_SET_PRESCALER(pwm, u32ChannelNum, u32Prescaler)     ((pwm)->CLKPSC = ((pwm)->CLKPSC & ~(PWM_CLKPSC_CLKPSC01_Msk << (((u32ChannelNum) >> 1) * 8))) | ((u32Prescaler) << (((u32ChannelNum) >> 1) * 8))) 
N
N/**
N * @brief This macro set the divider of the selected channel
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32Divider Clock divider of specified channel. Valid values are
N *              - \ref PWM_CLK_DIV_1
N *              - \ref PWM_CLK_DIV_2
N *              - \ref PWM_CLK_DIV_4
N *              - \ref PWM_CLK_DIV_8
N *              - \ref PWM_CLK_DIV_16 
N * @return None
N * \hideinitializer
N */
N#define PWM_SET_DIVIDER(pwm, u32ChannelNum, u32Divider) \
N    ((pwm)->CLKDIV = ((pwm)->CLKDIV & ~(PWM_CLKDIV_CLKDIV0_Msk << ((u32ChannelNum) * 4))) | ((u32Divider) << ((u32ChannelNum) * 4)))
X#define PWM_SET_DIVIDER(pwm, u32ChannelNum, u32Divider)     ((pwm)->CLKDIV = ((pwm)->CLKDIV & ~(PWM_CLKDIV_CLKDIV0_Msk << ((u32ChannelNum) * 4))) | ((u32Divider) << ((u32ChannelNum) * 4)))
N
N/**
N * @brief This macro set the duty of the selected channel
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5 
N * @param[in] u32CMR Duty of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @note This new setting will take effect on next PWM period
N * \hideinitializer
N */
N#define PWM_SET_CMR(pwm, u32ChannelNum, u32CMR) (*((__IO uint32_t *)((((uint32_t) & ((pwm)->CMPDAT0)) + u32ChannelNum * 4)))= (u32CMR))
N
N/**
N * @brief This macro set the period of the selected channel
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5 
N * @param[in] u32CNR Period of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @note This new setting will take effect on next PWM period
N * @note PWM counter will stop if period length set to 0
N * \hideinitializer
N */
N#define PWM_SET_CNR(pwm, u32ChannelNum, u32CNR)  (*((__IO uint32_t *) ((((uint32_t)&((pwm)->PERIOD0)) + (u32ChannelNum) * 4))) = (u32CNR))
N
N/**
N * @brief This macro set the duty of the selected channel for PWM asymmetric Mode
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5 
N * @param[in] u32CMRD Down counter in Asymmetric Mode. Valid values are between 0~0xFFFF
N * @return None
N * @note This new setting will take effect on next PWM period
N * \hideinitializer
N */
N#define PWM_SET_CMRD(pwm, u32ChannelNum, u32CMRD) (*((__IO uint32_t *)((((uint32_t) & ((pwm)->CMPDAT0)) + (u32ChannelNum) * 4)))= (u32CMRD << 16))
N
N/**
N * @brief This macro set the PWM aligned type
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelMask This parameter is not used
N * @param[in] u32AlignedType PWM aligned type, valid values are:
N *                  - \ref PWM_EDGE_ALIGNED
N *                  - \ref PWM_CENTER_ALIGNED
N * @return None
N * \hideinitializer
N */
N#define PWM_SET_ALIGNED_TYPE(pwm, u32ChannelMask, u32AlignedType) \
N    ((pwm)->CTL = ((pwm)->CTL & ~PWM_CTL_CNTTYPE_Msk) | (u32AlignedType))
X#define PWM_SET_ALIGNED_TYPE(pwm, u32ChannelMask, u32AlignedType)     ((pwm)->CTL = ((pwm)->CTL & ~PWM_CTL_CNTTYPE_Msk) | (u32AlignedType))
N
N/**
N * @brief This macro enables PWM asymmetric mode
N * @param[in] pwm The base address of PWM module
N * @return None
N * \hideinitializer
N */
N#define PWM_ENABLE_ASYMMETRIC_MODE(pwm) ((pwm)->CTL |= PWM_CTL_ASYMEN_Msk)
N
N/**
N * @brief This macro enables PWM Precise Center-Aligned Type
N * @param[in] pwm The base address of PWM module
N * @return None
N * \hideinitializer
N */
N#define PWM_ENABLE_PCAEN(pwm) (PWM->PCACTL |= PWM_PCACTL_PCAEN_Msk)
N
Nuint32_t PWM_ConfigOutputChannel(PWM_T *pwm,
N                                  uint32_t u32ChannelNum, 
N                                  uint32_t u32Frequency, 
N                                  uint32_t u32DutyCycle);
Nvoid PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nvoid PWM_DisableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nuint32_t PWM_GetADCTriggerFlag (PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nvoid PWM_EnableFaultBrake(PWM_T *pwm, 
N                           uint32_t u32ChannelMask, 
N                           uint32_t u32LevelMask, 
N                           uint32_t u32BrakeSource);
Nvoid PWM_ClearFaultBrakeFlag(PWM_T *pwm, uint32_t u32BrakeSource);
Nvoid PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration);
Nvoid PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum);
N
Nvoid PWM_EnableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType);
Nvoid PWM_DisableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
N
Nvoid PWM_EnableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource);
Nvoid PWM_DisableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource);
Nvoid PWM_ClearFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource);
Nuint32_t PWM_GetFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource);
N
Nvoid PWM_EnablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_DisablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
N
Nvoid PWM_EnableCenterInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntPeriodType);
Nvoid PWM_DisableCenterInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearCenterIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetCenterIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
N
Nvoid PWM_EnableRiseInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_DisableRiseInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearRiseIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetRiseIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
N
N/*@}*/ /* end of group Mini58_PWM_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group Mini58_PWM_Driver */
N
N/*@}*/ /* end of group Mini58_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__PWM_H__
N
N/*** (C) COPYRIGHT 2015 Nuvoton Technology Corp. ***/
L 11944 "..\Library\Device\Nuvoton\Mini58Series\Include\Mini58Series.h" 2
N#include "spi.h"
L 1 "..\Library\StdDriver\inc\spi.h" 1
N/**************************************************************************//**
N * @file     spi.h
N * @version  V1.00
N * $Revision: 3 $
N * $Date: 15/04/17 11:45a $ 
N * @brief    Mini58 series SPI driver header file
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __SPI_H__
N#define __SPI_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Mini58_Device_Driver Mini58 Device Driver
N  @{
N*/
N
N/** @addtogroup Mini58_SPI_Driver SPI Driver
N  @{
N*/
N
N/** @addtogroup Mini58_SPI_EXPORTED_CONSTANTS SPI Exported Constants
N  @{
N*/
N
N#define SPI_MODE_0        (SPI_CTL_TXNEG_Msk)                            /*!< CLKP=0; RX_NEG=0; TX_NEG=1 */
N#define SPI_MODE_1        (SPI_CTL_RXNEG_Msk)                            /*!< CLKP=0; RX_NEG=1; TX_NEG=0 */
N#define SPI_MODE_2        (SPI_CTL_CLKPOL_Msk | SPI_CTL_RXNEG_Msk)       /*!< CLKP=1; RX_NEG=1; TX_NEG=0 */
N#define SPI_MODE_3        (SPI_CTL_CLKPOL_Msk | SPI_CTL_TXNEG_Msk)       /*!< CLKP=1; RX_NEG=0; TX_NEG=1 */
N
N#define SPI_SLAVE         (SPI_CTL_SLAVE_Msk)                             /*!< Set as slave */
N#define SPI_MASTER        (0x0)                                             /*!< Set as master */
N
N#define SPI_SS                (SPI_SSCTL_SS_Msk)                             /*!< Set SS0 */
N#define SPI_SS_ACTIVE_HIGH    (SPI_SSCTL_SSACTPOL_Msk)                          /*!< SS active high */
N#define SPI_SS_ACTIVE_LOW     (0x0)                                         /*!< SS active low */
N
N#define SPI_IE_MASK                        (0x01)                           /*!< Interrupt enable mask */
N#define SPI_SSTA_INTEN_MASK                (0x04)                           /*!< Slave 3-Wire mode start interrupt enable mask */
N#define SPI_FIFO_TX_INTEN_MASK             (0x08)                           /*!< FIFO TX interrupt mask */
N#define SPI_FIFO_RX_INTEN_MASK             (0x10)                           /*!< FIFO RX interrupt mask */
N#define SPI_FIFO_RXOV_INTEN_MASK           (0x20)                           /*!< FIFO RX overrun interrupt mask */
N#define SPI_FIFO_TIMEOUT_INTEN_MASK        (0x40)                           /*!< FIFO timeout interrupt mask */
N
N
N/*@}*/ /* end of group Mini58_SPI_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup Mini58_SPI_EXPORTED_FUNCTIONS SPI Exported Functions
N  @{
N*/
N
N/**
N  * @brief  Abort the current transfer in slave 3-wire mode.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  */
N#define  SPI_ABORT_3WIRE_TRANSFER(spi) ( (spi)->SLVCTL |= SPI_SLVCTL_SLVABT_Msk )
N
N/**
N  * @brief  Clear the slave 3-wire mode start interrupt flag.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  */
N#define SPI_CLR_3WIRE_START_INT_FLAG(spi) ( (spi)->STATUS = SPI_STATUS_SLVSTIF_Msk )
N
N/**
N  * @brief  Clear the unit transfer interrupt flag.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  */
N#define SPI_CLR_UNIT_TRANS_INT_FLAG(spi) ( (spi)->STATUS = SPI_STATUS_UNITIF_Msk )
N
N/**
N  * @brief  Disable slave 3-wire mode.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  */
N#define SPI_DISABLE_3WIRE_MODE(spi) ( (spi)->SLVCTL &= ~SPI_SLVCTL_SLV3WIRE_Msk )
N
N/**
N  * @brief  Enable slave 3-wire mode.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  */
N#define SPI_ENABLE_3WIRE_MODE(spi) ( (spi)->SLVCTL |= SPI_SLVCTL_SLV3WIRE_Msk )
N
N/**
N  * @brief  Get the count of available data in RX FIFO.
N  * @param[in]  spi is the base address of SPI module.
N  * @return The count of available data in RX FIFO.
N  */
N#define SPI_GET_RX_FIFO_COUNT(spi) ( (((spi)->STATUS & SPI_STATUS_RXCNT_Msk) >> SPI_STATUS_RXCNT_Pos) & 0xf )
N
N/**
N  * @brief  Get the Rx FIFO empty flag.
N  * @param[in]  spi is the base address of SPI module.
N  * @return Rx FIFO flag
N  * @retval 0 Rx FIFO is not empty
N  * @retval 1 Rx FIFO is empty
N  */
N#define SPI_GET_RX_FIFO_EMPTY_FLAG(spi) ( ((spi)->STATUS & SPI_STATUS_RXEMPTY_Msk) == SPI_STATUS_RXEMPTY_Msk ? 1:0 )
N
N/**
N  * @brief  Get the Tx FIFO empty flag.
N  * @param[in]  spi is the base address of SPI module.
N  * @return Tx FIFO flag
N  * @retval 0 Tx FIFO is not empty
N  * @retval 1 Tx FIFO is empty
N  */
N#define SPI_GET_TX_FIFO_EMPTY_FLAG(spi) ( ((spi)->STATUS & SPI_STATUS_TXEMPTY_Msk) == SPI_STATUS_TXEMPTY_Msk ? 1:0 )
N
N/**
N  * @brief  Get the Tx FIFO full flag.
N  * @param  spi is the base address of SPI module.
N  * @return Tx FIFO flag
N  * @retval 0 Tx FIFO is not full
N  * @retval 1 Tx FIFO is full
N  */
N#define SPI_GET_TX_FIFO_FULL_FLAG(spi) ( ((spi)->STATUS & SPI_STATUS_TXFULL_Msk) == SPI_STATUS_TXFULL_Msk ? 1:0 )
N
N/**
N  * @brief  Get the datum read from Rx FIFO.
N  * @param[in]  spi is the base address of SPI module.
N  * @return Data in Rx buffer
N  */
N#define SPI_READ_RX(spi) ( (spi)->RX )
N
N/**
N  * @brief  Write datum to TX register.
N  * @param[in]  spi is the base address of SPI module.
N  * @param[in]  u32TxData is the datum which user attempt to transfer through SPI bus.
N  * @return none
N  */
N#define SPI_WRITE_TX(spi, u32TxData) ( (spi)->TX = u32TxData )
N
N/**
N  * @brief  Disable automatic slave select function and set SPI_SS pin to high state.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  */
Nstatic __INLINE void SPI_SET_SS_HIGH(SPI_T *spi)
Xstatic __inline void SPI_SET_SS_HIGH(SPI_T *spi)
N{
N  spi->SSCTL &= ~SPI_SSCTL_AUTOSS_Msk;  
X  spi->SSCTL &= ~(0x1ul << (3));  
N  spi->SSCTL |= (SPI_SSCTL_LTF_Msk | SPI_SSCTL_SSACTPOL_Msk | SPI_SSCTL_SS_Msk);
X  spi->SSCTL |= ((0x1ul << (5)) | (0x1ul << (2)) | (0x1ul << (0)));
N}
N
N/**
N  * @brief  Disable automatic slave select function and set SPI_SS pin to low state.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  */
Nstatic __INLINE void SPI_SET_SS_LOW(SPI_T *spi)
Xstatic __inline void SPI_SET_SS_LOW(SPI_T *spi)
N{
N  spi->SSCTL &= ~SPI_SSCTL_AUTOSS_Msk;
X  spi->SSCTL &= ~(0x1ul << (3));
N  spi->SSCTL |= SPI_SSCTL_LTF_Msk;  
X  spi->SSCTL |= (0x1ul << (5));  
N  spi->SSCTL &= ~SPI_SSCTL_SSACTPOL_Msk;
X  spi->SSCTL &= ~(0x1ul << (2));
N  spi->SSCTL |= SPI_SSCTL_SS_Msk;
X  spi->SSCTL |= (0x1ul << (0));
N}
N
N/**
N  * @brief Enable byte reorder function.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  */
N#define SPI_ENABLE_BYTE_REORDER(spi) ( (spi)->CTL |= SPI_CTL_REORDER_Msk )
N
N/**
N  * @brief  Disable byte reorder function.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  */
N#define SPI_DISABLE_BYTE_REORDER(spi) ( (spi)->CTL &= ~SPI_CTL_REORDER_Msk )
N
N/**
N  * @brief  Set the length of suspend interval.
N  * @param[in]  spi is the base address of SPI module.
N  * @param[in]  u32SuspCycle decides the length of suspend interval.
N  * @return none
N  */
N#define SPI_SET_SUSPEND_CYCLE(spi, u32SuspCycle) ( (spi)->CTL = ((spi)->CTL & ~SPI_CTL_SUSPITV_Msk) | (u32SuspCycle << SPI_CTL_SUSPITV_Pos) )
N
N/**
N  * @brief  Set the SPI transfer sequence with LSB first.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  */
N#define SPI_SET_LSB_FIRST(spi) ( (spi)->CTL |= SPI_CTL_LSB_Msk )
N
N/**
N  * @brief  Set the SPI transfer sequence with MSB first.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  */
N#define SPI_SET_MSB_FIRST(spi) ( (spi)->CTL &= ~SPI_CTL_LSB_Msk )
N
N/**
N  * @brief  Set the data width of a SPI transaction.
N  * @param[in]  spi is the base address of SPI module.
N  * @param[in]  u32Width is the bit width of transfer data.  
N  * @return none
N  */
Nstatic __INLINE void SPI_SET_DATA_WIDTH(SPI_T *spi, uint32_t u32Width)
Xstatic __inline void SPI_SET_DATA_WIDTH(SPI_T *spi, uint32_t u32Width)
N{
N   if(u32Width == 32)
N        u32Width = 0;
N        
N   spi->CTL = (spi->CTL & ~SPI_CTL_DWIDTH_Msk) | (u32Width << SPI_CTL_DWIDTH_Pos);
X   spi->CTL = (spi->CTL & ~(0x1ful << (3))) | (u32Width << (3));
N}
N
N/**
N  * @brief  Get the SPI busy state.
N  * @param[in]  spi is the base address of SPI module.
N  * @return SPI busy status
N  * @retval 0 SPI module is not busy
N  * @retval 1 SPI module is busy
N  */
N#define SPI_IS_BUSY(spi) ( ((spi)->CTL & SPI_CTL_SPIEN_Msk) == SPI_CTL_SPIEN_Msk ? 1:0 )
N
N/**
N  * @brief  Set the GO_BUSY bit to trigger SPI transfer.
N  * @param[in]  spi is the base address of SPI module.
N  * @return none
N  */
N#define SPI_TRIGGER(spi) ( (spi)->CTL |= SPI_CTL_SPIEN_Msk )
N
Nuint32_t SPI_Open(SPI_T *spi, uint32_t u32MasterSlave, uint32_t u32SPIMode, uint32_t u32DataWidth, uint32_t u32BusClock);
Nvoid SPI_Close(SPI_T *spi);
Nvoid SPI_ClearRxFIFO(SPI_T *spi);
Nvoid SPI_ClearTxFIFO(SPI_T *spi);
Nvoid SPI_DisableAutoSS(SPI_T *spi);
Nvoid SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel);
Nuint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock);
Nvoid SPI_EnableFIFO(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold);
Nvoid SPI_DisableFIFO(SPI_T *spi);
Nuint32_t SPI_GetBusClock(SPI_T *spi);
Nvoid SPI_EnableInt(SPI_T *spi, uint32_t u32Mask);
Nvoid SPI_DisableInt(SPI_T *spi, uint32_t u32Mask);
N
N/*@}*/ /* end of group Mini58_SPI_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group Mini58_SPI_Driver */
N
N/*@}*/ /* end of group Mini58_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SPI_H__
N
N/*** (C) COPYRIGHT 2015 Nuvoton Technology Corp. ***/
L 11945 "..\Library\Device\Nuvoton\Mini58Series\Include\Mini58Series.h" 2
N#include "timer.h"
L 1 "..\Library\StdDriver\inc\timer.h" 1
N/**************************************************************************//**
N * @file     timer.h
N * @version  V1.00
N * $Revision: 7 $
N * $Date: 15/05/27 11:56a $
N * @brief    Mini58 series TIMER driver header file
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __TIMER_H__
N#define __TIMER_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Mini58_Device_Driver Mini58 Device Driver
N  @{
N*/
N
N/** @addtogroup Mini58_TIMER_Driver TIMER Driver
N  @{
N*/
N
N/** @addtogroup Mini58_TIMER_EXPORTED_CONSTANTS TIMER Exported Constants
N  @{
N*/
N
N#define TIMER_ONESHOT_MODE                  (0UL)                           /*!< Timer working in one shot mode */
N#define TIMER_PERIODIC_MODE                 (1UL << TIMER_CTL_OPMODE_Pos)    /*!< Timer working in periodic mode */
N#define TIMER_TOGGLE_MODE                   (2UL << TIMER_CTL_OPMODE_Pos)    /*!< Timer working in toggle mode */
N#define TIMER_CONTINUOUS_MODE               (3UL << TIMER_CTL_OPMODE_Pos)    /*!< Timer working in continuous mode */
N#define TIMER_CAPTURE_FREE_COUNTING_MODE    (0UL)                           /*!< Free counting mode */
N#define TIMER_CAPTURE_TRIGGER_COUNTING_MODE (TIMER_EXTCTL_CAPSEL_Msk)      /*!< Trigger counting mode */
N#define TIMER_CAPTURE_COUNTER_RESET_MODE    (TIMER_EXTCTL_CAPFUNCS_Msk)    /*!< Counter reset mode */
N#define TIMER_CAPTURE_FALLING_EDGE              (0UL)                               /*!< Falling edge trigger timer capture */
N#define TIMER_CAPTURE_RISING_EDGE               (1UL << TIMER_EXTCTL_CAPEDGE_Pos)  /*!< Rising edge trigger timer capture */
N#define TIMER_CAPTURE_FALLING_THEN_RISING_EDGE  (2UL << TIMER_EXTCTL_CAPEDGE_Pos)  /*!< Falling edge then rising edge trigger timer capture */
N#define TIMER_CAPTURE_RISING_THEN_FALLING_EDGE  (3UL << TIMER_EXTCTL_CAPEDGE_Pos)  /*!< Rising edge then falling edge trigger timer capture */
N#define TIMER_COUNTER_RISING_EDGE           (TIMER_EXTCTL_CNTPHASE_Msk)     /*!< Counter increase on rising edge */
N#define TIMER_COUNTER_FALLING_EDGE          (0UL)                           /*!< Counter increase on falling edge */
N#define TIMER_TOGGLE_TMX_CNT_OUT            (0UL)                           /*!< Timer use TMx_CNT_OUT, x = 0, 1 pin as toggle output pin   */
N#define TIMER_TOGGLE_TMX_EXT                (TIMER_CTL_TGLPINSEL_Msk)       /*!< Timer use TMx_EXT, x = 0, 1 pin as toggle output pin */
N
N/*@}*/ /* end of group Mini58_TIMER_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup Mini58_TIMER_EXPORTED_FUNCTIONS TIMER Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro is used to set new Timer compared value
N  * @param[in] timer The base address of Timer module
N  * @param[in] u32Value  Timer compare value. Valid values are between 2 to 0xFFFFFF
N  * @return None
N  * \hideinitializer
N  */
N#define TIMER_SET_CMP_VALUE(timer, u32Value) ((timer)->CMP = (u32Value))
N
N/**
N  * @brief This macro is used to set new Timer prescale value
N  * @param[in] timer The base address of Timer module
N  * @param[in] u32Value  Timer prescale value. Valid values are between 0 to 0xFF
N  * @return None
N  * @note Clock input is divided by (prescale + 1) before it is fed into timer
N  * \hideinitializer
N  */
N#define TIMER_SET_PRESCALE_VALUE(timer, u32Value) ((timer)->CTL = ((timer)->CTL & ~TIMER_CTL_PSC_Msk) | (u32Value))
N
N/**
N  * @brief This macro is used to check if specify Timer is inactive or active
N  * @param[in] timer The base address of Timer module
N  * @return timer is activate or inactivate
N  * @retval 0 Timer 24-bit up counter is inactive
N  * @retval 1 Timer 24-bit up counter is active
N  * \hideinitializer
N  */
N#define TIMER_IS_ACTIVE(timer) ((timer)->CTL & TIMER_CTL_ACTSTS_Msk ? 1 : 0)
N
N/**
N  * @brief This macro is used to select Timer toggle output pin
N  * @param[in] timer The base address of Timer module
N  * @param[in] u32ToutSel Toggle output pin selection, valid values are
N  *                 - \ref TIMER_TOGGLE_TMX_CNT_OUT
N  *                 - \ref TIMER_TOGGLE_TMX_EXT
N  * @return None
N  * \hideinitializer
N  */
N#define TIMER_SELECT_TOUT_PIN(timer, u32ToutSel) ((timer)->CTL = ((timer)->CTL & ~TIMER_CTL_TGLPINSEL_Msk) | (u32ToutSel))
N
N
N
N/**
N  * @brief This function is used to start Timer counting
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_Start(TIMER_T *timer)
Xstatic __inline void TIMER_Start(TIMER_T *timer)
N{
N    timer->CTL |= TIMER_CTL_CNTEN_Msk;
X    timer->CTL |= (0x1ul << (30));
N}
N
N/**
N  * @brief This function is used to stop Timer counting
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_Stop(TIMER_T *timer)
Xstatic __inline void TIMER_Stop(TIMER_T *timer)
N{
N    timer->CTL &= ~TIMER_CTL_CNTEN_Msk;
X    timer->CTL &= ~(0x1ul << (30));
N}
N
N/**
N  * @brief This function is used to enable the Timer wake-up function
N  * @param[in] timer The base address of Timer module
N  * @return None
N  * @note  To wake the system from power down mode, timer clock source must be ether LXT or LIRC
N  */
N__STATIC_INLINE void TIMER_EnableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_EnableWakeup(TIMER_T *timer)
N{
N    timer->CTL |= TIMER_CTL_WKEN_Msk;
X    timer->CTL |= (0x1ul << (23));
N}
N
N/**
N  * @brief This function is used to disable the Timer wake-up function
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_DisableWakeup(TIMER_T *timer)
N{
N    timer->CTL &= ~TIMER_CTL_WKEN_Msk;
X    timer->CTL &= ~(0x1ul << (23));
N}
N
N
N/**
N  * @brief This function is used to enable the capture pin detection de-bounce function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_EnableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureDebounce(TIMER_T *timer)
N{
N    timer->EXTCTL |= TIMER_EXTCTL_CAPDBEN_Msk;
X    timer->EXTCTL |= (0x1ul << (6));
N}
N
N/**
N  * @brief This function is used to disable the capture pin detection de-bounce function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureDebounce(TIMER_T *timer)
N{
N    timer->EXTCTL &= ~TIMER_EXTCTL_CAPDBEN_Msk;
X    timer->EXTCTL &= ~(0x1ul << (6));
N}
N
N
N/**
N  * @brief This function is used to enable the counter pin detection de-bounce function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->EXTCTL |= TIMER_EXTCTL_CNTDBEN_Msk;
X    timer->EXTCTL |= (0x1ul << (7));
N}
N
N/**
N  * @brief This function is used to disable the counter pin detection de-bounce function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->EXTCTL &= ~TIMER_EXTCTL_CNTDBEN_Msk;
X    timer->EXTCTL &= ~(0x1ul << (7));
N}
N
N/**
N  * @brief This function is used to enable the Timer time-out interrupt function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_EnableInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableInt(TIMER_T *timer)
N{
N    timer->CTL |= TIMER_CTL_INTEN_Msk;
X    timer->CTL |= (0x1ul << (29));
N}
N
N/**
N  * @brief This function is used to disable the Timer time-out interrupt function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableInt(TIMER_T *timer)
N{
N    timer->CTL &= ~TIMER_CTL_INTEN_Msk;
X    timer->CTL &= ~(0x1ul << (29));
N}
N
N/**
N  * @brief This function is used to enable the Timer capture trigger interrupt function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_EnableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureInt(TIMER_T *timer)
N{
N    timer->EXTCTL |= TIMER_EXTCTL_CAPIEN_Msk;
X    timer->EXTCTL |= (0x1ul << (5));
N}
N
N/**
N  * @brief This function is used to disable the Timer capture trigger interrupt function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureInt(TIMER_T *timer)
N{
N    timer->EXTCTL &= ~TIMER_EXTCTL_CAPIEN_Msk;
X    timer->EXTCTL &= ~(0x1ul << (5));
N}
N
N/**
N  * @brief This function indicates Timer time-out interrupt occurred or not.
N  * @param[in] timer The base address of Timer module
N  * @return Timer time-out interrupt occurred or not
N  * @retval 0 Timer time-out interrupt did not occur
N  * @retval 1 Timer time-out interrupt occurred
N  */
N__STATIC_INLINE uint32_t TIMER_GetIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetIntFlag(TIMER_T *timer)
N{
N    return(timer->INTSTS & TIMER_INTSTS_TIF_Msk ? 1 : 0);
X    return(timer->INTSTS & (0x1ul << (0)) ? 1 : 0);
N}
N
N/**
N  * @brief This function clears the Timer time-out interrupt flag.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_ClearIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearIntFlag(TIMER_T *timer)
N{
N    timer->INTSTS = TIMER_INTSTS_TIF_Msk;
X    timer->INTSTS = (0x1ul << (0));
N}
N
N/**
N  * @brief This function indicates Timer capture interrupt occurred or not.
N  * @param[in] timer The base address of Timer module
N  * @return Timer capture interrupt occurred or not
N  * @retval 0 Timer capture interrupt did not occur
N  * @retval 1 Timer capture interrupt occurred
N  */
N__STATIC_INLINE uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
N{
N    return timer->EINTSTS;
N}
N
N/**
N  * @brief This function clears the Timer capture interrupt flag.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
N{
N    timer->EINTSTS = TIMER_EINTSTS_CAPIF_Msk;
X    timer->EINTSTS = (0x1ul << (0));
N}
N
N/**
N  * @brief This function indicates Timer has waked up system or not.
N  * @param[in] timer The base address of Timer module
N  * @return Timer has waked up system or not
N  * @retval 0 Timer did not wake up system
N  * @retval 1 Timer wake up system
N  */
N__STATIC_INLINE uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
N{
N    return (timer->INTSTS & TIMER_INTSTS_TWKF_Msk ? 1 : 0);
X    return (timer->INTSTS & (0x1ul << (1)) ? 1 : 0);
N}
N
N/**
N  * @brief This function clears the Timer wakeup interrupt flag.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_ClearWakeupFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearWakeupFlag(TIMER_T *timer)
N{
N    timer->INTSTS = TIMER_INTSTS_TWKF_Msk;
X    timer->INTSTS = (0x1ul << (1));
N}
N
N/**
N  * @brief This function gets the Timer capture data.
N  * @param[in] timer The base address of Timer module
N  * @return Timer capture data value
N  */
N__STATIC_INLINE uint32_t TIMER_GetCaptureData(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureData(TIMER_T *timer)
N{
N    return timer->CAP;
N}
N
N/**
N  * @brief This function reports the current timer counter value.
N  * @param[in] timer The base address of Timer module
N  * @return Timer counter value
N  */
N__STATIC_INLINE uint32_t TIMER_GetCounter(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCounter(TIMER_T *timer)
N{
N    return timer->CNT;
N}
N
Nuint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq);
Nvoid TIMER_Close(TIMER_T *timer);
Nvoid TIMER_Delay(TIMER_T *timer, uint32_t u32Usec);
Nvoid TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge);
Nvoid TIMER_DisableCapture(TIMER_T *timer);
Nvoid TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge);
Nvoid TIMER_DisableEventCounter(TIMER_T *timer);
Nuint32_t TIMER_GetModuleClock(TIMER_T *timer);
N
N
N/*@}*/ /* end of group Mini58_TIMER_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group Mini58_TIMER_Driver */
N
N/*@}*/ /* end of group Mini58_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__TIMER_H__
N
N/*** (C) COPYRIGHT 2015 Nuvoton Technology Corp. ***/
L 11946 "..\Library\Device\Nuvoton\Mini58Series\Include\Mini58Series.h" 2
N#include "uart.h"
L 1 "..\Library\StdDriver\inc\uart.h" 1
N/**************************************************************************//**
N * @file     UART.h
N * @version  V1.00
N * $Revision: 3 $
N * $Date: 15/05/28 4:34p $ 
N * @brief    Mini58 series UART driver header file
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __UART_H__
N#define __UART_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Mini58_Device_Driver Mini58 Device Driver
N  @{
N*/
N
N/** @addtogroup Mini58_UART_Driver UART Driver
N  @{
N*/
N
N/** @addtogroup Mini58_UART_EXPORTED_CONSTANTS UART Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART_FIFO constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define UART_FIFO_RFITL_1BYTE        (0x0 << UART_FIFO_RFITL_Pos)   /*!< UART_FIFO setting to set RX FIFO Trigger Level to 1 bit */
N#define UART_FIFO_RFITL_4BYTES       (0x1 << UART_FIFO_RFITL_Pos)   /*!< UART_FIFO setting to set RX FIFO Trigger Level to 4 bits */
N#define UART_FIFO_RFITL_8BYTES       (0x2 << UART_FIFO_RFITL_Pos)   /*!< UART_FIFO setting to set RX FIFO Trigger Level to 8 bits */
N#define UART_FIFO_RFITL_14BYTES      (0x3 << UART_FIFO_RFITL_Pos)   /*!< UART_FIFO setting to set RX FIFO Trigger Level to 14 bits */
N
N#define UART_FIFO_RTSTRGLV_1BYTE        (0x0 << UART_FIFO_RTSTRGLV_Pos)  /*!< UART_FIFO setting to set RTS Trigger Level to 1 bit */
N#define UART_FIFO_RTSTRGLV_4BYTES       (0x1 << UART_FIFO_RTSTRGLV_Pos)  /*!< UART_FIFO setting to set RTS Trigger Level to 4 bits */
N#define UART_FIFO_RTSTRGLV_8BYTES       (0x2 << UART_FIFO_RTSTRGLV_Pos)  /*!< UART_FIFO setting to set RTS Trigger Level to 8 bits */
N#define UART_FIFO_RTSTRGLV_14BYTES      (0x3 << UART_FIFO_RTSTRGLV_Pos)  /*!< UART_FIFO setting to set RTS Trigger Level to 14 bits */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART_LINE constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_WORD_LEN_5        (0) /*!< UART_LINE setting to set UART word length to 5 bits */
N#define UART_WORD_LEN_6        (1) /*!< UART_LINE setting to set UART word length to 6 bits */
N#define UART_WORD_LEN_7        (2) /*!< UART_LINE setting to set UART word length to 7 bits */
N#define UART_WORD_LEN_8        (3) /*!< UART_LINE setting to set UART word length to 8 bits */
N
N#define UART_PARITY_NONE    (0x0 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to set UART as no parity   */
N#define UART_PARITY_ODD     (0x1 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to set UART as odd parity  */
N#define UART_PARITY_EVEN    (0x3 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to set UART as even parity */
N#define UART_PARITY_MARK    (0x5 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to keep parity bit as '1'  */
N#define UART_PARITY_SPACE   (0x7 << UART_LINE_PBE_Pos) /*!< UART_LINE setting to keep parity bit as '0'  */
N
N#define UART_STOP_BIT_1     (0x0 << UART_LINE_NSB_Pos) /*!< UART_LINE setting for one stop bit  */
N#define UART_STOP_BIT_1_5   (0x1 << UART_LINE_NSB_Pos) /*!< UART_LINE setting for 1.5 stop bit when 5-bit word length  */
N#define UART_STOP_BIT_2     (0x1 << UART_LINE_NSB_Pos) /*!< UART_LINE setting for two stop bit when 6, 7, 8-bit word length */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART RTS LEVEL TRIGGER constants definitions                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_RTS_IS_HIGH_LEV_TRG    (0x1 << UART_MODEM_RTSACTLV_Pos) /*!< Set RTS is High Level Trigger   */
N#define UART_RTS_IS_LOW_LEV_TRG     (0x0 << UART_MODEM_RTSACTLV_Pos) /*!< Set RTS is Low Level Trigger    */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FUNC_SEL constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_FUNC_SEL_UART    (0x0 << UART_FUNSEL_FUN_SEL_Pos) /*!< UART_FUNCSEL setting to set UART Function  (Default) */
N#define UART_FUNC_SEL_IrDA    (0x2 << UART_FUNSEL_FUN_SEL_Pos) /*!< UART_FUNCSEL setting to set IrDA Function            */
N#define UART_FUNC_SEL_RS485   (0x3 << UART_FUNSEL_FUN_SEL_Pos) /*!< UART_FUNCSEL setting to set RS485 Function           */
N
N
N/*@}*/ /* end of group Mini58_UART_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup Mini58_UART_EXPORTED_FUNCTIONS UART Exported Functions
N  @{
N*/
N
N/**
N *    @brief    Calculate UART baudrate mode0 divider
N *
N *    @param    None
N *    
N *    @return    UART baudrate mode0 register setting value
N *    
N */
N#define UART_BAUD_MODE0        (0)
N
N/**
N *    @brief    Calculate UART baudrate mode0 divider
N *
N *    @param    None
N *    
N *    @return    UART baudrate mode2 register setting value
N *    
N */
N#define UART_BAUD_MODE2        (UART_BAUD_BAUDM1_Msk | UART_BAUD_BAUDM0_Msk)
N
N
N/**
N *    @brief    Calculate UART baudrate mode0 divider
N *
N *    @param[in]    u32SrcFreq      UART clock frequency
N *    @param[in]    u32BaudRate     Baudrate of UART module
N *    
N *    @return    UART baudrate mode0 divider
N *    
N */
N#define UART_BAUD_MODE0_DIVIDER(u32SrcFreq, u32BaudRate)    (((u32SrcFreq + (u32BaudRate*8)) / u32BaudRate >> 4)-2)
N
N/**
N *    @brief    Calculate UART baudrate mode2 divider
N *
N *    @param[in]    u32SrcFreq    UART clock frequency
N *    @param[in]    u32BaudRate    Baudrate of UART module
N *    
N *    @return    UART baudrate mode2 divider  
N */
N#define UART_BAUD_MODE2_DIVIDER(u32SrcFreq, u32BaudRate)    (((u32SrcFreq + (u32BaudRate/2)) / u32BaudRate)-2)     
N
N
N/**
N *    @brief    Write Data to Tx data register
N *
N *    @param[in]    uart        The base address of UART module.
N *    @param[in]    u8Data  Data byte to transmit 
N *                          
N *    @return    None
N */
N#define UART_WRITE(uart, u8Data)    (uart->DAT = (u8Data))
N
N/**
N *    @brief    Read Rx data register
N *
N *    @param[in]    uart        The base address of UART module. 
N *
N *    @return    The oldest data byte in RX FIFO 
N */
N#define UART_READ(uart)    (uart->DAT)
N
N
N/**
N *    @brief    Get Tx empty register value. 
N *
N *    @param[in]   uart        The base address of UART module  
N *
N *    @return    Tx empty register value. 
N */
N#define UART_GET_TX_EMPTY(uart)    (uart->FIFOSTS & UART_FIFOSTS_TXEMPTYF_Msk) 
N
N
N/**
N *    @brief    Get Rx empty register value. 
N *
N *    @param[in]    uart        The base address of UART module 
N * 
N *    @return    Rx empty register value.
N */
N#define UART_GET_RX_EMPTY(uart)    (uart->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk) 
N
N/**
N *    @brief    Check specified uart port transmission is over. 
N *
N *    @param[in]    uart        The base address of UART module 
N * 
N *    @return    TE_Flag.
N */
N#define UART_IS_TX_EMPTY(uart)    ((uart->FIFOSTS & UART_FIFOSTS_TXEMPTYF_Msk) >> UART_FIFOSTS_TXEMPTYF_Pos) 
N
N
N/**
N *    @brief    Wait specified uart port transmission is over 
N *
N *    @param[in]    uart        The base address of UART module 
N *
N *    @return    None 
N */
N#define UART_WAIT_TX_EMPTY(uart)    while(!(((uart->FIFOSTS) & UART_FIFOSTS_TXEMPTYF_Msk) >> UART_FIFOSTS_TXEMPTYF_Pos))
N                                     
N/**
N *    @brief    Check RDA_IF is set or not
N *
N *    @param[in]    uart        The base address of UART module 
N *
N *    @return     
N *            0 : The number of bytes in the RX FIFO is less than the RFITL  
N *            1 : The number of bytes in the RX FIFO equals or larger than RFITL
N */
N#define UART_IS_RX_READY(uart)    ((uart->INTSTS & UART_INTSTS_RDAIF_Msk)>>UART_INTSTS_RDAIF_Pos)
N
N
N/**
N *    @brief    Check TX FIFO is full or not 
N *
N *    @param[in]    uart        The base address of UART module 
N *
N *    @return     
N *            1 = TX FIFO is full
N *            0 = TX FIFO is not full
N */
N#define UART_IS_TX_FULL(uart)    ((uart->FIFOSTS & UART_FIFOSTS_TXFULL_Msk)>>UART_FIFOSTS_TXFULL_Pos)
N
N/**
N *    @brief    Check RX FIFO is full or not 
N *
N *    @param[in]    uart        The base address of UART module  
N *
N *    @return
N *            1 = RX FIFO is full
N *            0 = RX FIFO is not full
N *
N */
N#define UART_IS_RX_FULL(uart)    ((uart->FIFOSTS & UART_FIFOSTS_RXFULL_Msk)>>UART_FIFOSTS_RXFULL_Pos)
N
N
N/**
N *    @brief    Get Tx full register value 
N *
N *    @param[in]    uart        The base address of UART module 
N *
N *    @return    Tx full register value 
N */
N#define UART_GET_TX_FULL(uart)    (uart->FIFOSTS & UART_FIFOSTS_TXFULL_Msk)
N
N
N/**
N *    @brief    Get Rx full register value 
N *
N *    @param[in]    uart        The base address of UART module 
N *
N *    @return    Rx full register value 
N */
N#define UART_GET_RX_FULL(uart)    (uart->FIFOSTS & UART_FIFOSTS_RXFULL_Msk)
N
N
N/**
N *    @brief    Enable specified interrupt
N *
N *    @param[in]    uart        The base address of UART module  
N *    @param[in]    u32eIntSel    Interrupt type select 
N *                        - \ref UART_INTEN_TOCNTEN_Msk        : Rx Time Out interrupt
N *                        - \ref UART_INTEN_WKCTSIEN_Msk       : Wakeup interrupt
N *                        - \ref UART_INTEN_BUFERRIEN_Msk      : Buffer Error interrupt   
N *                        - \ref UART_INTEN_RXTOIEN_Msk        : Rx time-out interrupt       
N *                        - \ref UART_INTEN_MODEMIEN_Msk       : Modem interrupt           
N *                        - \ref UART_INTEN_RLSIEN_Msk         : Rx Line status interrupt                              
N *                        - \ref UART_INTEN_THREIEN_Msk        : Tx empty interrupt          
N *                        - \ref UART_INTEN_RDAIEN_Msk         : Rx ready interrupt           
N *
N *    @return    None                                                    
N */
N#define UART_ENABLE_INT(uart, u32eIntSel)    (uart->INTEN |= (u32eIntSel))
N
N
N/**
N *    @brief    Disable specified interrupt  
N *
N *    @param[in]    uart        The base address of UART module 
N *    @param[in]    u32eIntSel    Interrupt type select 
N *                        - \ref UART_INTEN_TOCNTEN_Msk        : Rx Time Out interrupt
N *                        - \ref UART_INTEN_WKCTSIEN_Msk       : Wakeup interrupt
N *                        - \ref UART_INTEN_BUFERRIEN_Msk      : Buffer Error interrupt   
N *                        - \ref UART_INTEN_RXTOIEN_Msk        : Rx time-out interrupt       
N *                        - \ref UART_INTEN_MODEMIEN_Msk       : Modem interrupt           
N *                        - \ref UART_INTEN_RLSIEN_Msk         : Rx Line status interrupt                              
N *                        - \ref UART_INTEN_THREIEN_Msk        : Tx empty interrupt          
N *                        - \ref UART_INTEN_RDAIEN_Msk         : Rx ready interrupt          
N *    @return    None                                                    
N */
N#define UART_DISABLE_INT(uart, u32eIntSel)    (uart->INTEN &= ~ (u32eIntSel))
N
N
N/**
N *    @brief    Get specified interrupt flag/status
N *
N *    @param[in]    uart            The base address of UART module 
N *    @param[in]    u32eIntTypeFlag    Interrupt Type Flag,should be   
N *                            - \ref UART_INTSTS_CTSWKIF_Msk       : nCTS Wake-Up Interrupt Flag
N *                            - \ref UART_INTSTS_BUFERRINT_Msk     : Buffer Error Interrupt Indicator
N *                            - \ref UART_INTSTS_RXTOINT_Msk       : Time-out Interrupt Indicator 
N *                            - \ref UART_INTSTS_MODEMINT_Msk      : MODEM Status Interrupt Indicator 
N *                            - \ref UART_INTSTS_RLSINT_Msk        : Receive Line Status Interrupt 
N *                            - \ref UART_INTSTS_THREINT_Msk       : Transmit Holding Register Empty Interrupt Indicator
N *                            - \ref UART_INTSTS_RDAINT_Msk        : Receive Data Available Interrupt Indicator 
N *                            - \ref UART_INTSTS_BUFERRIF_Msk      : Buffer Error Interrupt Flag   
N *                            - \ref UART_INTSTS_RXTOIF_Msk        : Rx time-out interrupt Flag   
N *                            - \ref UART_INTSTS_MODEMIF_Msk       : Modem interrupt Flag
N *                            - \ref UART_INTSTS_RLSIF_Msk         : Rx Line status interrupt Flag                              
N *                            - \ref UART_INTSTS_THREIF_Msk        : Tx empty interrupt Flag
N *                            - \ref UART_INTSTS_RDAIF_Msk         : Rx ready interrupt Flag 
N *
N *    @return
N *            0 = The specified interrupt is not happened. 
N *            1 = The specified interrupt is happened.                                                      
N */                                                                                      
N#define UART_GET_INT_FLAG(uart,u32eIntTypeFlag)    ((uart->INTSTS & (u32eIntTypeFlag))?1:0)
N
N
N/**
N *    @brief    Set RTS pin is low
N *
N *    @param[in]    uart        The base address of UART module 
N *    @return    None
N */ 
N__INLINE void UART_CLEAR_RTS(UART_T* uart)  
X__inline void UART_CLEAR_RTS(UART_T* uart)  
N{
N    uart->MODEM |= UART_MODEM_RTSACTLV_Msk;
X    uart->MODEM |= (0x1ul << (9));
N    uart->MODEM &= ~UART_MODEM_RTS_Msk;
X    uart->MODEM &= ~(0x1ul << (1));
N}
N
N/**
N *    @brief    Set RTS pin is high
N *
N *    @param[in]    uart        The base address of UART module 
N *    @return    None
N */ 
N__INLINE void UART_SET_RTS(UART_T* uart)
X__inline void UART_SET_RTS(UART_T* uart)
N{
N    uart->MODEM |= UART_MODEM_RTSACTLV_Msk | UART_MODEM_RTS_Msk;
X    uart->MODEM |= (0x1ul << (9)) | (0x1ul << (1));
N}
N
N/**
N *	@brief	Clear RS-485 Address Byte Detection Flag
N *
N *	@param[in]	uart	The base address of UART module 
N *	@return	None
N */                                                                                                                                 
N#define UART_RS485_CLEAR_ADDR_FLAG(uart)    (uart->FIFOSTS  |= UART_FIFOSTS_ADDRDETF_Msk)
N
N
N/**
N *    @brief    Get RS-485 Address Byte Detection Flag
N *
N *    @param[in]    uart        The base address of UART module 
N *    @return    RS-485 Address Byte Detection Flag
N */    
N#define UART_RS485_GET_ADDR_FLAG(uart)    ((uart->FIFOSTS  & UART_FIFOSTS_ADDRDETF_Msk) >> UART_FIFOSTS_ADDRDETF_Pos)
N
N
Nvoid UART_ClearIntFlag(UART_T* uart , uint32_t u32InterruptFlag);
Nvoid UART_Close(UART_T* uart );
Nvoid UART_DisableFlowCtrl(UART_T* uart );
Nvoid UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag );
Nvoid UART_EnableFlowCtrl(UART_T* uart );
Nvoid UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag );
Nvoid UART_Open(UART_T* uart, uint32_t u32baudrate);
Nuint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
Nvoid UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits);
Nvoid UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC);
Nvoid UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction);
Nvoid UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr);
Nuint32_t UART_Write(UART_T* uart,uint8_t *pu8TxBuf, uint32_t u32WriteBytes);
N
N
N/*@}*/ /* end of group Mini58_UART_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group Mini58_UART_Driver */
N
N/*@}*/ /* end of group Mini58_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__UART_H__
N
N/*** (C) COPYRIGHT 2015 Nuvoton Technology Corp. ***/
N
N
N
N
N
N
N
N
L 11947 "..\Library\Device\Nuvoton\Mini58Series\Include\Mini58Series.h" 2
N#include "wdt.h"
L 1 "..\Library\StdDriver\inc\wdt.h" 1
N/**************************************************************************//**
N * @file     wdt.h
N * @version  V1.00
N * $Revision: 2 $
N * $Date: 15/05/28 1:16p $ 
N * @brief    Mini58 series WDT driver header file
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __WDT_H__
N#define __WDT_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Mini58_Device_Driver Mini58 Device Driver
N  @{
N*/
N
N/** @addtogroup Mini58_WDT_Driver WDT Driver
N  @{
N*/
N
N/** @addtogroup Mini58_WDT_EXPORTED_CONSTANTS WDT Exported Constants
N  @{
N*/
N#define WDT_TIMEOUT_2POW4          (0UL << WDT_CTL_TOUTSEL_Pos) /*!< WDT setting for timeout interval = 2^4 * WDT clocks */
N#define WDT_TIMEOUT_2POW6          (1UL << WDT_CTL_TOUTSEL_Pos) /*!< WDT setting for timeout interval = 2^6 * WDT clocks */
N#define WDT_TIMEOUT_2POW8          (2UL << WDT_CTL_TOUTSEL_Pos) /*!< WDT setting for timeout interval = 2^8 * WDT clocks */
N#define WDT_TIMEOUT_2POW10         (3UL << WDT_CTL_TOUTSEL_Pos) /*!< WDT setting for timeout interval = 2^10 * WDT clocks */
N#define WDT_TIMEOUT_2POW12         (4UL << WDT_CTL_TOUTSEL_Pos) /*!< WDT setting for timeout interval = 2^12 * WDT clocks */
N#define WDT_TIMEOUT_2POW14         (5UL << WDT_CTL_TOUTSEL_Pos) /*!< WDT setting for timeout interval = 2^14 * WDT clocks */
N#define WDT_TIMEOUT_2POW16         (6UL << WDT_CTL_TOUTSEL_Pos) /*!< WDT setting for timeout interval = 2^16 * WDT clocks */
N#define WDT_TIMEOUT_2POW18         (7UL << WDT_CTL_TOUTSEL_Pos) /*!< WDT setting for timeout interval = 2^18 * WDT clocks */
N
N#define WDT_RESET_DELAY_3CLK        (3UL << WDT_ALTCTL_RSTDSEL_Pos)    /*!< WDT setting reset delay to 3 WDT clocks */
N#define WDT_RESET_DELAY_18CLK       (2UL << WDT_ALTCTL_RSTDSEL_Pos)    /*!< WDT setting reset delay to 18 WDT clocks */
N#define WDT_RESET_DELAY_130CLK      (1UL << WDT_ALTCTL_RSTDSEL_Pos)    /*!< WDT setting reset delay to 130 WDT clocks */
N#define WDT_RESET_DELAY_1026CLK     (0UL << WDT_ALTCTL_RSTDSEL_Pos)    /*!< WDT setting reset delay to 1026 WDT clocks */
N
N
N/*@}*/ /* end of group Mini58_WDT_EXPORTED_CONSTANTS */
N    
N    
N/** @addtogroup Mini58_WDT_EXPORTED_FUNCTIONS WDT Exported Functions
N  @{
N*/
N
N/** 
N  * @brief This macro clear WDT time-out reset system flag. 
N  * \hideinitializer
N  */
N#define WDT_CLEAR_RESET_FLAG()  (WDT->CTL = (WDT->CTL & ~(WDT_CTL_IF_Msk | WDT_CTL_WKF_Msk)) | WDT_CTL_RSTF_Msk)
N
N/** 
N  * @brief This macro clear WDT time-out interrupt flag. 
N  * \hideinitializer
N  */
N#define WDT_CLEAR_TIMEOUT_INT_FLAG() (WDT->CTL = (WDT->CTL & ~(WDT_CTL_RSTF_Msk | WDT_CTL_WKF_Msk)) | WDT_CTL_IF_Msk)
N
N/** 
N  * @brief This macro clear WDT time-out wake-up system flag. 
N  * \hideinitializer
N  */
N#define WDT_CLEAR_TIMEOUT_WAKEUP_FLAG() (WDT->CTL = (WDT->CTL & ~(WDT_CTL_RSTF_Msk | WDT_CTL_IF_Msk)) | WDT_CTL_WKF_Msk)
N
N/** 
N  * @brief This macro indicate WDT time-out to reset system or not.
N  * @return WDT reset system or not
N  * @retval 0 WDT did not cause system reset
N  * @retval 1 WDT caused system reset 
N  * \hideinitializer
N  */
N#define WDT_GET_RESET_FLAG() (WDT->CTL & WDT_CTL_RSTF_Msk ? 1 : 0)
N
N/** 
N  * @brief This macro indicate WDT time-out interrupt occurred or not.
N  * @return WDT time-out interrupt occurred or not
N  * @retval 0 WDT time-out interrupt did not occur
N  * @retval 1 WDT time-out interrupt occurred 
N  * \hideinitializer
N  */
N#define WDT_GET_TIMEOUT_INT_FLAG() (WDT->CTL & WDT_CTL_IF_Msk ? 1 : 0)
N
N/** 
N  * @brief This macro indicate WDT time-out waked system up or not
N  * @return WDT time-out waked system up or not
N  * @retval 0 WDT did not wake up system
N  * @retval 1 WDT waked up system
N  * \hideinitializer
N  */
N#define WDT_GET_TIMEOUT_WAKEUP_FLAG() (WDT->CTL & WDT_CTL_WKF_Msk ? 1 : 0)
N
N/** 
N  * @brief This macro is used to reset 18-bit WDT counter.
N  * @details If WDT is activated and enabled to reset system, software must reset WDT counter 
N  *  before WDT time-out plus reset delay reached. Or WDT generate a reset signal.
N  * \hideinitializer
N  */
N#define WDT_RESET_COUNTER() (WDT->CTL  = (WDT->CTL & ~(WDT_CTL_IF_Msk | WDT_CTL_WKF_Msk | WDT_CTL_RSTF_Msk)) | WDT_CTL_RSTCNT_Msk)
N
N
Nvoid  WDT_Open(uint32_t u32TimeoutInterval,
N                  uint32_t u32ResetDelay,
N                  uint32_t u32EnableReset,
N                  uint32_t u32EnableWakeup);  
Nvoid WDT_Close(void);
N
Nvoid WDT_EnableInt(void);
Nvoid WDT_DisableInt(void);
N
N/*@}*/ /* end of group Mini58_WDT_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group Mini58_WDT_Driver */
N
N/*@}*/ /* end of group Mini58_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__WDT_H__
N
N/*** (C) COPYRIGHT 2015 Nuvoton Technology Corp. ***/
L 11948 "..\Library\Device\Nuvoton\Mini58Series\Include\Mini58Series.h" 2
N#include "wwdt.h"
L 1 "..\Library\StdDriver\inc\wwdt.h" 1
N/**************************************************************************//**
N * @file     wwdt.h
N * @version  V1.00
N * $Revision: 1 $
N * $Date: 15/02/02 3:19p $
N * @brief    Mini58 series WWDT driver header file
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __WWDT_H__
N#define __WWDT_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Mini58_Device_Driver Mini58 Device Driver
N  @{
N*/
N
N/** @addtogroup Mini58_WWDT_Driver WWDT Driver
N  @{
N*/
N
N/** @addtogroup Mini58_WWDT_EXPORTED_CONSTANTS WWDT Exported Constants
N  @{
N*/
N#define WWDT_PRESCALER_1          (0UL << WWDT_CTL_PSCSEL_Pos)   ///< WWDT setting prescaler to 1     \hideinitializer 
N#define WWDT_PRESCALER_2          (1UL << WWDT_CTL_PSCSEL_Pos)   ///< WWDT setting prescaler to 2     \hideinitializer 
N#define WWDT_PRESCALER_4          (2UL << WWDT_CTL_PSCSEL_Pos)   ///< WWDT setting prescaler to 4     \hideinitializer 
N#define WWDT_PRESCALER_8          (3UL << WWDT_CTL_PSCSEL_Pos)   ///< WWDT setting prescaler to 8     \hideinitializer 
N#define WWDT_PRESCALER_16         (4UL << WWDT_CTL_PSCSEL_Pos)   ///< WWDT setting prescaler to 16    \hideinitializer 
N#define WWDT_PRESCALER_32         (5UL << WWDT_CTL_PSCSEL_Pos)   ///< WWDT setting prescaler to 32    \hideinitializer 
N#define WWDT_PRESCALER_64         (6UL << WWDT_CTL_PSCSEL_Pos)   ///< WWDT setting prescaler to 64    \hideinitializer 
N#define WWDT_PRESCALER_128        (7UL << WWDT_CTL_PSCSEL_Pos)   ///< WWDT setting prescaler to 128   \hideinitializer 
N#define WWDT_PRESCALER_192        (8UL << WWDT_CTL_PSCSEL_Pos)   ///< WWDT setting prescaler to 192   \hideinitializer 
N#define WWDT_PRESCALER_256        (9UL << WWDT_CTL_PSCSEL_Pos)   ///< WWDT setting prescaler to 256   \hideinitializer 
N#define WWDT_PRESCALER_384        (0xAUL << WWDT_CTL_PSCSEL_Pos) ///< WWDT setting prescaler to 384   \hideinitializer 
N#define WWDT_PRESCALER_512        (0xBUL << WWDT_CTL_PSCSEL_Pos) ///< WWDT setting prescaler to 512   \hideinitializer 
N#define WWDT_PRESCALER_768        (0xCUL << WWDT_CTL_PSCSEL_Pos) ///< WWDT setting prescaler to 768   \hideinitializer 
N#define WWDT_PRESCALER_1024       (0xDUL << WWDT_CTL_PSCSEL_Pos) ///< WWDT setting prescaler to 1024  \hideinitializer 
N#define WWDT_PRESCALER_1536       (0xEUL << WWDT_CTL_PSCSEL_Pos) ///< WWDT setting prescaler to 1536  \hideinitializer 
N#define WWDT_PRESCALER_2048       (0xFUL << WWDT_CTL_PSCSEL_Pos) ///< WWDT setting prescaler to 2048  \hideinitializer 
N
N#define WWDT_RELOAD_WORD          (0x00005AA5)                     ///< Fill this value to RLD register to reload WWDT counter  \hideinitializer 
N/*@}*/ /* end of group Mini58_WWDT_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup Mini58_WWDT_EXPORTED_FUNCTIONS WWDT Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro clear WWDT time-out reset system flag.
N  * @param None
N  * @return None
N  * \hideinitializer
N  */
N#define WWDT_CLEAR_RESET_FLAG()  (WWDT->STATUS = WWDT_STATUS_WWDTRF_Msk)
N
N/**
N  * @brief This macro clear WWDT compare match interrupt flag.
N  * @param None
N  * @return None
N  * \hideinitializer
N  */
N#define WWDT_CLEAR_INT_FLAG() (WWDT->STATUS = WWDT_STATUS_WWDTIF_Msk)
N
N/**
N  * @brief This macro is use to get WWDT time-out reset system flag.
N  * @return WWDT reset system or not
N  * @retval 0 WWDT did not cause system reset
N  * @retval 1 WWDT caused system reset
N  * \hideinitializer
N  */
N#define WWDT_GET_RESET_FLAG() (WWDT->STATUS & WWDT_STATUS_WWDTRF_Msk ? 1 : 0)
N
N/**
N  * @brief This macro is used to indicate WWDT compare match interrupt flag.
N  * @return WWDT compare match interrupt occurred or not
N  * @retval 0 WWDT compare match interrupt did not occur
N  * @retval 1 WWDT compare match interrupt occurred
N  * \hideinitializer
N  */
N#define WWDT_GET_INT_FLAG() (WWDT->STATUS & WWDT_STATUS_WWDTIF_Msk ? 1 : 0)
N
N/**
N  * @brief This macro to reflects current WWDT counter value
N  * @param None
N  * @return Return current WWDT counter value
N  * \hideinitializer
N  */
N#define WWDT_GET_COUNTER() (WWDT->CNT)
N
N/**
N  * @brief This macro is used to reload the WWDT counter value to 0x3F.
N  * @param None
N  * @return None
N  * @details After WWDT enabled, application must reload WWDT counter while
N  *          current counter is less than compare value and larger than 0,
N  *          otherwise WWDT will cause system reset.
N  * \hideinitializer
N  */
N#define WWDT_RELOAD_COUNTER() (WWDT->RLDCNT  = WWDT_RELOAD_WORD)
N
N
Nvoid WWDT_Open(uint32_t u32PreScale, uint32_t u32CmpValue, uint32_t u32EnableInt);
N
N
N/*@}*/ /* end of group Mini58_WWDT_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group Mini58_WWDT_Driver */
N
N/*@}*/ /* end of group Mini58_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__WWDT_H__
N
N/*** (C) COPYRIGHT 2015 Nuvoton Technology Corp. ***/
L 11949 "..\Library\Device\Nuvoton\Mini58Series\Include\Mini58Series.h" 2
N
N#endif  // __MINI58SERIES_H__
N
N/*** (C) COPYRIGHT 2015-2016 Nuvoton Technology Corp. ***/
N
L 7 "..\Bsp\bsp.h" 2
N#include "gpio.h"
N#include "clk.h"
N#include "sys.h"
N#include "uart.h"
N#include "timer.h"
N#include "pwm.h"
N#include "fmc.h"
N
N#include "lite-log.h"
L 1 "..\utils\inc\lite-log.h" 1
N/*
N * Copyright (c) 2014-2016 Alibaba Group. All rights reserved.
N * License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *    http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N */
N
N#ifndef __LITE_LOG_H__
N#define __LITE_LOG_H__
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {
N#endif
N
N#include <stdint.h>
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 27 "..\utils\inc\lite-log.h" 2
N#include <string.h>
N#include <stdio.h>
N
N#define LITE_printf                     printf
N#define LITE_sprintf                    sprintf
N#define LITE_snprintf                   snprintf
N
Ntypedef enum _LOGLEVEL {
N	LOG_EMERG_LEVEL = 0, /* OS system is unavailable */
N	LOG_CRIT_LEVEL, /* current application aborting */
N	LOG_ERR_LEVEL, /* current app-module error */
N	LOG_WARNING_LEVEL, /* using default parameters */
N	LOG_INFO_LEVEL, /* running messages */
N	LOG_DEBUG_LEVEL, /* debugging messages */
N} LOGLEVEL;
N
Nvoid LITE_openlog(const char *ident);
Nvoid LITE_closelog(void);
Nint LITE_log_enabled(void);
Nchar *LITE_get_logname(void);
Nint LITE_get_loglevel(void);
Nvoid LITE_set_loglevel(int level);
Nint LITE_hexdump(const char *title, const void *buf, const int len);
N
Nvoid LITE_syslog(const char *f, const int l, const int level, const char *fmt,
N		...);
N#define log_emerg(args...)      LITE_syslog(__FUNCTION__, __LINE__, LOG_EMERG_LEVEL, args)
N#define log_crit(args...)       LITE_syslog(__FUNCTION__, __LINE__, LOG_CRIT_LEVEL, args)
N#define log_err(args...)        LITE_syslog(__FUNCTION__, __LINE__, LOG_ERR_LEVEL, args)
N#define log_warning(args...)    LITE_syslog(__FUNCTION__, __LINE__, LOG_WARNING_LEVEL, args)
N#define log_info(args...)       LITE_syslog(__FUNCTION__, __LINE__, LOG_INFO_LEVEL, args)
N#define log_debug(args...)      LITE_syslog(__FUNCTION__, __LINE__, LOG_DEBUG_LEVEL, args)
N
Nint log_multi_line_internal(const char *f, const int l, const char *title,
N		int level, char *payload, const char *mark);
N#define log_multi_line(level, title, fmt, payload, mark) \
N    log_multi_line_internal(__func__, __LINE__, title, level, payload, mark)
X#define log_multi_line(level, title, fmt, payload, mark)     log_multi_line_internal(__func__, __LINE__, title, level, payload, mark)
N
Nvoid LITE_rich_hexdump(const char *f, const int l, const int level,
N		const char *buf_str, const void *buf_ptr, const int buf_len);
N
N#if defined(__GLIBC__)
X#if 0L
S#define HEXDUMP_DEBUG(buf, len) \
S    LITE_rich_hexdump(__func__, __LINE__, LOG_DEBUG_LEVEL, #buf, (const void *)buf, (const int)len)
X#define HEXDUMP_DEBUG(buf, len)     LITE_rich_hexdump(__func__, __LINE__, LOG_DEBUG_LEVEL, #buf, (const void *)buf, (const int)len)
S
S#define HEXDUMP_INFO(buf, len)      \
S    LITE_rich_hexdump(__func__, __LINE__, LOG_INFO_LEVEL, #buf, (const void *)buf, (const int)len)
X#define HEXDUMP_INFO(buf, len)          LITE_rich_hexdump(__func__, __LINE__, LOG_INFO_LEVEL, #buf, (const void *)buf, (const int)len)
N#else
N#define HEXDUMP_DEBUG(buf, len) \
N    LITE_rich_hexdump(__func__, __LINE__, LOG_DEBUG_LEVEL, #buf, buf, len)
X#define HEXDUMP_DEBUG(buf, len)     LITE_rich_hexdump(__func__, __LINE__, LOG_DEBUG_LEVEL, #buf, buf, len)
N
N#define HEXDUMP_INFO(buf, len)      \
N    LITE_rich_hexdump(__func__, __LINE__, LOG_INFO_LEVEL, #buf, buf, len)
X#define HEXDUMP_INFO(buf, len)          LITE_rich_hexdump(__func__, __LINE__, LOG_INFO_LEVEL, #buf, buf, len)
N#endif
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif
N#endif  /* __LITE_LOG_H__ */
L 16 "..\Bsp\bsp.h" 2
N
N#include "bsp_2d4.h"
L 1 "..\Bsp\inc\bsp_2d4.h" 1
N/*
N * bsp_bt.h
N *
N *  Created on: 2017年6月26日
N *      Author: fly
N */
N
N#ifndef BSP_INC_BSP_2D4_H_
N#define BSP_INC_BSP_2D4_H_
N
N#define         CSN_HIGH                (P04 = 1)
N#define         CSN_LOW                 (P04 = 0)
N#define         SCK_HIGH                P07 = 1;delay_2d4(1)
N#define         SCK_LOW                 P07 = 0;delay_2d4(1)
N
N#define         SPI_DATA_HIGH           (P05 = 1)
N#define         SPI_DATA_LOW            (P05 = 0)
N#define         SPI_DATA_STATUS         (P05)
N#define         SPI_DATA_OUTPUT_MODE     GPIO_SetMode(P0, BIT5, GPIO_MODE_OUTPUT);
N#define         SPI_DATA_INPUT_MODE      GPIO_SetMode(P0, BIT5, GPIO_MODE_INPUT);
N#define         CE_HIGH                  RF_WriteReg(CE_FSPI_ON, 0)
N#define         CE_LOW                   RF_WriteReg(CE_FSPI_OFF, 0)
N////////////////////////////////////////////////////////////////////////////////
N//                    以下为声明部分，不建议修改                              //
N////////////////////////////////////////////////////////////////////////////////
N
N/********************SPI  REGISTER  ********************/
N#define		R_REGISTER			0x00                            //SPI read RF data
N#define		W_REGISTER			0x20                            //SPI write RF data
N#define		R_RX_PAYLOAD		0x61                            //Read RX Payload
N#define		W_TX_PAYLOAD		0xA0                            //Write TX Payload
N#define		FLUSH_TX			0xE1                            //Flush RX FIFO
N#define		FLUSH_RX			0xE2                            //Flush TX FIFO
N#define		REUSE_TX_PL			0xE3                            //Reuse TX Payload
N#define		ACTIVATE			0x50                            //ACTIVATE
N#define		DEACTIVATE			0x50                            //DEACTIVATE
N#define		R_RX_PL_WID			0x60                            //Read width of RX data
N#define		W_ACK_PAYLOAD		        0xA8                            //Data with ACK
N#define		W_TX_PAYLOAD_NOACK	        0xB0                            //TX Payload no ACK Request
N#define		CE_FSPI_ON	                0xFD                            // CE HIGH
N#define		CE_FSPI_OFF	                0xFC                            // CE LOW
N#define		RST_FSPI	                0x53                            // RESET
N#define		NOP_N				0xFF
N
N/******************CONTROL  REGISTER*******************/
N#define		CONFIG              0x00
N#define		EN_AA				0x01
N#define		EN_RXADDR			0x02
N#define		SETUP_AW			0x03
N#define		SETUP_RETR			0x04
N#define		RF_CH				0x05
N#define		RF_SETUP			0x06
N#define		STATUS				0x07
N#define		OBSERVE_TX			0x08
N#define		DATAOUT			    0x09
N#define		RX_ADDR_P0			0x0A
N#define		RX_ADDR_P1			0x0B
N#define		RX_ADDR_P2			0x0C
N#define		RX_ADDR_P3			0x0D
N#define		RX_ADDR_P4			0x0E
N#define		RX_ADDR_P5			0x0F
N#define		TX_ADDR				0x10
N#define		RX_PW_P0			0x11
N#define		RX_PW_P1			0x12
N#define		RX_PW_P2			0x13
N#define		RX_PW_P3			0x14
N#define		RX_PW_P4			0x15
N#define		RX_PW_P5			0x16
N#define		FIFO_STATUS			0x17
N#define		DEMOD_CAL				0x19
N#define     RF_CAL2				0x1A
N#define     DEM_CAL2			0x1B
N#define		DYNPD				0x1C
N#define		FEATURE				0x1D
N#define		RF_CAL				0x1E
N#define		BB_CAL				0x1F
N
N/////////////////////////////////////////////////////////////////////////////////////
N/*************************CONTROL CMD***********************************************/
N#define         RF13dBm                         0x3F                            // 13dBm  发射档位功率设置
N#define         RF10dBm                         0X0F                            // 10dBm
N#define         RF8dBm                          0x15                            // 8dbm
N#define         RF7dBm                          0x07                            // 7dbm
N#define         RF5dBm                          0x2c                            // 5dbm
N#define         RF4dBm                          0x06                            // 4dbm
N#define         RF2dBm                          0x05                            // 2dbm
N#define         RF0dBm                          0X0B                            // 0dBm
N#define         RF_3dBm                         0x04                            // -3dBm
N#define         RF_6dBm                         0x0A                            // -6dBm
N#define         RF_10dBm                        0x02                            // -10dBm
N#define         RF_18dBm                        0x01                            // -18dBm
N#define         RF_30dBm                        0x00                            // -30dBm
N
N#define         DR_1M                           0X00				//通信速率 1Mbps
N#define         DR_2M                           0X40				//通信速率 2Mbps
N#define         DR_250K                         0XC0                            //通信速率 250Kbps
N#define         RX_DR_FLAG                      0X40                            // 接收中断标志位
N#define         TX_DS_FLAG                      0X20                            // 发送完成中断标志位
N#define         RX_TX_CMP_FLAG                  0X60                            // 发送接收完成中断标志位，ack_payload 模式下使用
N#define         MAX_RT_FLAG                     0X10                            // 发送重传超时中断标志位
N#define         TRANS_ENHANCE_MODE              1                               //传输类型增强型
N#define         TRANS_BURST_MODE                2                               //传输类型普通型
N///////////////////////////////////////////////////////////////////////////////
N//                  根据用户应用，以下部分可能需要修改                       //
N///////////////////////////////////////////////////////////////////////////////
N/******************* Function declare *******************/
Nvoid Wireless2d4_InitHard(void);
N
Nvoid SPI_WW(uint8_t R_REG);
Nvoid RF_WriteReg(uint8_t reg, uint8_t wdata);
Nvoid RF_WriteBuf(uint8_t reg, uint8_t *pBuf, uint8_t length);
Nvoid SPI_WR(uint8_t R_REG);
Nuint8_t ucSPI_Read(void);
Nuint8_t ucRF_ReadReg(uint8_t reg);
Nvoid RF_ReadBuf(uint8_t reg, uint8_t *pBuf, uint8_t length);
Nvoid RF_TxMode(void);
Nvoid RF_RxMode(void);
Nuint8_t ucRF_GetStatus(void);
Nuint8_t ucRF_GetRSSI(void);
Nvoid RF_ClearStatus(void);
Nvoid RF_ClearFIFO(void);
Nvoid RF_SetChannel(uint8_t Channel);
Nvoid RF_TxData(uint8_t *ucPayload, uint8_t length);
Nuint8_t ucRF_DumpRxData(uint8_t *ucPayload, uint8_t length);
Nvoid RF_Carrier(uint8_t ucChannel_Set);
Nvoid RF_Init(void);
N
N/******************Parameter define **********************/
N
N#define         DEFAULT_CHANNEL                78				//初始化时的频率： 2478 MHz
N#define         PAYLOAD_WIDTH                  16				//Payload宽度：    8bytes
N#define         TRANSMIT_TYPE                  TRANS_BURST_MODE 		//使用普通型模式    TRANS_BURST_MODE    TRANS_ENHANCE_MODE
N#define         DATA_RATE                      DR_1M                            //通信速率1Mbps       DR_2M    DR_1M  DR_250K
N#define         RF_POWER                      (RF13dBm |DATA_RATE)		//发射功率13dBm
N
N#endif /* BSP_INC_BSP_2D4_H_ */
L 18 "..\Bsp\bsp.h" 2
N//#include "bsp_uart.h"
N#include "bsp_timer0.h"
L 1 "..\Bsp\inc\bsp_timer0.h" 1
N/*
N * bsp_timer0.h
N *
N *  Created on: 2017年6月28日
N *      Author: fly
N */
N
N#ifndef BSP_INC_BSP_TIMER0_H_
N#define BSP_INC_BSP_TIMER0_H_
N
Ntypedef struct {
N
N//	uint8_t cnt_1ms;
N	uint8_t flag_1ms;
N
N	uint8_t cnt_10ms;
N	uint8_t flag_10ms;
N
N	uint8_t cnt_100ms;
N	uint8_t flag_100ms;
N
N	uint8_t cnt_500ms;
N	uint8_t flag_500ms;
N
N	uint16_t cnt_1s;
N	uint8_t flag_1s;
N
N} Task_time;
N
N//extern _Task_time Task_time;
N
Nvoid Timer0_InitHard(void);
NTask_time* timer0_taskTimer_get(void);
N
N#endif /* BSP_INC_BSP_TIMER0_H_ */
L 20 "..\Bsp\bsp.h" 2
N#include "bsp_light.h"
L 1 "..\Bsp\inc\bsp_light.h" 1
N/*
N * bsp_light.h
N *
N *  Created on: 2017年8月18日
N *      Author: fly
N */
N
N#ifndef BSP_INC_BSP_LIGHT_H_
N#define BSP_INC_BSP_LIGHT_H_
N
Nvoid Light_InitHard(void);
N//void Light_Red_set(uint16_t duty);
N//void Light_Green_set(uint16_t duty);
N//void Light_Blue_set(uint16_t duty);
Nvoid Light_RGB_set(uint16_t r, uint16_t g, uint16_t b);
Nvoid Light_bright_set(uint8_t br);
N
N#endif /* BSP_INC_BSP_LIGHT_H_ */
L 21 "..\Bsp\bsp.h" 2
N#include "bsp_relay.h"
L 1 "..\Bsp\inc\bsp_relay.h" 1
N/*
N * bsp_relay.h
N *
N *  Created on: 2017年8月18日
N *      Author: fly
N */
N
N#ifndef BSP_INC_BSP_RELAY_H_
N#define BSP_INC_BSP_RELAY_H_
N
Nvoid Relay_InitHard(void);
Nvoid Relay_on(void);
Nvoid Relay_off(void);
Nvoid Relay_toggle(void);
Nuint8_t Relay_IsOn(void);
Nvoid Relay_set(uint8_t s);
N
N#endif /* BSP_INC_BSP_RELAY_H_ */
L 22 "..\Bsp\bsp.h" 2
N#include "bsp_eeprom.h"
L 1 "..\Bsp\inc\bsp_eeprom.h" 1
N/*
N * bsp_eeprom.h
N *
N *  Created on: 2017年9月8日
N *      Author: fly
N */
N
N#ifndef BSP_INC_BSP_EEPROM_H_
N#define BSP_INC_BSP_EEPROM_H_
N
N//#define DOME_START_ADDR   0x3C00  //use 3KB
N//#define DOME_START_ADDR   0x3E00  //use 2.5KB
N#define DOME_START_ADDR   0x6C00  //use 5KB
N
N
Nvoid EEPROM_InitHard(void);
N
Nvoid bsp_eeprom_write_int(uint32_t u32addr, uint32_t u32data);
Nint32_t bsp_eeprom_erase(uint32_t u32addr);
Nuint32_t bsp_eeprom_read_int(uint32_t u32Addr);
N
N#endif /* BSP_INC_BSP_EEPROM_H_ */
L 23 "..\Bsp\bsp.h" 2
N#include "bsp_key.h"
L 1 "..\Bsp\inc\bsp_key.h" 1
N/*
N *********************************************************************************************************
N *
N *	模块名称 : 按键驱动模块
N *	文件名称 : bsp_key.h
N *	版    本 : V1.0
N *	说    明 : 头文件
N *
N *********************************************************************************************************
N */
N
N#ifndef __BSP_KEY_H
N#define __BSP_KEY_H
N
N#define KEY_COUNT    2
N
N/* 根据应用程序的功能重命名按键宏 */
N#define KEY_DOWN_K1		KEY_1_DOWN
N#define KEY_UP_K1		KEY_1_UP
N#define KEY_LONG_K1		KEY_1_LONG
N
N#define KEY_DOWN_K2		KEY_2_DOWN
N#define KEY_UP_K2		KEY_2_UP
N#define KEY_LONG_K2		KEY_2_LONG
N
N
N/* 按键ID, 主要用于bsp_KeyState()函数的入口参数 */
Ntypedef enum {
N	KID_K1 = 0,
N	KID_K2,
N} KEY_ID_E;
N
N/*
N 按键滤波时间50ms, 单位10ms。
N 只有连续检测到50ms状态不变才认为有效，包括弹起和按下两种事件
N 即使按键电路不做硬件滤波，该滤波机制也可以保证可靠地检测到按键事件
N */
N#define KEY_FILTER_TIME   5
N#define KEY_LONG_TIME     100			/* 单位10ms， 持续1秒，认为长按事件 */
N
N/*
N 每个按键对应1个全局的结构体变量。
N */
Ntypedef struct {
N	/* 下面是一个函数指针，指向判断按键手否按下的函数 */
N	uint8_t (*IsKeyDownFunc)(void); /* 按键按下的判断函数,1表示按下 */
N
N	uint8_t Count; /* 滤波器计数器 */
N	uint16_t LongCount; /* 长按计数器 */
N	uint16_t LongTime; /* 按键按下持续时间, 0表示不检测长按 */
N	uint8_t State; /* 按键当前状态（按下还是弹起） */
N	uint8_t RepeatSpeed; /* 连续按键周期 */
N	uint8_t RepeatCount; /* 连续按键计数器 */
N} KEY_T;
N
N/*
N 定义键值代码, 必须按如下次序定时每个键的按下、弹起和长按事件
N
N 推荐使用enum, 不用#define，原因：
N (1) 便于新增键值,方便调整顺序，使代码看起来舒服点
N (2) 编译器可帮我们避免键值重复。
N */
Ntypedef enum {
N	KEY_NONE = 0, /* 0 表示按键事件 */
N
N	KEY_1_DOWN, /* 1键按下 */
N	KEY_1_UP, /* 1键弹起 */
N	KEY_1_LONG, /* 1键长按 */
N
N	KEY_2_DOWN, /* 2键按下 */
N	KEY_2_UP, /* 2键弹起 */
N	KEY_2_LONG, /* 2键长按 */
N} KEY_ENUM;
N
N/* 按键FIFO用到变量 */
N#define KEY_FIFO_SIZE	10
Ntypedef struct {
N	uint8_t Buf[KEY_FIFO_SIZE]; /* 键值缓冲区 */
X	uint8_t Buf[10];  
N	uint8_t Read; /* 缓冲区读指针1 */
N	uint8_t Write; /* 缓冲区写指针 */
N	uint8_t Read2; /* 缓冲区读指针2 */
N} KEY_FIFO_T;
N
N/* 供外部调用的函数声明 */
Nvoid bsp_InitKey(void);
Nvoid bsp_KeyScan(void);
Nvoid bsp_PutKey(uint8_t _KeyCode);
Nuint8_t bsp_GetKey(void);
Nuint8_t bsp_GetKey2(void);
Nuint8_t bsp_GetKeyState(KEY_ID_E _ucKeyID);
Nvoid bsp_SetKeyParam(uint8_t _ucKeyID, uint16_t _LongTime, uint8_t _RepeatSpeed);
Nvoid bsp_ClearKey(void);
N
N#endif
N
N/*****************************(END OF FILE) *********************************/
L 24 "..\Bsp\bsp.h" 2
N#include "bsp_uart_fifo.h"
L 1 "..\Bsp\inc\bsp_uart_fifo.h" 1
N#ifndef _BSP_USART_FIFO_H_
N#define _BSP_USART_FIFO_H_
N
N#define	UART0_FIFO_EN	1
N#define	UART1_FIFO_EN	1
N
N///* RS485芯片发送使能GPIO, PB2 */
N//#define RCC_RS485_TXEN 	 RCC_APB2Periph_GPIOB
N//#define PORT_RS485_TXEN  GPIOB
N//#define PIN_RS485_TXEN	 GPIO_Pin_2
N
N//#define RS485_RX_EN()	PORT_RS485_TXEN->BRR = PIN_RS485_TXEN
N//#define RS485_TX_EN()	PORT_RS485_TXEN->BSRR = PIN_RS485_TXEN
N
N/* 定义端口号 */
Ntypedef enum {
N	COM0 = 0, COM1 = 1,
N} COM_PORT_E;
N
N
N#if UART0_FIFO_EN == 1
X#if 1 == 1
N#define UART0_BAUD			115200
N#define UART0_TX_BUF_SIZE	1*64
N#define UART0_RX_BUF_SIZE	1*64
N#endif
N
N#if UART1_FIFO_EN == 1
X#if 1 == 1
N#define UART1_BAUD			19200
N#define UART1_TX_BUF_SIZE	1*256
N#define UART1_RX_BUF_SIZE	1*256
N#endif
N
N/* 串口设备结构体 */
Ntypedef struct {
N	UART_T *uart; /* STM32内部串口设备指针 */
N	uint8_t *pTxBuf; /* 发送缓冲区 */
N	uint8_t *pRxBuf; /* 接收缓冲区 */
N	uint16_t usTxBufSize; /* 发送缓冲区大小 */
N	uint16_t usRxBufSize; /* 接收缓冲区大小 */
N	__IO uint16_t usTxWrite; /* 发送缓冲区写指针 */
X	volatile uint16_t usTxWrite;  
N	__IO uint16_t usTxRead; /* 发送缓冲区读指针 */
X	volatile uint16_t usTxRead;  
N	__IO uint16_t usTxCount; /* 等待发送的数据个数 */
X	volatile uint16_t usTxCount;  
N
N	__IO uint16_t usRxWrite; /* 接收缓冲区写指针 */
X	volatile uint16_t usRxWrite;  
N	__IO uint16_t usRxRead; /* 接收缓冲区读指针 */
X	volatile uint16_t usRxRead;  
N	__IO uint16_t usRxCount; /* 还未读取的新数据个数 */
X	volatile uint16_t usRxCount;  
N
N	void (*SendBefor)(void); /* 开始发送之前的回调函数指针（主要用于RS485切换到发送模式） */
N	void (*SendOver)(void); /* 发送完毕的回调函数指针（主要用于RS485将发送模式切换为接收模式） */
N	void (*ReciveNew)(uint8_t _byte); /* 串口收到数据的回调函数指针 */
N} UART_T_M;
N
Nvoid bsp_InitUart(void);
Nvoid comSendBuf(COM_PORT_E _ucPort, uint8_t *_ucaBuf, uint16_t _usLen);
Nvoid comSendChar(COM_PORT_E _ucPort, uint8_t _ucByte);
Nuint8_t comGetChar(COM_PORT_E _ucPort, uint8_t *_pByte);
N
Nvoid comClearTxFifo(COM_PORT_E _ucPort);
Nvoid comClearRxFifo(COM_PORT_E _ucPort);
N
N//void RS485_SendBuf(uint8_t *_ucaBuf, uint16_t _usLen);
N//void RS485_SendStr(char *_pBuf);
N
N//void bsp_Set485Baud(uint32_t _baud);
N
Nvoid bsp_SetUart1Baud(uint32_t _baud);
Nvoid bsp_SetUart2Baud(uint32_t _baud);
N
N#endif
N
N/***************************** 安富莱电子 www.armfly.com (END OF FILE) *********************************/
L 25 "..\Bsp\bsp.h" 2
N
N#define ENABLE_INT()	__set_PRIMASK(0)
N#define DISABLE_INT()	__set_PRIMASK(1)
N
Nvoid bsp_Init(void);
N
N#endif
N
N/***************************** (END OF FILE) *********************************/
L 18 "..\App\inc\app.h" 2
N//#include "app_repeat_exe.h"
N#include "app_work.h"
L 1 "..\App\inc\app_work.h" 1
N/*
N * app_work.h
N *
N *  Created on: 2017年7月6日
N *      Author: admin
N */
N
N#ifndef APP_INC_APP_WORK_H_
N#define APP_INC_APP_WORK_H_
N
Ntypedef struct _WORK_T {
N
N	uint8_t device_mode;
N	union {
N		uint8_t allbits;
N		struct {
N			unsigned DOME :1;
N			unsigned ra2 :1;
N			unsigned DEMO :1;
N			unsigned blinkEnable :1;
N			unsigned ra6 :1;
N			unsigned ra7 :1;
N			unsigned ra8 :1;
N			unsigned ra9 :1;
N		} bits;
N	} status;
N
N//	uint8_t mode;
N
N} WORK_T;
N
Ntypedef struct _LED_MODE_MSG_ST {
N
N	union {
N		uint8_t allbits;
N		struct {
N			unsigned pp :1;  //闪法关闭/开启。0：闪法正常工作，1：闪法暂停
N			unsigned ra2 :1;
N			unsigned ra3 :1;
N			unsigned ra5 :1;
N			unsigned ra6 :1;
N			unsigned ra7 :1;
N			unsigned ra8 :1;
N			unsigned ra9 :1;
N		} bits;
N	} status;
N
N//	uint8_t mode;
N
N} LED_MODE_MSG_ST;
N
Nextern WORK_T g_tWork;
N
Nvoid app_work_Init(void);
Nvoid app_work_1s_pro(void);
Nvoid app_work_100ms_pro(void);
N
N#endif /* APP_INC_APP_WORK_H_ */
L 20 "..\App\inc\app.h" 2
N#include "app_2d4.h"
L 1 "..\App\inc\app_2d4.h" 1
N/*
N * app_2d4.h
N *
N *  Created on: 2017年8月18日
N *      Author: fly
N */
N
N#ifndef APP_INC_APP_2D4_H_
N#define APP_INC_APP_2D4_H_
N
N#define LCD2LAMP_HEADER   0xF2
N#define LAMP2LCD_HEADER   0xF8
N/*
N #define POWER_SHORT_CMD      0xB1
N #define POWER_LONG_CMD      0xBA
N
N #define ACC_CMD        0xB6
N
N #define UP_CMD         0xB3
N #define DOWN_CMD       0xB4
N #define DOME_CMD       0xB9
N #define VOL_ADD_CMD    0xB5
N #define VOL_MINUS_CMD  0xB7
N
N #define PLAY_CMD       0xB2
N #define MODE_CMD       0xB8
N */
N/////////
N#define  KEY_POWER_SHORT_CMD      0x01
N//#define POWER_LONG_CMD      0xBA
N
N#define  KEY_ACC_CMD        0x09
N#define  KEY_DOME_CMD       0xB9
N
N#define  KEY_UP_CMD           0x02
N#define  KEY_DOWN_CMD         0x03
N#define  KEY_VOL_ADD_CMD      0x04
N#define  KEY_VOL_MINUS_CMD    0x05
N#define  KEY_PLAY_SHORT_CMD   0x06
N#define  KEY_PLAY_LONG_CMD    0x07
N#define  KEY_MODE_CMD         0x08
N///
N
N#define  RCV_POWER_STATUS_CMD                0x31
N#define  RCV_X_BOX_STATUS_CMD                0x32
N#define  RCV_BT_STATUS_CMD                   0x33
N#define  RCV_PLAY_PAUSE_STATUS_CMD           0x34
N#define  RCV_PREV_NEXT_CMD                   0x35
N
N#define  RCV_USB_PLAY_TIME_CMD               0x36
N#define  RCV_FM_HZ_CMD                       0x37
N#define  RCV_VOL_CMD                         0x38
N
N#define  MODE_CHANGE_CMD                     0x41
N
N#define  KEY_CARD_MODE_POWER_CMD           0x50
N#define  KEY_CARD_MODE_POWER_LONG_CMD      0x70
N#define  KEY_CARD_PREV_VOL_MINUS_CMD       0x51
N#define  KEY_CARD_PREV_VOL_MINUS_LONG_CMD  0x71
N#define  KEY_CARD_PLAY_BT_CALL_CMD         0x52
N#define  KEY_CARD_PLAY_BT_CALL_LONG_CMD    0x72
N#define  KEY_CARD_NEXT_VOL_ADD_CMD         0x53
N#define  KEY_CARD_NEXT_VOL_ADD_LONG_CMD    0x73
N
N#define  KEY_CARD_POWER_CMD              0x54
N#define  KEY_CARD_MODE_ADD_CMD           0x55
N
N#define  KEY_CARD_SPEED_ADD_CMD          0x56
N#define  KEY_CARD_DEMO_CMD               0x57
N#define  KEY_CARD_SPEED_MINUS_CMD        0x58
N
N#define  KEY_CARD_COLOR_ADD_CMD          0x59
N#define  KEY_CARD_MODE_CMD               0x5A
N#define  KEY_CARD_BRIGHT_ADD_CMD         0x5B
N
N#define  KEY_CARD_COLOR_MINUS_CMD        0x5C
N#define  KEY_CARD_BRIGHT_MINUS_CMD       0x5D
N
N#define  KEY_CARD_NUM_1_CMD              0x5E
N#define  KEY_CARD_NUM_1_LONG_CMD         0x7E
N#define  KEY_CARD_NUM_2_CMD              0x5F
N#define  KEY_CARD_NUM_3_CMD              0x60
N#define  KEY_CARD_NUM_4_CMD              0x61
N
N#define  APP_COLOR_ATLA_CMD       0x62
N#define  APP_BRIGHT_CMD           0x63
N#define  APP_SPEED_CMD            0x64
N#define  APP_FLASH_INDEX_CMD      0x65
N#define  APP_SWITCH_INDEX_CMD      0x66
N
N#define  LED_MODE_MSG_CMD      0xE0
N
N#define  DEVICE_STA_CMD      0xF0
N//extern uint8_t sendBuf[PAYLOAD_WIDTH];
N
Nvoid app_2d4_init(void);
Nvoid app_2d4_send(uint8_t *d, uint8_t len);
Nvoid app_2d4_pro(void);
N
N#endif /* APP_INC_APP_2D4_H_ */
L 21 "..\App\inc\app.h" 2
N#include "app_uart.h"
L 1 "..\App\inc\app_uart.h" 1
N/*
N * app_uart.h
N *
N *  Created on: 2017年8月31日
N *      Author: fly
N */
N
N#ifndef APP_INC_APP_UART_H_
N#define APP_INC_APP_UART_H_
N
N#define BT_MODE     0x01
N#define FM_MODE     0x02
N#define USB_MODE    0x03
N#define AUX_MODE    0x04
N#define DOME_MODE   0x05
N#define CALL_MODE   0x06
N
N
N#define BLINK_METHOD_CMD   0x12
N/*
N #define POWER_LONG_UART_CMD      0x31
N //#define POWER_LONG_UART_CMD      0xBA
N
N #define DOME_UART_CMD      0x32
N
N #define VOL_ADD_UART_CMD      0x36
N #define VOL_MINUS_UART_CMD    0x37
N
N #define UP_UART_CMD    0x34
N #define DOWN_UART_CMD    0x35
N
N #define PLAY_UART_CMD    0x38
N
N #define MODE_UART_CMD    0x39
N */
N
Ntypedef struct _Uart_ST {
N
N	uint8_t rxBuf[512];
N	uint8_t txBuf[256];
N
N	uint16_t pWrite;
N	uint16_t pRead;
N
N} Uart_ST;
N
Nvoid app_uart_Init(void);
Nvoid app_uart_send(uint8_t cmd, uint8_t *ptr, uint8_t len);
Nvoid app_uart_pro(void);
N
N#endif /* APP_INC_APP_UART_H_ */
L 22 "..\App\inc\app.h" 2
N#include "app_crc.h"
L 1 "..\App\inc\app_crc.h" 1
N/*
N * app_crc.h
N *
N *  Created on: 2017年8月31日
N *      Author: fly
N */
N
N#ifndef APP_INC_APP_CRC_H_
N#define APP_INC_APP_CRC_H_
N
Nuint8_t app_CalcCRC8(uint8_t *ptr, uint8_t len);
Nuint8_t app_CalcCRC8_cycle(uint8_t *ptr, uint16_t len, uint16_t pos,
N		uint16_t bufLen);
N
N#endif /* APP_INC_APP_CRC_H_ */
L 23 "..\App\inc\app.h" 2
N#include "app_dome.h"
L 1 "..\App\inc\app_dome.h" 1
N/*
N * app_dome.h
N *
N *  Created on: 2017年9月8日
N *      Author: fly
N */
N
N#ifndef APP_INC_APP_DOME_H_
N#define APP_INC_APP_DOME_H_
N
N//#define DOME_SPEED_MULTIPLE   2
N//#define DEFAULT_DOME_NUM   22  //use 2.5KB
N//#define DEFAULT_DOME_NUM   26  //use 3KB
N//#define DEFAULT_DOME_NUM   44  //use 5KB
N
N#pragma pack(1)
Ntypedef struct _DOME_PRO_T {
N	uint8_t currentDomeIndex;
N//	uint8_t currentSubDomeIndex;
N
N} DOME_PRO_T;
N#pragma pack()
N
N#pragma pack(1)
Ntypedef struct _SUBDOME_ASSIST_T {
N	uint8_t switch_flag;
N	uint32_t msCnt;
N	uint8_t stopTime;
N} SUBDOME_ASSIST_T;
N#pragma pack()
N///////
N#pragma pack(1)
Ntypedef struct _COLOR_T {
N	uint8_t R;
N	uint8_t G;
N	uint8_t B;
N} COLOR_T;
N#pragma pack()
N
N#pragma pack(1)
Ntypedef struct _SUBDOME_T {
N	uint8_t mode;
N	COLOR_T color1;
N	COLOR_T color2;
N	uint8_t repeate;
N	uint16_t speed;
N	uint8_t bright;
N	uint16_t offtime;
N} SUBDOME_T;
N#pragma pack()
N//typedef union _REPEAT_NUMBER_T {
N//	uint8_t datas;
N//	struct {
N//		unsigned repeat :4;
N//		unsigned number :4;
N//	} bits;
N//} REPEAT_NUMBER_T;
N
N#pragma pack(1)
Ntypedef struct _DOME_HEADER_T {
N	char name[8];
N	uint8_t index;  //刚加的
N	uint8_t repeat_number;  //闪法重复的次数，单元模式的数量
N} DOME_HEADER_T;
N#pragma pack()
N
N#pragma pack(1)
Ntypedef struct _DOME_DEFAULT_T {
N	DOME_HEADER_T header;
N	SUBDOME_T subdome[8];
N} DOME_DEFAULT_T;
N#pragma pack()
N
N#pragma pack(1)
Ntypedef struct _DOME_RUNNING_T {
N	uint8_t bright;
N	uint8_t speed;
N	struct {
N		uint16_t R;
N		uint16_t G;
N		uint16_t B;
N	} color;
N} DOME_RUNNING_T;
N#pragma pack()
N
Nextern uint8_t blink_number; //闪法的总数量
Nextern DOME_DEFAULT_T dome_blink;
Nextern DOME_RUNNING_T dome_running_param;
N
Nvoid app_dome_Init(void);
N
Nvoid app_color_blink_previous(void);
Nvoid app_color_blink_next(void);
N
Nvoid app_dome_start(uint8_t index);
Nvoid app_dome_previous(void);
Nvoid app_dome_next(void);
Nvoid app_dome_get_current_Name(uint8_t *name, uint8_t len);
Nvoid app_dome_start_current(void);
Nvoid app_dome_stop_current(void);
Nvoid app_dome_rgb(uint8_t r, uint8_t g, uint8_t b);
Nvoid app_dome_interrupter(void);
N
N#endif /* APP_INC_APP_DOME_H_ */
L 24 "..\App\inc\app.h" 2
N#include "app_eeprom.h"
L 1 "..\App\inc\app_eeprom.h" 1
N/*
N * app_eeprom.h
N *
N *  Created on: 2017年9月8日
N *      Author: fly
N */
N
N#ifndef APP_INC_APP_EEPROM_H_
N#define APP_INC_APP_EEPROM_H_
N
N
N
Nvoid app_eeprom_Init(void);
Nvoid app_eeprom_get_dome_with_index(DOME_DEFAULT_T* dd, uint8_t index);
N
Nvoid app_eeprom_erase(uint32_t addr);
Nvoid app_eeprom_write_int(uint32_t addr, uint32_t d);
Nuint32_t app_eeprom_read_int(uint32_t addr);
N
N#endif /* APP_INC_APP_EEPROM_H_ */
L 25 "..\App\inc\app.h" 2
N
N
N
N#endif /* APP_INC_APP_H_ */
N
L 8 "..\App\src\app_eeprom.c" 2
N#include <string.h>
N
Nvoid app_eeprom_Init(void) {
N
N}
N
Nvoid app_eeprom_get_dome_with_index(DOME_DEFAULT_T *dd, uint8_t index) {
N	uint8_t availableGroup = 0;
N	uint8_t minSpaceBytes = 0;
N	uint16_t i = 0;
N	uint8_t *pt;
N	if (sizeof(DOME_DEFAULT_T) % 4) {
N		minSpaceBytes = (sizeof(DOME_DEFAULT_T) / 4) * 4 + 4;
N	} else {
N		minSpaceBytes = sizeof(DOME_DEFAULT_T);
N	}
N	availableGroup = (FMC_APROM_END - DOME_START_ADDR) / minSpaceBytes;
X	availableGroup = (0x00008000UL - 0x6C00) / minSpaceBytes;
N
N	if (index >= availableGroup) {
N		index = 0;
N	}
N
N	pt = (uint8_t *) dd;
N	SYS_UnlockReg();
N	FMC_Open();
N	for (i = 0; i < (sizeof(DOME_DEFAULT_T) / 4); i++) {
N		uint8_t j = 0;
N		uint32_t dt = app_eeprom_read_int(index * minSpaceBytes + i * 4);
N		for (j = 0; j < 4; j++) {
N			*(pt + i * 4 + j) = (dt >> (j * 8)) & 0xFF;
N		}
N	}
N	if (sizeof(DOME_DEFAULT_T) % 4) {
N		uint32_t dt = app_eeprom_read_int(
N				index * minSpaceBytes + (sizeof(DOME_DEFAULT_T) / 4) * 4);
N		for (i = 0; i < (sizeof(DOME_DEFAULT_T) % 4); i++) {
N			*(pt + (sizeof(DOME_DEFAULT_T) / 4) * 4 + i) = (dt >> (i * 8))
N					& 0xFF;
N		}
N	}
N	FMC_Close();
N	SYS_LockReg();
N}
N
Nvoid app_eeprom_erase(uint32_t addr) {
N	bsp_eeprom_erase(DOME_START_ADDR + addr);
X	bsp_eeprom_erase(0x6C00 + addr);
N}
Nvoid app_eeprom_write_int(uint32_t addr, uint32_t d) {
N	bsp_eeprom_write_int(DOME_START_ADDR + addr, d);
X	bsp_eeprom_write_int(0x6C00 + addr, d);
N}
Nuint32_t app_eeprom_read_int(uint32_t addr) {
N	return bsp_eeprom_read_int(DOME_START_ADDR + addr);
X	return bsp_eeprom_read_int(0x6C00 + addr);
N}
N
