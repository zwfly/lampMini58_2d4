; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\bsp_uart_fifo.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\bsp_uart_fifo.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\Library\StdDriver\inc -I..\Library\CMSIS\Include -I..\Library\Device\Nuvoton\Mini58Series\Include -I..\Bsp -I..\Bsp\inc -I..\utils\inc -I..\App\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=523 --omf_browse=.\obj\bsp_uart_fifo.crf ..\Bsp\src\bsp_uart_fifo.c]
                          THUMB

                          AREA ||i.ComToUart||, CODE, READONLY, ALIGN=2

                  ComToUart PROC
;;;48      */
;;;49     UART_T_M *ComToUart(COM_PORT_E _ucPort) {
000000  2800              CMP      r0,#0
000002  d003              BEQ      |L1.12|
;;;50     	if (_ucPort == COM0) {
;;;51     #if UART0_FIFO_EN == 1
;;;52     		return &g_tUart0;
;;;53     #else
;;;54     		return 0;
;;;55     #endif
;;;56     	} else if (_ucPort == COM1) {
000004  2801              CMP      r0,#1
000006  d003              BEQ      |L1.16|
;;;57     #if UART1_FIFO_EN == 1
;;;58     		return &g_tUart1;
;;;59     #else
;;;60     		return 0;
;;;61     #endif
;;;62     	} else {
;;;63     		/* 不做任何处理 */
;;;64     		return 0;
000008  2000              MOVS     r0,#0
;;;65     	}
;;;66     }
00000a  4770              BX       lr
                  |L1.12|
00000c  4802              LDR      r0,|L1.24|
00000e  4770              BX       lr
                  |L1.16|
000010  4801              LDR      r0,|L1.24|
000012  30a8              ADDS     r0,r0,#0xa8           ;58
000014  4770              BX       lr
;;;67     
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      ||.bss||

                          AREA ||i.USART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART0_IRQHandler PROC
;;;491    #if UART0_FIFO_EN == 1
;;;492    void USART0_IRQHandler(void) {
000000  b510              PUSH     {r4,lr}
;;;493    	UartIRQ(&g_tUart0);
000002  4802              LDR      r0,|L2.12|
000004  f7fffffe          BL       UartIRQ
;;;494    }
000008  bd10              POP      {r4,pc}
;;;495    #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      ||.bss||

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;497    #if UART1_FIFO_EN == 1
;;;498    void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;499    {
;;;500    	UartIRQ(&g_tUart1);
000002  4802              LDR      r0,|L3.12|
000004  f7fffffe          BL       UartIRQ
;;;501    }
000008  bd10              POP      {r4,pc}
;;;502    #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      ||.bss||+0xa8

                          AREA ||i.UartIRQ||, CODE, READONLY, ALIGN=1

                  UartIRQ PROC
;;;406     */
;;;407    static void UartIRQ(UART_T_M *_pUart) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;408    	/* 处理接收中断  */
;;;409    	if (_pUart->uart->INTSTS & UART_INTSTS_RDAINT_Msk) {
000004  6800              LDR      r0,[r0,#0]
000006  69c0              LDR      r0,[r0,#0x1c]
000008  2500              MOVS     r5,#0
00000a  05c0              LSLS     r0,r0,#23
00000c  2800              CMP      r0,#0
00000e  db17              BLT      |L4.64|
000010  e01a              B        |L4.72|
                  |L4.18|
;;;410    		/* 从串口接收数据寄存器读取数据存放到接收FIFO */
;;;411    		uint8_t ch;
;;;412    
;;;413    		/* Get all the input characters */
;;;414    		while (UART_IS_RX_READY(_pUart->uart)) {
;;;415    			/* Get the character from UART Buffer */
;;;416    			ch = UART_READ(_pUart->uart);
000012  6800              LDR      r0,[r0,#0]
;;;417    			_pUart->pRxBuf[_pUart->usRxWrite] = ch;
000014  8ae2              LDRH     r2,[r4,#0x16]
000016  68a1              LDR      r1,[r4,#8]
000018  b2c0              UXTB     r0,r0                 ;416
00001a  5488              STRB     r0,[r1,r2]
;;;418    			if (++_pUart->usRxWrite >= _pUart->usRxBufSize) {
00001c  8ae1              LDRH     r1,[r4,#0x16]
00001e  1c49              ADDS     r1,r1,#1
000020  b28a              UXTH     r2,r1
000022  82e2              STRH     r2,[r4,#0x16]
000024  89e1              LDRH     r1,[r4,#0xe]
000026  428a              CMP      r2,r1
000028  d300              BCC      |L4.44|
;;;419    				_pUart->usRxWrite = 0;
00002a  82e5              STRH     r5,[r4,#0x16]
                  |L4.44|
;;;420    			}
;;;421    			if (_pUart->usRxCount < _pUart->usRxBufSize) {
00002c  8b62              LDRH     r2,[r4,#0x1a]
00002e  428a              CMP      r2,r1
000030  d202              BCS      |L4.56|
;;;422    				_pUart->usRxCount++;
000032  8b61              LDRH     r1,[r4,#0x1a]
000034  1c49              ADDS     r1,r1,#1
000036  8361              STRH     r1,[r4,#0x1a]
                  |L4.56|
;;;423    			}
;;;424    
;;;425    			/* 回调函数,通知应用程序收到新数据,一般是发送1个消息或者设置一个标记 */
;;;426    			//if (_pUart->usRxWrite == _pUart->usRxRead)
;;;427    			//if (_pUart->usRxCount == 1)
;;;428    			{
;;;429    				if (_pUart->ReciveNew) {
000038  6a61              LDR      r1,[r4,#0x24]
00003a  2900              CMP      r1,#0
00003c  d000              BEQ      |L4.64|
;;;430    					_pUart->ReciveNew(ch);
00003e  4788              BLX      r1
                  |L4.64|
000040  6820              LDR      r0,[r4,#0]            ;414
000042  69c1              LDR      r1,[r0,#0x1c]         ;414
000044  07c9              LSLS     r1,r1,#31             ;414
000046  d1e4              BNE      |L4.18|
                  |L4.72|
;;;431    				}
;;;432    			}
;;;433    
;;;434    		}
;;;435    	}
;;;436    	/* 处理发送缓冲区空中断 */
;;;437    	if (_pUart->uart->INTSTS & UART_INTSTS_THREINT_Msk) {
000048  6820              LDR      r0,[r4,#0]
00004a  69c1              LDR      r1,[r0,#0x1c]
00004c  0589              LSLS     r1,r1,#22
00004e  d511              BPL      |L4.116|
;;;438    		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;439    		if (_pUart->usTxCount == 0) {
000050  8aa1              LDRH     r1,[r4,#0x14]
000052  2900              CMP      r1,#0
000054  d00f              BEQ      |L4.118|
;;;440    			/* 发送缓冲区的数据已取完时， 禁止发送缓冲区空中断 （注意：此时最后1个数据还未真正发送完毕）*/
;;;441    //			USART_ITConfig(_pUart->uart, USART_IT_TXE, DISABLE);
;;;442    			UART_DisableInt(_pUart->uart, UART_INTEN_THREIEN_Msk);
;;;443    
;;;444    			/* 使能数据发送完毕中断 */
;;;445    //			USART_ITConfig(_pUart->uart, USART_IT_TC, ENABLE);
;;;446    //			UART_DisableInt(_pUart->uart, UART_INTEN_THREIEN_Msk);
;;;447    		} else {
;;;448    			/* 从发送FIFO取1个字节写入串口发送数据寄存器 */
;;;449    			UART_WRITE(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
000056  8a62              LDRH     r2,[r4,#0x12]
000058  6861              LDR      r1,[r4,#4]
00005a  5c89              LDRB     r1,[r1,r2]
00005c  6001              STR      r1,[r0,#0]
;;;450    			if (++_pUart->usTxRead >= _pUart->usTxBufSize) {
00005e  8a60              LDRH     r0,[r4,#0x12]
000060  1c40              ADDS     r0,r0,#1
000062  b280              UXTH     r0,r0
000064  8260              STRH     r0,[r4,#0x12]
000066  89a1              LDRH     r1,[r4,#0xc]
000068  4288              CMP      r0,r1
00006a  d300              BCC      |L4.110|
;;;451    				_pUart->usTxRead = 0;
00006c  8265              STRH     r5,[r4,#0x12]
                  |L4.110|
;;;452    			}
;;;453    			_pUart->usTxCount--;
00006e  8aa0              LDRH     r0,[r4,#0x14]
000070  1e40              SUBS     r0,r0,#1
000072  82a0              STRH     r0,[r4,#0x14]
                  |L4.116|
;;;454    		}
;;;455    	}
;;;456    #if 0
;;;457    	/* 数据bit位全部发送完毕的中断 */
;;;458    	else if (USART_GetITStatus(_pUart->uart, UART_IT_TC) != RESET) {
;;;459    		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;460    		if (_pUart->usTxCount == 0) {
;;;461    			/* 如果发送FIFO的数据全部发送完毕，禁止数据发送完毕中断 */
;;;462    			USART_ITConfig(_pUart->uart, UART_IT_TC, DISABLE);
;;;463    
;;;464    			/* 回调函数, 一般用来处理RS485通信，将RS485芯片设置为接收模式，避免抢占总线 */
;;;465    			if (_pUart->SendOver) {
;;;466    				_pUart->SendOver();
;;;467    			}
;;;468    		} else {
;;;469    			/* 正常情况下，不会进入此分支 */
;;;470    
;;;471    			/* 如果发送FIFO的数据还未完毕，则从发送FIFO取1个数据写入发送数据寄存器 */
;;;472    			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
;;;473    			if (++_pUart->usTxRead >= _pUart->usTxBufSize) {
;;;474    				_pUart->usTxRead = 0;
;;;475    			}
;;;476    			_pUart->usTxCount--;
;;;477    		}
;;;478    	}
;;;479    #endif
;;;480    }
000074  bd70              POP      {r4-r6,pc}
                  |L4.118|
000076  2102              MOVS     r1,#2                 ;442
000078  f7fffffe          BL       UART_DisableInt
00007c  bd70              POP      {r4-r6,pc}
;;;481    
                          ENDP


                          AREA ||i.UartVarInit||, CODE, READONLY, ALIGN=2

                  UartVarInit PROC
;;;175     */
;;;176    static void UartVarInit(void) {
000000  4916              LDR      r1,|L5.92|
;;;177    #if UART0_FIFO_EN == 1
;;;178    	g_tUart0.uart = UART0; /* STM32 串口设备 */
000002  4815              LDR      r0,|L5.88|
;;;179    	g_tUart0.pTxBuf = g_TxBuf0; /* 发送缓冲区指针 */
000004  6008              STR      r0,[r1,#0]  ; g_tUart0
000006  4608              MOV      r0,r1
000008  3028              ADDS     r0,r0,#0x28
;;;180    	g_tUart0.pRxBuf = g_RxBuf0; /* 接收缓冲区指针 */
00000a  6048              STR      r0,[r1,#4]  ; g_tUart0
00000c  3040              ADDS     r0,r0,#0x40
;;;181    	g_tUart0.usTxBufSize = UART0_TX_BUF_SIZE; /* 发送缓冲区大小 */
00000e  6088              STR      r0,[r1,#8]  ; g_tUart0
000010  2040              MOVS     r0,#0x40
000012  8188              STRH     r0,[r1,#0xc]
;;;182    	g_tUart0.usRxBufSize = UART0_RX_BUF_SIZE; /* 接收缓冲区大小 */
000014  81c8              STRH     r0,[r1,#0xe]
;;;183    	g_tUart0.usTxWrite = 0; /* 发送FIFO写索引 */
000016  2000              MOVS     r0,#0
000018  8208              STRH     r0,[r1,#0x10]
;;;184    	g_tUart0.usTxRead = 0; /* 发送FIFO读索引 */
00001a  8248              STRH     r0,[r1,#0x12]
;;;185    	g_tUart0.usRxWrite = 0; /* 接收FIFO写索引 */
00001c  82c8              STRH     r0,[r1,#0x16]
;;;186    	g_tUart0.usRxRead = 0; /* 接收FIFO读索引 */
00001e  8308              STRH     r0,[r1,#0x18]
;;;187    	g_tUart0.usRxCount = 0; /* 接收到的新数据个数 */
000020  8348              STRH     r0,[r1,#0x1a]
;;;188    	g_tUart0.usTxCount = 0; /* 待发送的数据个数 */
000022  8288              STRH     r0,[r1,#0x14]
;;;189    	g_tUart0.SendBefor = 0; /* 发送数据前的回调函数 */
;;;190    	g_tUart0.SendOver = 0; /* 发送完毕后的回调函数 */
000024  61c8              STR      r0,[r1,#0x1c]  ; g_tUart0
;;;191    	g_tUart0.ReciveNew = 0; /* 接收到新数据后的回调函数 */
000026  6208              STR      r0,[r1,#0x20]  ; g_tUart0
;;;192    #endif
;;;193    
;;;194    #if UART1_FIFO_EN == 1
;;;195    	g_tUart1.uart = UART1; /* STM32 串口设备 */
000028  6248              STR      r0,[r1,#0x24]  ; g_tUart0
00002a  4a0d              LDR      r2,|L5.96|
00002c  31a8              ADDS     r1,r1,#0xa8
;;;196    	g_tUart1.pTxBuf = g_TxBuf1; /* 发送缓冲区指针 */
00002e  600a              STR      r2,[r1,#0]  ; g_tUart1
000030  460a              MOV      r2,r1
000032  3228              ADDS     r2,r2,#0x28
;;;197    	g_tUart1.pRxBuf = g_RxBuf1; /* 接收缓冲区指针 */
000034  604a              STR      r2,[r1,#4]  ; g_tUart1
000036  32ff              ADDS     r2,r2,#0xff
000038  3201              ADDS     r2,#1
;;;198    	g_tUart1.usTxBufSize = UART1_TX_BUF_SIZE; /* 发送缓冲区大小 */
00003a  608a              STR      r2,[r1,#8]  ; g_tUart1
00003c  22ff              MOVS     r2,#0xff
00003e  3201              ADDS     r2,#1
000040  818a              STRH     r2,[r1,#0xc]
;;;199    	g_tUart1.usRxBufSize = UART1_RX_BUF_SIZE; /* 接收缓冲区大小 */
000042  81ca              STRH     r2,[r1,#0xe]
;;;200    	g_tUart1.usTxWrite = 0; /* 发送FIFO写索引 */
000044  8208              STRH     r0,[r1,#0x10]
;;;201    	g_tUart1.usTxRead = 0; /* 发送FIFO读索引 */
000046  8248              STRH     r0,[r1,#0x12]
;;;202    	g_tUart1.usRxWrite = 0; /* 接收FIFO写索引 */
000048  82c8              STRH     r0,[r1,#0x16]
;;;203    	g_tUart1.usRxRead = 0; /* 接收FIFO读索引 */
00004a  8308              STRH     r0,[r1,#0x18]
;;;204    	g_tUart1.usRxCount = 0; /* 接收到的新数据个数 */
00004c  8348              STRH     r0,[r1,#0x1a]
;;;205    	g_tUart1.usTxCount = 0; /* 待发送的数据个数 */
00004e  8288              STRH     r0,[r1,#0x14]
;;;206    	g_tUart1.SendBefor = 0; /* 发送数据前的回调函数 */
;;;207    	g_tUart1.SendOver = 0; /* 发送完毕后的回调函数 */
000050  61c8              STR      r0,[r1,#0x1c]  ; g_tUart1
;;;208    	g_tUart1.ReciveNew = 0; /* 接收到新数据后的回调函数 */
000052  6208              STR      r0,[r1,#0x20]  ; g_tUart1
000054  6248              STR      r0,[r1,#0x24]  ; g_tUart1
;;;209    #endif
;;;210    
;;;211    }
000056  4770              BX       lr
;;;212    
                          ENDP

                  |L5.88|
                          DCD      0x40050000
                  |L5.92|
                          DCD      ||.bss||
                  |L5.96|
                          DCD      0x40150000

                          AREA ||i.bsp_InitUart||, CODE, READONLY, ALIGN=2

                  bsp_InitUart PROC
;;;32      */
;;;33     void bsp_InitUart(void) {
000000  b570              PUSH     {r4-r6,lr}
;;;34     	UartVarInit(); /* 必须先初始化全局变量,再配置硬件 */
000002  f7fffffe          BL       UartVarInit
000006  4d16              LDR      r5,|L6.96|
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       CLK_EnableModuleClock
00000e  2401              MOVS     r4,#1
000010  0664              LSLS     r4,r4,#25
000012  2200              MOVS     r2,#0
000014  4621              MOV      r1,r4
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       CLK_SetModuleClock
00001c  4a12              LDR      r2,|L6.104|
00001e  4811              LDR      r0,|L6.100|
000020  6050              STR      r0,[r2,#4]
000022  0290              LSLS     r0,r2,#10
000024  f7fffffe          BL       SYS_ResetModule
000028  25e1              MOVS     r5,#0xe1
00002a  026d              LSLS     r5,r5,#9
00002c  4629              MOV      r1,r5
00002e  480f              LDR      r0,|L6.108|
000030  f7fffffe          BL       UART_Open
000034  4e0a              LDR      r6,|L6.96|
000036  1c76              ADDS     r6,r6,#1
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       CLK_EnableModuleClock
00003e  2200              MOVS     r2,#0
000040  4621              MOV      r1,r4
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       CLK_SetModuleClock
000048  2030              MOVS     r0,#0x30
00004a  2105              MOVS     r1,#5
00004c  0709              LSLS     r1,r1,#28
00004e  6388              STR      r0,[r1,#0x38]
000050  1220              ASRS     r0,r4,#8
000052  f7fffffe          BL       SYS_ResetModule
000056  4629              MOV      r1,r5
000058  4805              LDR      r0,|L6.112|
00005a  f7fffffe          BL       UART_Open
;;;35     
;;;36     	InitHardUart(); /* 配置串口的硬件参数(波特率等) */
;;;37     
;;;38     //	ConfigUartNVIC(); /* 配置串口中断 */
;;;39     }
00005e  bd70              POP      {r4-r6,pc}
;;;40     
                          ENDP

                  |L6.96|
                          DCD      0xa7803d10
                  |L6.100|
                          DCD      0x00000303
                  |L6.104|
                          DCD      0x50000040
                  |L6.108|
                          DCD      0x40050000
                  |L6.112|
                          DCD      0x40150000

                          AREA ||i.comClearRxFifo||, CODE, READONLY, ALIGN=1

                  comClearRxFifo PROC
;;;154     */
;;;155    void comClearRxFifo(COM_PORT_E _ucPort) {
000000  b500              PUSH     {lr}
;;;156    	UART_T_M *pUart;
;;;157    
;;;158    	pUart = ComToUart(_ucPort);
000002  f7fffffe          BL       ComToUart
;;;159    	if (pUart == 0) {
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L7.18|
;;;160    		return;
;;;161    	}
;;;162    
;;;163    	pUart->usRxWrite = 0;
00000a  2100              MOVS     r1,#0
00000c  82c1              STRH     r1,[r0,#0x16]
;;;164    	pUart->usRxRead = 0;
00000e  8301              STRH     r1,[r0,#0x18]
;;;165    	pUart->usRxCount = 0;
000010  8341              STRH     r1,[r0,#0x1a]
                  |L7.18|
;;;166    }
000012  bd00              POP      {pc}
;;;167    
                          ENDP


                          AREA ||i.comClearTxFifo||, CODE, READONLY, ALIGN=1

                  comClearTxFifo PROC
;;;133     */
;;;134    void comClearTxFifo(COM_PORT_E _ucPort) {
000000  b500              PUSH     {lr}
;;;135    	UART_T_M *pUart;
;;;136    
;;;137    	pUart = ComToUart(_ucPort);
000002  f7fffffe          BL       ComToUart
;;;138    	if (pUart == 0) {
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L8.18|
;;;139    		return;
;;;140    	}
;;;141    
;;;142    	pUart->usTxWrite = 0;
00000a  2100              MOVS     r1,#0
00000c  8201              STRH     r1,[r0,#0x10]
;;;143    	pUart->usTxRead = 0;
00000e  8241              STRH     r1,[r0,#0x12]
;;;144    	pUart->usTxCount = 0;
000010  8281              STRH     r1,[r0,#0x14]
                  |L8.18|
;;;145    }
000012  bd00              POP      {pc}
;;;146    
                          ENDP


                          AREA ||i.comGetChar||, CODE, READONLY, ALIGN=1

                  comGetChar PROC
;;;114     */
;;;115    uint8_t comGetChar(COM_PORT_E _ucPort, uint8_t *_pByte) {
000000  b510              PUSH     {r4,lr}
;;;116    	UART_T_M *pUart;
;;;117    
;;;118    	pUart = ComToUart(_ucPort);
000002  f7fffffe          BL       ComToUart
;;;119    	if (pUart == 0) {
000006  2800              CMP      r0,#0
000008  d01f              BEQ      |L9.74|
;;;120    		return 0;
;;;121    	}
;;;122    
;;;123    	return UartGetChar(pUart, _pByte);
00000a  4602              MOV      r2,r0
00000c  2001              MOVS     r0,#1
00000e  f3808810          MSR      PRIMASK,r0
000012  8b53              LDRH     r3,[r2,#0x1a]
000014  2000              MOVS     r0,#0
000016  f3808810          MSR      PRIMASK,r0
00001a  2b00              CMP      r3,#0
00001c  d015              BEQ      |L9.74|
00001e  8b14              LDRH     r4,[r2,#0x18]
000020  6893              LDR      r3,[r2,#8]
000022  5d1b              LDRB     r3,[r3,r4]
000024  700b              STRB     r3,[r1,#0]
000026  2101              MOVS     r1,#1
000028  f3818810          MSR      PRIMASK,r1
00002c  8b11              LDRH     r1,[r2,#0x18]
00002e  1c49              ADDS     r1,r1,#1
000030  b289              UXTH     r1,r1
000032  8311              STRH     r1,[r2,#0x18]
000034  89d3              LDRH     r3,[r2,#0xe]
000036  4299              CMP      r1,r3
000038  d300              BCC      |L9.60|
00003a  8310              STRH     r0,[r2,#0x18]
                  |L9.60|
00003c  8b50              LDRH     r0,[r2,#0x1a]
00003e  1e40              SUBS     r0,r0,#1
000040  8350              STRH     r0,[r2,#0x1a]
000042  2000              MOVS     r0,#0
000044  f3808810          MSR      PRIMASK,r0
000048  2001              MOVS     r0,#1
                  |L9.74|
;;;124    }
00004a  bd10              POP      {r4,pc}
;;;125    
                          ENDP


                          AREA ||i.comSendBuf||, CODE, READONLY, ALIGN=1

                  comSendBuf PROC
;;;77      */
;;;78     void comSendBuf(COM_PORT_E _ucPort, uint8_t *_ucaBuf, uint16_t _usLen) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
;;;79     	UART_T_M *pUart;
;;;80     
;;;81     	pUart = ComToUart(_ucPort);
000006  f7fffffe          BL       ComToUart
00000a  0004              MOVS     r4,r0
;;;82     	if (pUart == 0) {
00000c  d030              BEQ      |L10.112|
;;;83     		return;
;;;84     	}
;;;85     
;;;86     	if (pUart->SendBefor != 0) {
00000e  69e0              LDR      r0,[r4,#0x1c]
000010  2800              CMP      r0,#0
000012  d000              BEQ      |L10.22|
;;;87     		pUart->SendBefor(); /* 如果是RS485通信，可以在这个函数中将RS485设置为发送模式 */
000014  4780              BLX      r0
                  |L10.22|
000016  2000              MOVS     r0,#0
;;;88     	}
;;;89     
;;;90     	UartSend(pUart, _ucaBuf, _usLen);
000018  e024              B        |L10.100|
                  |L10.26|
00001a  89a2              LDRH     r2,[r4,#0xc]
                  |L10.28|
00001c  2101              MOVS     r1,#1
00001e  f3818810          MSR      PRIMASK,r1
000022  8aa1              LDRH     r1,[r4,#0x14]
000024  466b              MOV      r3,sp
000026  8019              STRH     r1,[r3,#0]
000028  2100              MOVS     r1,#0
00002a  f3818810          MSR      PRIMASK,r1
00002e  8819              LDRH     r1,[r3,#0]
000030  428a              CMP      r2,r1
000032  d9f3              BLS      |L10.28|
000034  5c31              LDRB     r1,[r6,r0]
000036  8a23              LDRH     r3,[r4,#0x10]
000038  6862              LDR      r2,[r4,#4]
00003a  54d1              STRB     r1,[r2,r3]
00003c  2101              MOVS     r1,#1
00003e  f3818810          MSR      PRIMASK,r1
000042  8a21              LDRH     r1,[r4,#0x10]
000044  1c49              ADDS     r1,r1,#1
000046  b289              UXTH     r1,r1
000048  8221              STRH     r1,[r4,#0x10]
00004a  89a2              LDRH     r2,[r4,#0xc]
00004c  4291              CMP      r1,r2
00004e  d301              BCC      |L10.84|
000050  2100              MOVS     r1,#0
000052  8221              STRH     r1,[r4,#0x10]
                  |L10.84|
000054  8aa1              LDRH     r1,[r4,#0x14]
000056  1c49              ADDS     r1,r1,#1
000058  82a1              STRH     r1,[r4,#0x14]
00005a  2100              MOVS     r1,#0
00005c  f3818810          MSR      PRIMASK,r1
000060  1c40              ADDS     r0,r0,#1
000062  b280              UXTH     r0,r0
                  |L10.100|
000064  42a8              CMP      r0,r5
000066  d3d8              BCC      |L10.26|
000068  2102              MOVS     r1,#2
00006a  6820              LDR      r0,[r4,#0]
00006c  f7fffffe          BL       UART_EnableInt
                  |L10.112|
;;;91     }
000070  bdf8              POP      {r3-r7,pc}
;;;92     
                          ENDP


                          AREA ||i.comSendChar||, CODE, READONLY, ALIGN=1

                  comSendChar PROC
;;;101     */
;;;102    void comSendChar(COM_PORT_E _ucPort, uint8_t _ucByte) {
000000  b513              PUSH     {r0,r1,r4,lr}
;;;103    	comSendBuf(_ucPort, &_ucByte, 1);
000002  2201              MOVS     r2,#1
000004  a901              ADD      r1,sp,#4
000006  f7fffffe          BL       comSendBuf
;;;104    }
00000a  bd1c              POP      {r2-r4,pc}
;;;105    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tUart0
                          %        40
                  g_TxBuf0
                          %        64
                  g_RxBuf0
                          %        64
                  g_tUart1
                          %        40
                  g_TxBuf1
                          %        256
                  g_RxBuf1
                          %        256

;*** Start embedded assembler ***

#line 1 "..\\Bsp\\src\\bsp_uart_fifo.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REV16|
#line 388 "..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_bsp_uart_fifo_c_b28b0d00____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH|
#line 402
|__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
