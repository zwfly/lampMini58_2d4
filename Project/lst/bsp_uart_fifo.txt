; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\bsp_uart_fifo.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\bsp_uart_fifo.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\Library\StdDriver\inc -I..\Library\CMSIS\Include -I..\Library\Device\Nuvoton\Mini58Series\Include -I..\Bsp -I..\Bsp\inc -I..\utils\inc -I..\App\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=523 --omf_browse=.\obj\bsp_uart_fifo.crf ..\Bsp\src\bsp_uart_fifo.c]
                          THUMB

                          AREA ||i.ComToUart||, CODE, READONLY, ALIGN=2

                  ComToUart PROC
;;;46      */
;;;47     UART_T_M *ComToUart(COM_PORT_E _ucPort) {
000000  2800              CMP      r0,#0
000002  d003              BEQ      |L1.12|
;;;48     	if (_ucPort == COM0) {
;;;49     #if UART0_FIFO_EN == 1
;;;50     		return &g_tUart0;
;;;51     #else
;;;52     		return 0;
;;;53     #endif
;;;54     	} else if (_ucPort == COM1) {
000004  2801              CMP      r0,#1
000006  d003              BEQ      |L1.16|
;;;55     #if UART1_FIFO_EN == 1
;;;56     		return &g_tUart1;
;;;57     #else
;;;58     		return 0;
;;;59     #endif
;;;60     	} else {
;;;61     		/* 不做任何处理 */
;;;62     		return 0;
000008  2000              MOVS     r0,#0
;;;63     	}
;;;64     }
00000a  4770              BX       lr
                  |L1.12|
00000c  4802              LDR      r0,|L1.24|
00000e  4770              BX       lr
                  |L1.16|
000010  4801              LDR      r0,|L1.24|
000012  30a8              ADDS     r0,r0,#0xa8           ;56
000014  4770              BX       lr
;;;65     
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      ||.bss||

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART0_IRQHandler PROC
;;;490    #if UART0_FIFO_EN == 1
;;;491    void UART0_IRQHandler(void) {
000000  b510              PUSH     {r4,lr}
;;;492    	UartIRQ(&g_tUart0);
000002  4802              LDR      r0,|L2.12|
000004  f7fffffe          BL       UartIRQ
;;;493    }
000008  bd10              POP      {r4,pc}
;;;494    #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      ||.bss||

                          AREA ||i.UART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART1_IRQHandler PROC
;;;496    #if UART1_FIFO_EN == 1
;;;497    void UART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;498    {
;;;499    	UartIRQ(&g_tUart1);
000002  4802              LDR      r0,|L3.12|
000004  f7fffffe          BL       UartIRQ
;;;500    }
000008  bd10              POP      {r4,pc}
;;;501    #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      ||.bss||+0xa8

                          AREA ||i.UartIRQ||, CODE, READONLY, ALIGN=1

                  UartIRQ PROC
;;;406     */
;;;407    static void UartIRQ(UART_T_M *_pUart) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;408    	/* 处理接收中断  */
;;;409    	if (_pUart->uart->INTSTS & UART_INTSTS_RDAINT_Msk) {
000004  6800              LDR      r0,[r0,#0]
000006  69c0              LDR      r0,[r0,#0x1c]
000008  2500              MOVS     r5,#0
00000a  05c0              LSLS     r0,r0,#23
00000c  2800              CMP      r0,#0
00000e  db17              BLT      |L4.64|
000010  e01a              B        |L4.72|
                  |L4.18|
;;;410    		/* 从串口接收数据寄存器读取数据存放到接收FIFO */
;;;411    		uint8_t ch;		
;;;412    		/* Get all the input characters */
;;;413    		while (UART_IS_RX_READY(_pUart->uart)) {
;;;414    			/* Get the character from UART Buffer */
;;;415    			ch = UART_READ(_pUart->uart);
000012  6800              LDR      r0,[r0,#0]
;;;416    			_pUart->pRxBuf[_pUart->usRxWrite] = ch;
000014  8ae2              LDRH     r2,[r4,#0x16]
000016  68a1              LDR      r1,[r4,#8]
000018  b2c0              UXTB     r0,r0                 ;415
00001a  5488              STRB     r0,[r1,r2]
;;;417    			if (++_pUart->usRxWrite >= _pUart->usRxBufSize) {
00001c  8ae1              LDRH     r1,[r4,#0x16]
00001e  1c49              ADDS     r1,r1,#1
000020  b28a              UXTH     r2,r1
000022  82e2              STRH     r2,[r4,#0x16]
000024  89e1              LDRH     r1,[r4,#0xe]
000026  428a              CMP      r2,r1
000028  d300              BCC      |L4.44|
;;;418    				_pUart->usRxWrite = 0;
00002a  82e5              STRH     r5,[r4,#0x16]
                  |L4.44|
;;;419    			}
;;;420    			if (_pUart->usRxCount < _pUart->usRxBufSize) {
00002c  8b62              LDRH     r2,[r4,#0x1a]
00002e  428a              CMP      r2,r1
000030  d202              BCS      |L4.56|
;;;421    				_pUart->usRxCount++;
000032  8b61              LDRH     r1,[r4,#0x1a]
000034  1c49              ADDS     r1,r1,#1
000036  8361              STRH     r1,[r4,#0x1a]
                  |L4.56|
;;;422    			}
;;;423    
;;;424    			/* 回调函数,通知应用程序收到新数据,一般是发送1个消息或者设置一个标记 */
;;;425    			//if (_pUart->usRxWrite == _pUart->usRxRead)
;;;426    			//if (_pUart->usRxCount == 1)
;;;427    			{
;;;428    				if (_pUart->ReciveNew) {
000038  6a61              LDR      r1,[r4,#0x24]
00003a  2900              CMP      r1,#0
00003c  d000              BEQ      |L4.64|
;;;429    					_pUart->ReciveNew(ch);
00003e  4788              BLX      r1
                  |L4.64|
000040  6820              LDR      r0,[r4,#0]            ;413
000042  69c1              LDR      r1,[r0,#0x1c]         ;413
000044  07c9              LSLS     r1,r1,#31             ;413
000046  d1e4              BNE      |L4.18|
                  |L4.72|
;;;430    				}
;;;431    			}
;;;432    
;;;433    		}
;;;434    	}
;;;435    	/* 处理发送缓冲区空中断 */
;;;436    	if (_pUart->uart->INTSTS & UART_INTSTS_THREINT_Msk) {
000048  6820              LDR      r0,[r4,#0]
00004a  69c1              LDR      r1,[r0,#0x1c]
00004c  0589              LSLS     r1,r1,#22
00004e  d511              BPL      |L4.116|
;;;437    		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;438    		if (_pUart->usTxCount == 0) {
000050  8aa1              LDRH     r1,[r4,#0x14]
000052  2900              CMP      r1,#0
000054  d00f              BEQ      |L4.118|
;;;439    			/* 发送缓冲区的数据已取完时， 禁止发送缓冲区空中断 （注意：此时最后1个数据还未真正发送完毕）*/
;;;440    //			USART_ITConfig(_pUart->uart, USART_IT_TXE, DISABLE);
;;;441    			UART_DisableInt(_pUart->uart, UART_INTEN_THREIEN_Msk);
;;;442    
;;;443    			/* 使能数据发送完毕中断 */
;;;444    //			USART_ITConfig(_pUart->uart, USART_IT_TC, ENABLE);
;;;445    //			UART_DisableInt(_pUart->uart, UART_INTEN_THREIEN_Msk);
;;;446    		} else {
;;;447    			/* 从发送FIFO取1个字节写入串口发送数据寄存器 */
;;;448    			UART_WRITE(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
000056  8a62              LDRH     r2,[r4,#0x12]
000058  6861              LDR      r1,[r4,#4]
00005a  5c89              LDRB     r1,[r1,r2]
00005c  6001              STR      r1,[r0,#0]
;;;449    			if (++_pUart->usTxRead >= _pUart->usTxBufSize) {
00005e  8a60              LDRH     r0,[r4,#0x12]
000060  1c40              ADDS     r0,r0,#1
000062  b280              UXTH     r0,r0
000064  8260              STRH     r0,[r4,#0x12]
000066  89a1              LDRH     r1,[r4,#0xc]
000068  4288              CMP      r0,r1
00006a  d300              BCC      |L4.110|
;;;450    				_pUart->usTxRead = 0;
00006c  8265              STRH     r5,[r4,#0x12]
                  |L4.110|
;;;451    			}
;;;452    			_pUart->usTxCount--;
00006e  8aa0              LDRH     r0,[r4,#0x14]
000070  1e40              SUBS     r0,r0,#1
000072  82a0              STRH     r0,[r4,#0x14]
                  |L4.116|
;;;453    		}
;;;454    	}
;;;455    #if 0
;;;456    	/* 数据bit位全部发送完毕的中断 */
;;;457    	else if (USART_GetITStatus(_pUart->uart, UART_IT_TC) != RESET) {
;;;458    		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;459    		if (_pUart->usTxCount == 0) {
;;;460    			/* 如果发送FIFO的数据全部发送完毕，禁止数据发送完毕中断 */
;;;461    			USART_ITConfig(_pUart->uart, UART_IT_TC, DISABLE);
;;;462    
;;;463    			/* 回调函数, 一般用来处理RS485通信，将RS485芯片设置为接收模式，避免抢占总线 */
;;;464    			if (_pUart->SendOver) {
;;;465    				_pUart->SendOver();
;;;466    			}
;;;467    		} else {
;;;468    			/* 正常情况下，不会进入此分支 */
;;;469    
;;;470    			/* 如果发送FIFO的数据还未完毕，则从发送FIFO取1个数据写入发送数据寄存器 */
;;;471    			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
;;;472    			if (++_pUart->usTxRead >= _pUart->usTxBufSize) {
;;;473    				_pUart->usTxRead = 0;
;;;474    			}
;;;475    			_pUart->usTxCount--;
;;;476    		}
;;;477    	}
;;;478    #endif
;;;479    }
000074  bd70              POP      {r4-r6,pc}
                  |L4.118|
000076  2102              MOVS     r1,#2                 ;441
000078  f7fffffe          BL       UART_DisableInt
00007c  bd70              POP      {r4-r6,pc}
;;;480    
                          ENDP


                          AREA ||i.UartVarInit||, CODE, READONLY, ALIGN=2

                  UartVarInit PROC
;;;173     */
;;;174    static void UartVarInit(void) {
000000  4916              LDR      r1,|L5.92|
;;;175    #if UART0_FIFO_EN == 1
;;;176    	g_tUart0.uart = UART0; /* STM32 串口设备 */
000002  4815              LDR      r0,|L5.88|
;;;177    	g_tUart0.pTxBuf = g_TxBuf0; /* 发送缓冲区指针 */
000004  6008              STR      r0,[r1,#0]  ; g_tUart0
000006  4608              MOV      r0,r1
000008  3028              ADDS     r0,r0,#0x28
;;;178    	g_tUart0.pRxBuf = g_RxBuf0; /* 接收缓冲区指针 */
00000a  6048              STR      r0,[r1,#4]  ; g_tUart0
00000c  3040              ADDS     r0,r0,#0x40
;;;179    	g_tUart0.usTxBufSize = UART0_TX_BUF_SIZE; /* 发送缓冲区大小 */
00000e  6088              STR      r0,[r1,#8]  ; g_tUart0
000010  2040              MOVS     r0,#0x40
000012  8188              STRH     r0,[r1,#0xc]
;;;180    	g_tUart0.usRxBufSize = UART0_RX_BUF_SIZE; /* 接收缓冲区大小 */
000014  81c8              STRH     r0,[r1,#0xe]
;;;181    	g_tUart0.usTxWrite = 0; /* 发送FIFO写索引 */
000016  2000              MOVS     r0,#0
000018  8208              STRH     r0,[r1,#0x10]
;;;182    	g_tUart0.usTxRead = 0; /* 发送FIFO读索引 */
00001a  8248              STRH     r0,[r1,#0x12]
;;;183    	g_tUart0.usRxWrite = 0; /* 接收FIFO写索引 */
00001c  82c8              STRH     r0,[r1,#0x16]
;;;184    	g_tUart0.usRxRead = 0; /* 接收FIFO读索引 */
00001e  8308              STRH     r0,[r1,#0x18]
;;;185    	g_tUart0.usRxCount = 0; /* 接收到的新数据个数 */
000020  8348              STRH     r0,[r1,#0x1a]
;;;186    	g_tUart0.usTxCount = 0; /* 待发送的数据个数 */
000022  8288              STRH     r0,[r1,#0x14]
;;;187    	g_tUart0.SendBefor = 0; /* 发送数据前的回调函数 */
;;;188    	g_tUart0.SendOver = 0; /* 发送完毕后的回调函数 */
000024  61c8              STR      r0,[r1,#0x1c]  ; g_tUart0
;;;189    	g_tUart0.ReciveNew = 0; /* 接收到新数据后的回调函数 */
000026  6208              STR      r0,[r1,#0x20]  ; g_tUart0
;;;190    #endif
;;;191    
;;;192    #if UART1_FIFO_EN == 1
;;;193    	g_tUart1.uart = UART1; /* STM32 串口设备 */
000028  6248              STR      r0,[r1,#0x24]  ; g_tUart0
00002a  4a0d              LDR      r2,|L5.96|
00002c  31a8              ADDS     r1,r1,#0xa8
;;;194    	g_tUart1.pTxBuf = g_TxBuf1; /* 发送缓冲区指针 */
00002e  600a              STR      r2,[r1,#0]  ; g_tUart1
000030  460a              MOV      r2,r1
000032  3228              ADDS     r2,r2,#0x28
;;;195    	g_tUart1.pRxBuf = g_RxBuf1; /* 接收缓冲区指针 */
000034  604a              STR      r2,[r1,#4]  ; g_tUart1
000036  32ff              ADDS     r2,r2,#0xff
000038  3201              ADDS     r2,#1
;;;196    	g_tUart1.usTxBufSize = UART1_TX_BUF_SIZE; /* 发送缓冲区大小 */
00003a  608a              STR      r2,[r1,#8]  ; g_tUart1
00003c  22ff              MOVS     r2,#0xff
00003e  3201              ADDS     r2,#1
000040  818a              STRH     r2,[r1,#0xc]
;;;197    	g_tUart1.usRxBufSize = UART1_RX_BUF_SIZE; /* 接收缓冲区大小 */
000042  81ca              STRH     r2,[r1,#0xe]
;;;198    	g_tUart1.usTxWrite = 0; /* 发送FIFO写索引 */
000044  8208              STRH     r0,[r1,#0x10]
;;;199    	g_tUart1.usTxRead = 0; /* 发送FIFO读索引 */
000046  8248              STRH     r0,[r1,#0x12]
;;;200    	g_tUart1.usRxWrite = 0; /* 接收FIFO写索引 */
000048  82c8              STRH     r0,[r1,#0x16]
;;;201    	g_tUart1.usRxRead = 0; /* 接收FIFO读索引 */
00004a  8308              STRH     r0,[r1,#0x18]
;;;202    	g_tUart1.usRxCount = 0; /* 接收到的新数据个数 */
00004c  8348              STRH     r0,[r1,#0x1a]
;;;203    	g_tUart1.usTxCount = 0; /* 待发送的数据个数 */
00004e  8288              STRH     r0,[r1,#0x14]
;;;204    	g_tUart1.SendBefor = 0; /* 发送数据前的回调函数 */
;;;205    	g_tUart1.SendOver = 0; /* 发送完毕后的回调函数 */
000050  61c8              STR      r0,[r1,#0x1c]  ; g_tUart1
;;;206    	g_tUart1.ReciveNew = 0; /* 接收到新数据后的回调函数 */
000052  6208              STR      r0,[r1,#0x20]  ; g_tUart1
000054  6248              STR      r0,[r1,#0x24]  ; g_tUart1
;;;207    #endif
;;;208    
;;;209    }
000056  4770              BX       lr
;;;210    
                          ENDP

                  |L5.88|
                          DCD      0x40050000
                  |L5.92|
                          DCD      ||.bss||
                  |L5.96|
                          DCD      0x40150000

                          AREA ||i.bsp_InitUart||, CODE, READONLY, ALIGN=2

                  bsp_InitUart PROC
;;;32      */
;;;33     void bsp_InitUart(void) {
000000  b570              PUSH     {r4-r6,lr}
;;;34     	UartVarInit(); 
000002  f7fffffe          BL       UartVarInit
000006  4d1a              LDR      r5,|L6.112|
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       CLK_EnableModuleClock
00000e  2401              MOVS     r4,#1
000010  0664              LSLS     r4,r4,#25
000012  2200              MOVS     r2,#0
000014  4621              MOV      r1,r4
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       CLK_SetModuleClock
00001c  4a16              LDR      r2,|L6.120|
00001e  4815              LDR      r0,|L6.116|
000020  6050              STR      r0,[r2,#4]
000022  0290              LSLS     r0,r2,#10
000024  f7fffffe          BL       SYS_ResetModule
000028  21e1              MOVS     r1,#0xe1
00002a  0249              LSLS     r1,r1,#9
00002c  4813              LDR      r0,|L6.124|
00002e  f7fffffe          BL       UART_Open
000032  1c6d              ADDS     r5,r5,#1
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       CLK_EnableModuleClock
00003a  2200              MOVS     r2,#0
00003c  4621              MOV      r1,r4
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       CLK_SetModuleClock
000044  2030              MOVS     r0,#0x30
000046  2105              MOVS     r1,#5
000048  0709              LSLS     r1,r1,#28
00004a  6388              STR      r0,[r1,#0x38]
00004c  1220              ASRS     r0,r4,#8
00004e  f7fffffe          BL       SYS_ResetModule
000052  4c0b              LDR      r4,|L6.128|
000054  214b              MOVS     r1,#0x4b
000056  0209              LSLS     r1,r1,#8
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       UART_Open
00005e  6861              LDR      r1,[r4,#4]
000060  2213              MOVS     r2,#0x13
000062  4311              ORRS     r1,r1,r2
000064  6061              STR      r1,[r4,#4]
000066  2001              MOVS     r0,#1
000068  4906              LDR      r1,|L6.132|
00006a  0340              LSLS     r0,r0,#13
00006c  6008              STR      r0,[r1,#0]
;;;35     	InitHardUart(); 
;;;36     	ConfigUartNVIC();
;;;37     }
00006e  bd70              POP      {r4-r6,pc}
;;;38     
                          ENDP

                  |L6.112|
                          DCD      0xa7803d10
                  |L6.116|
                          DCD      0x00000303
                  |L6.120|
                          DCD      0x50000040
                  |L6.124|
                          DCD      0x40050000
                  |L6.128|
                          DCD      0x40150000
                  |L6.132|
                          DCD      0xe000e100

                          AREA ||i.comClearRxFifo||, CODE, READONLY, ALIGN=1

                  comClearRxFifo PROC
;;;152     */
;;;153    void comClearRxFifo(COM_PORT_E _ucPort) {
000000  b500              PUSH     {lr}
;;;154    	UART_T_M *pUart;
;;;155    
;;;156    	pUart = ComToUart(_ucPort);
000002  f7fffffe          BL       ComToUart
;;;157    	if (pUart == 0) {
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L7.18|
;;;158    		return;
;;;159    	}
;;;160    
;;;161    	pUart->usRxWrite = 0;
00000a  2100              MOVS     r1,#0
00000c  82c1              STRH     r1,[r0,#0x16]
;;;162    	pUart->usRxRead = 0;
00000e  8301              STRH     r1,[r0,#0x18]
;;;163    	pUart->usRxCount = 0;
000010  8341              STRH     r1,[r0,#0x1a]
                  |L7.18|
;;;164    }
000012  bd00              POP      {pc}
;;;165    
                          ENDP


                          AREA ||i.comClearTxFifo||, CODE, READONLY, ALIGN=1

                  comClearTxFifo PROC
;;;131     */
;;;132    void comClearTxFifo(COM_PORT_E _ucPort) {
000000  b500              PUSH     {lr}
;;;133    	UART_T_M *pUart;
;;;134    
;;;135    	pUart = ComToUart(_ucPort);
000002  f7fffffe          BL       ComToUart
;;;136    	if (pUart == 0) {
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L8.18|
;;;137    		return;
;;;138    	}
;;;139    
;;;140    	pUart->usTxWrite = 0;
00000a  2100              MOVS     r1,#0
00000c  8201              STRH     r1,[r0,#0x10]
;;;141    	pUart->usTxRead = 0;
00000e  8241              STRH     r1,[r0,#0x12]
;;;142    	pUart->usTxCount = 0;
000010  8281              STRH     r1,[r0,#0x14]
                  |L8.18|
;;;143    }
000012  bd00              POP      {pc}
;;;144    
                          ENDP


                          AREA ||i.comGetChar||, CODE, READONLY, ALIGN=1

                  comGetChar PROC
;;;112     */
;;;113    uint8_t comGetChar(COM_PORT_E _ucPort, uint8_t *_pByte) {
000000  b510              PUSH     {r4,lr}
;;;114    	UART_T_M *pUart;
;;;115    
;;;116    	pUart = ComToUart(_ucPort);
000002  f7fffffe          BL       ComToUart
;;;117    	if (pUart == 0) {
000006  2800              CMP      r0,#0
000008  d01f              BEQ      |L9.74|
;;;118    		return 0;
;;;119    	}
;;;120    
;;;121    	return UartGetChar(pUart, _pByte);
00000a  4602              MOV      r2,r0
00000c  2001              MOVS     r0,#1
00000e  f3808810          MSR      PRIMASK,r0
000012  8b53              LDRH     r3,[r2,#0x1a]
000014  2000              MOVS     r0,#0
000016  f3808810          MSR      PRIMASK,r0
00001a  2b00              CMP      r3,#0
00001c  d015              BEQ      |L9.74|
00001e  8b14              LDRH     r4,[r2,#0x18]
000020  6893              LDR      r3,[r2,#8]
000022  5d1b              LDRB     r3,[r3,r4]
000024  700b              STRB     r3,[r1,#0]
000026  2101              MOVS     r1,#1
000028  f3818810          MSR      PRIMASK,r1
00002c  8b11              LDRH     r1,[r2,#0x18]
00002e  1c49              ADDS     r1,r1,#1
000030  b289              UXTH     r1,r1
000032  8311              STRH     r1,[r2,#0x18]
000034  89d3              LDRH     r3,[r2,#0xe]
000036  4299              CMP      r1,r3
000038  d300              BCC      |L9.60|
00003a  8310              STRH     r0,[r2,#0x18]
                  |L9.60|
00003c  8b50              LDRH     r0,[r2,#0x1a]
00003e  1e40              SUBS     r0,r0,#1
000040  8350              STRH     r0,[r2,#0x1a]
000042  2000              MOVS     r0,#0
000044  f3808810          MSR      PRIMASK,r0
000048  2001              MOVS     r0,#1
                  |L9.74|
;;;122    }
00004a  bd10              POP      {r4,pc}
;;;123    
                          ENDP


                          AREA ||i.comSendBuf||, CODE, READONLY, ALIGN=1

                  comSendBuf PROC
;;;75      */
;;;76     void comSendBuf(COM_PORT_E _ucPort, uint8_t *_ucaBuf, uint16_t _usLen) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
;;;77     	UART_T_M *pUart;
;;;78     
;;;79     	pUart = ComToUart(_ucPort);
000006  f7fffffe          BL       ComToUart
00000a  0004              MOVS     r4,r0
;;;80     	if (pUart == 0) {
00000c  d030              BEQ      |L10.112|
;;;81     		return;
;;;82     	}
;;;83     
;;;84     	if (pUart->SendBefor != 0) {
00000e  69e0              LDR      r0,[r4,#0x1c]
000010  2800              CMP      r0,#0
000012  d000              BEQ      |L10.22|
;;;85     		pUart->SendBefor(); /* 如果是RS485通信，可以在这个函数中将RS485设置为发送模式 */
000014  4780              BLX      r0
                  |L10.22|
000016  2000              MOVS     r0,#0
;;;86     	}
;;;87     
;;;88     	UartSend(pUart, _ucaBuf, _usLen);
000018  e024              B        |L10.100|
                  |L10.26|
00001a  89a2              LDRH     r2,[r4,#0xc]
                  |L10.28|
00001c  2101              MOVS     r1,#1
00001e  f3818810          MSR      PRIMASK,r1
000022  8aa1              LDRH     r1,[r4,#0x14]
000024  466b              MOV      r3,sp
000026  8019              STRH     r1,[r3,#0]
000028  2100              MOVS     r1,#0
00002a  f3818810          MSR      PRIMASK,r1
00002e  8819              LDRH     r1,[r3,#0]
000030  428a              CMP      r2,r1
000032  d9f3              BLS      |L10.28|
000034  5c31              LDRB     r1,[r6,r0]
000036  8a23              LDRH     r3,[r4,#0x10]
000038  6862              LDR      r2,[r4,#4]
00003a  54d1              STRB     r1,[r2,r3]
00003c  2101              MOVS     r1,#1
00003e  f3818810          MSR      PRIMASK,r1
000042  8a21              LDRH     r1,[r4,#0x10]
000044  1c49              ADDS     r1,r1,#1
000046  b289              UXTH     r1,r1
000048  8221              STRH     r1,[r4,#0x10]
00004a  89a2              LDRH     r2,[r4,#0xc]
00004c  4291              CMP      r1,r2
00004e  d301              BCC      |L10.84|
000050  2100              MOVS     r1,#0
000052  8221              STRH     r1,[r4,#0x10]
                  |L10.84|
000054  8aa1              LDRH     r1,[r4,#0x14]
000056  1c49              ADDS     r1,r1,#1
000058  82a1              STRH     r1,[r4,#0x14]
00005a  2100              MOVS     r1,#0
00005c  f3818810          MSR      PRIMASK,r1
000060  1c40              ADDS     r0,r0,#1
000062  b280              UXTH     r0,r0
                  |L10.100|
000064  42a8              CMP      r0,r5
000066  d3d8              BCC      |L10.26|
000068  2102              MOVS     r1,#2
00006a  6820              LDR      r0,[r4,#0]
00006c  f7fffffe          BL       UART_EnableInt
                  |L10.112|
;;;89     }
000070  bdf8              POP      {r3-r7,pc}
;;;90     
                          ENDP


                          AREA ||i.comSendChar||, CODE, READONLY, ALIGN=1

                  comSendChar PROC
;;;99      */
;;;100    void comSendChar(COM_PORT_E _ucPort, uint8_t _ucByte) {
000000  b513              PUSH     {r0,r1,r4,lr}
;;;101    	comSendBuf(_ucPort, &_ucByte, 1);
000002  2201              MOVS     r2,#1
000004  a901              ADD      r1,sp,#4
000006  f7fffffe          BL       comSendBuf
;;;102    }
00000a  bd1c              POP      {r2-r4,pc}
;;;103    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tUart0
                          %        40
                  g_TxBuf0
                          %        64
                  g_RxBuf0
                          %        64
                  g_tUart1
                          %        40
                  g_TxBuf1
                          %        256
                  g_RxBuf1
                          %        256

;*** Start embedded assembler ***

#line 1 "..\\Bsp\\src\\bsp_uart_fifo.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REV16|
#line 388 "..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_bsp_uart_fifo_c_b28b0d00____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH|
#line 402
|__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
