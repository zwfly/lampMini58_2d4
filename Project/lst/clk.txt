; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\Library\StdDriver\inc -I..\Library\CMSIS\Include -I..\Library\Device\Nuvoton\Mini58Series\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=523 --omf_browse=.\obj\clk.crf ..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;28       */
;;;29     void CLK_DisableCKO(void)
000000  4802              LDR      r0,|L1.12|
;;;30     {
;;;31         /* Disable CKO clock source */
;;;32         CLK->APBCLK &= (~CLK_APBCLK_CLKOCKEN_Msk);
000002  6881              LDR      r1,[r0,#8]
000004  2240              MOVS     r2,#0x40
000006  4391              BICS     r1,r1,r2
000008  6081              STR      r1,[r0,#8]
;;;33     }
00000a  4770              BX       lr
;;;34     
                          ENDP

                  |L1.12|
                          DCD      0x50000200

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;399      */
;;;400    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  0fc1              LSRS     r1,r0,#31
;;;401    {
;;;402        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK+(MODULE_APBCLK(u32ModuleIdx)*4))  &= ~(1<<MODULE_IP_EN_Pos(u32ModuleIdx));
000002  008a              LSLS     r2,r1,#2
000004  4904              LDR      r1,|L2.24|
000006  1851              ADDS     r1,r2,r1
000008  684a              LDR      r2,[r1,#4]
00000a  06c3              LSLS     r3,r0,#27
00000c  0edb              LSRS     r3,r3,#27
00000e  2001              MOVS     r0,#1
000010  4098              LSLS     r0,r0,r3
000012  4382              BICS     r2,r2,r0
000014  604a              STR      r2,[r1,#4]
;;;403    }
000016  4770              BX       lr
;;;404    
                          ENDP

                  |L2.24|
                          DCD      0x50000200

                          AREA ||i.CLK_DisablePLL||, CODE, READONLY, ALIGN=2

                  CLK_DisablePLL PROC
;;;559      */
;;;560    void CLK_DisablePLL(void)
000000  4802              LDR      r0,|L3.12|
;;;561    {
;;;562        CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
000002  6a01              LDR      r1,[r0,#0x20]
000004  01c2              LSLS     r2,r0,#7
000006  4311              ORRS     r1,r1,r2
000008  6201              STR      r1,[r0,#0x20]
;;;563    }
00000a  4770              BX       lr
;;;564    
                          ENDP

                  |L3.12|
                          DCD      0x50000200

                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_DisableSysTick PROC
;;;320      */
;;;321    void CLK_DisableSysTick(void)
000000  4901              LDR      r1,|L4.8|
;;;322    {
;;;323        SysTick->CTRL = 0;    /* Set System Tick counter disabled */
000002  2000              MOVS     r0,#0
000004  6108              STR      r0,[r1,#0x10]
;;;324    }
000006  4770              BX       lr
;;;325    
                          ENDP

                  |L4.8|
                          DCD      0xe000e000

                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_DisableXtalRC PROC
;;;349      */
;;;350    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L5.12|
;;;351    {
;;;352        CLK->PWRCTL &=~u32ClkMask;
000002  680a              LDR      r2,[r1,#0]
000004  4382              BICS     r2,r2,r0
000006  600a              STR      r2,[r1,#0]
;;;353    }
000008  4770              BX       lr
;;;354    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;52       */
;;;53     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
000000  0152              LSLS     r2,r2,#5
;;;54     {
;;;55         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;56         CLK->CLKOCTL = CLK_CLKOCTL_CLKOEN_Msk | u32ClkDiv | u32ClkDivBy1En<<CLK_CLKOCTL_DIV1EN_Pos;
000002  430a              ORRS     r2,r2,r1
000004  2110              MOVS     r1,#0x10
000006  430a              ORRS     r2,r2,r1
000008  4905              LDR      r1,|L6.32|
00000a  624a              STR      r2,[r1,#0x24]
;;;57     
;;;58         /* Enable CKO clock source */
;;;59         CLK->APBCLK |= CLK_APBCLK_CLKOCKEN_Msk;
00000c  688a              LDR      r2,[r1,#8]
00000e  2340              MOVS     r3,#0x40
000010  431a              ORRS     r2,r2,r3
000012  608a              STR      r2,[r1,#8]
;;;60     
;;;61         /* Select CKO clock source */
;;;62         CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_CLKOSEL_Msk)) | u32ClkSrc;
000014  69ca              LDR      r2,[r1,#0x1c]
000016  230c              MOVS     r3,#0xc
000018  439a              BICS     r2,r2,r3
00001a  4302              ORRS     r2,r2,r0
00001c  61ca              STR      r2,[r1,#0x1c]
;;;63     }
00001e  4770              BX       lr
;;;64     
                          ENDP

                  |L6.32|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;374      */
;;;375    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  0fc1              LSRS     r1,r0,#31
;;;376    {
;;;377        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK+(MODULE_APBCLK(u32ModuleIdx)*4))  |= 1<<MODULE_IP_EN_Pos(u32ModuleIdx);
000002  008a              LSLS     r2,r1,#2
000004  4904              LDR      r1,|L7.24|
000006  1851              ADDS     r1,r2,r1
000008  684a              LDR      r2,[r1,#4]
00000a  06c3              LSLS     r3,r0,#27
00000c  0edb              LSRS     r3,r3,#27
00000e  2001              MOVS     r0,#1
000010  4098              LSLS     r0,r0,r3
000012  4302              ORRS     r2,r2,r0
000014  604a              STR      r2,[r1,#4]
;;;378    }
000016  4770              BX       lr
;;;379    
                          ENDP

                  |L7.24|
                          DCD      0x50000200

                          AREA ||i.CLK_EnablePLL||, CODE, READONLY, ALIGN=2

                  CLK_EnablePLL PROC
;;;414      */
;;;415    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;416    {
000002  b085              SUB      sp,sp,#0x14
000004  460c              MOV      r4,r1
;;;417        uint32_t u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC , u32NRT;
;;;418        uint32_t u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR,u32Best;
;;;419    
;;;420        /* Disable PLL first to avoid unstable when setting PLL */
;;;421        CLK_DisablePLL();
000006  f7fffffe          BL       CLK_DisablePLL
;;;422    
;;;423        /* PLL source clock is from HXT */
;;;424        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT) {
00000a  9805              LDR      r0,[sp,#0x14]
00000c  2800              CMP      r0,#0
;;;425            /* Enable HXT clock */
;;;426            CLK->PWRCTL = (CLK->PWRCTL & ~CLK_PWRCTL_XTLEN_Msk) | CLK_PWRCTL_XTLEN_HXT ;
;;;427    
;;;428            /* Wait for HXT clock ready */
;;;429            CLK_WaitClockReady(CLK_STATUS_XTLSTB_Msk);
;;;430    
;;;431            /* Select PLL source clock from HXT */
;;;432            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HXT;
;;;433            u32PllSrcClk = __XTAL;
;;;434    
;;;435            /* u32NR start from 2 */
;;;436            u32NRT = 2;
;;;437        }
;;;438    
;;;439        /* PLL source clock is from HIRC */
;;;440        else {
;;;441            /* Enable HIRC clock */
;;;442            CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00000e  4871              LDR      r0,|L8.468|
000010  6801              LDR      r1,[r0,#0]
000012  d013              BEQ      |L8.60|
000014  2204              MOVS     r2,#4
000016  4311              ORRS     r1,r1,r2
000018  6001              STR      r1,[r0,#0]
;;;443    
;;;444            /* Wait for HIRC clock ready */
;;;445            CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001a  2010              MOVS     r0,#0x10
00001c  f7fffffe          BL       CLK_WaitClockReady
;;;446    
;;;447            /* Select PLL source clock from HIRC */
;;;448            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HIRC;
000020  2001              MOVS     r0,#1
000022  04c0              LSLS     r0,r0,#19
;;;449            u32PllSrcClk = __HIRC;
000024  9003              STR      r0,[sp,#0xc]
000026  486c              LDR      r0,|L8.472|
;;;450    
;;;451            /* u32NR start from 4 when FIN = 22.1184MHz to avoid calculation overflow */
;;;452            u32NRT = 4;
000028  9001              STR      r0,[sp,#4]
00002a  2004              MOVS     r0,#4
                  |L8.44|
;;;453        }
;;;454    
;;;455        /* Select "NO" according to request frequency */
;;;456        if((u32PllFreq <= FREQ_200MHZ) && (u32PllFreq > FREQ_100MHZ)) {
00002c  9002              STR      r0,[sp,#8]
00002e  486b              LDR      r0,|L8.476|
000030  496b              LDR      r1,|L8.480|
000032  1820              ADDS     r0,r4,r0
000034  4288              CMP      r0,r1
000036  d80e              BHI      |L8.86|
;;;457            u32NO = 0;
000038  2700              MOVS     r7,#0
;;;458            u32PllFreq = u32PllFreq;
00003a  e01c              B        |L8.118|
                  |L8.60|
00003c  0889              LSRS     r1,r1,#2              ;426
00003e  0089              LSLS     r1,r1,#2              ;426
000040  1c49              ADDS     r1,r1,#1              ;426
000042  6001              STR      r1,[r0,#0]            ;426
000044  2001              MOVS     r0,#1                 ;429
000046  f7fffffe          BL       CLK_WaitClockReady
00004a  2000              MOVS     r0,#0                 ;432
00004c  9003              STR      r0,[sp,#0xc]          ;433
00004e  4865              LDR      r0,|L8.484|
000050  9001              STR      r0,[sp,#4]            ;436
000052  2002              MOVS     r0,#2                 ;436
000054  e7ea              B        |L8.44|
                  |L8.86|
;;;459        } else if((u32PllFreq <= FREQ_100MHZ) && (u32PllFreq >= FREQ_50MHZ)) {
000056  4864              LDR      r0,|L8.488|
000058  4963              LDR      r1,|L8.488|
00005a  1820              ADDS     r0,r4,r0
00005c  4249              RSBS     r1,r1,#0
00005e  4288              CMP      r0,r1
000060  d802              BHI      |L8.104|
;;;460            u32NO = 1;
000062  2701              MOVS     r7,#1
;;;461            u32PllFreq = u32PllFreq << 1;
000064  0064              LSLS     r4,r4,#1
000066  e006              B        |L8.118|
                  |L8.104|
;;;462        } else if((u32PllFreq < FREQ_50MHZ) && (u32PllFreq >= FREQ_25MHZ)) {
000068  4860              LDR      r0,|L8.492|
00006a  1821              ADDS     r1,r4,r0
00006c  4240              RSBS     r0,r0,#0
00006e  4281              CMP      r1,r0
000070  d27b              BCS      |L8.362|
;;;463            u32NO = 3;
000072  2703              MOVS     r7,#3
;;;464            u32PllFreq = u32PllFreq << 2;
000074  00a4              LSLS     r4,r4,#2
                  |L8.118|
;;;465        } else {
;;;466            /* Wrong frequency request. Just return default setting. */
;;;467            goto lexit;
;;;468        }
;;;469    
;;;470        /* Find best solution */
;;;471        u32Min = (uint32_t) - 1;
000076  2500              MOVS     r5,#0
000078  43ed              MVNS     r5,r5
;;;472        u32MinNR = 0;
;;;473        u32MinNF = 0;
;;;474        for(u32NR=u32NRT; u32NR <= 33; u32NR++) {
00007a  9e02              LDR      r6,[sp,#8]
00007c  e022              B        |L8.196|
                  |L8.126|
;;;475            u32Tmp = u32PllSrcClk / u32NR;
00007e  4631              MOV      r1,r6
000080  9801              LDR      r0,[sp,#4]
000082  f7fffffe          BL       __aeabi_uidivmod
;;;476            if((u32Tmp > 1600000) && (u32Tmp < 15000000)) {
000086  495a              LDR      r1,|L8.496|
000088  4684              MOV      r12,r0                ;475
00008a  1841              ADDS     r1,r0,r1
00008c  4859              LDR      r0,|L8.500|
00008e  4281              CMP      r1,r0
000090  d217              BCS      |L8.194|
;;;477                for(u32NF = 2; u32NF <= 513; u32NF++) {
;;;478                    u32Tmp2 = u32Tmp * u32NF;
;;;479                    if((u32Tmp2 >= 100000000) && (u32Tmp2 <= 200000000)) {
000092  4b53              LDR      r3,|L8.480|
000094  2102              MOVS     r1,#2                 ;477
000096  1c5b              ADDS     r3,r3,#1
                  |L8.152|
000098  4850              LDR      r0,|L8.476|
00009a  4662              MOV      r2,r12                ;478
00009c  434a              MULS     r2,r1,r2              ;478
00009e  1c40              ADDS     r0,r0,#1
0000a0  1810              ADDS     r0,r2,r0
0000a2  4298              CMP      r0,r3
0000a4  d809              BHI      |L8.186|
;;;480                        u32Tmp3 = (u32Tmp2 > u32PllFreq) ? u32Tmp2 - u32PllFreq : u32PllFreq - u32Tmp2;
0000a6  42a2              CMP      r2,r4
0000a8  d901              BLS      |L8.174|
0000aa  1b10              SUBS     r0,r2,r4
0000ac  e000              B        |L8.176|
                  |L8.174|
0000ae  1aa0              SUBS     r0,r4,r2
                  |L8.176|
;;;481                        if(u32Tmp3 < u32Min) {
0000b0  42a8              CMP      r0,r5
0000b2  d202              BCS      |L8.186|
;;;482                            u32Min = u32Tmp3;
0000b4  0005              MOVS     r5,r0
;;;483                            u32MinNR = u32NR;
;;;484                            u32MinNF = u32NF;
;;;485                            /* Break when get good results */
;;;486                            if(u32Min == 0) {
0000b6  9100              STR      r1,[sp,#0]
0000b8  d00b              BEQ      |L8.210|
                  |L8.186|
0000ba  484f              LDR      r0,|L8.504|
0000bc  1c49              ADDS     r1,r1,#1              ;477
0000be  4281              CMP      r1,r0                 ;477
0000c0  d9ea              BLS      |L8.152|
                  |L8.194|
0000c2  1c76              ADDS     r6,r6,#1              ;477
                  |L8.196|
0000c4  2e21              CMP      r6,#0x21              ;474
0000c6  d9da              BLS      |L8.126|
;;;487                                /* Enable and apply new PLL setting. */
;;;488                                CLK->PLLCTL = u32CLK_SRC | (u32NO << 14) | ((u32MinNR - 2) << 9) | (u32MinNF - 2);
;;;489    
;;;490                                /* Wait for PLL clock stable */
;;;491                                CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;492    
;;;493                                /* Return actual PLL output clock frequency */
;;;494                                return u32PllSrcClk / ((u32NO + 1) * u32MinNR) * u32MinNF;
;;;495                            }
;;;496                        }
;;;497                    }
;;;498                }
;;;499            }
;;;500        }
;;;501    
;;;502    
;;;503        /* Find best solution */
;;;504        u32Best = u32Min;
;;;505        u32Min = (uint32_t) - 1;
0000c8  2600              MOVS     r6,#0
;;;506        u32MinNR = 0;
;;;507        u32MinNF = 0;
;;;508        for(u32NR=u32NRT; u32NR <= 33; u32NR++) {
0000ca  9504              STR      r5,[sp,#0x10]
0000cc  43f6              MVNS     r6,r6                 ;505
0000ce  9d02              LDR      r5,[sp,#8]
0000d0  e051              B        |L8.374|
                  |L8.210|
0000d2  9803              LDR      r0,[sp,#0xc]          ;488
0000d4  03b9              LSLS     r1,r7,#14             ;488
0000d6  4301              ORRS     r1,r1,r0              ;488
0000d8  2001              MOVS     r0,#1                 ;488
0000da  0272              LSLS     r2,r6,#9              ;488
0000dc  0280              LSLS     r0,r0,#10             ;488
0000de  1a10              SUBS     r0,r2,r0              ;488
0000e0  4301              ORRS     r1,r1,r0              ;488
0000e2  9800              LDR      r0,[sp,#0]            ;488
0000e4  1e80              SUBS     r0,r0,#2              ;488
0000e6  4301              ORRS     r1,r1,r0              ;488
0000e8  483a              LDR      r0,|L8.468|
0000ea  6201              STR      r1,[r0,#0x20]         ;488
0000ec  2004              MOVS     r0,#4                 ;491
0000ee  f7fffffe          BL       CLK_WaitClockReady
0000f2  1c79              ADDS     r1,r7,#1              ;494
0000f4  4371              MULS     r1,r6,r1              ;494
0000f6  e031              B        |L8.348|
                  |L8.248|
;;;509            u32Tmp = u32PllSrcClk / u32NR;
0000f8  4629              MOV      r1,r5
0000fa  9801              LDR      r0,[sp,#4]
0000fc  f7fffffe          BL       __aeabi_uidivmod
;;;510            if((u32Tmp > 1600000) && (u32Tmp < 15000000)) {
000100  493b              LDR      r1,|L8.496|
000102  4684              MOV      r12,r0                ;509
000104  1841              ADDS     r1,r0,r1
000106  483b              LDR      r0,|L8.500|
000108  4281              CMP      r1,r0
00010a  d233              BCS      |L8.372|
00010c  4b34              LDR      r3,|L8.480|
;;;511                for(u32NF = 2; u32NF <= 513; u32NF++) {
00010e  2102              MOVS     r1,#2
000110  1c5b              ADDS     r3,r3,#1              ;479
                  |L8.274|
;;;512                    u32Tmp2 = u32Tmp * u32NF;
;;;513                    if((u32Tmp2 >= 100000000) && (u32Tmp2 <= 200000000)) {
000112  4832              LDR      r0,|L8.476|
000114  4662              MOV      r2,r12                ;512
000116  434a              MULS     r2,r1,r2              ;512
000118  1c40              ADDS     r0,r0,#1
00011a  1810              ADDS     r0,r2,r0
00011c  4298              CMP      r0,r3
00011e  d825              BHI      |L8.364|
;;;514                        u32Tmp3 = (u32Tmp2 > u32PllFreq) ? u32Tmp2 - u32PllFreq : u32PllFreq - u32Tmp2;
000120  42a2              CMP      r2,r4
000122  d901              BLS      |L8.296|
000124  1b10              SUBS     r0,r2,r4
000126  e000              B        |L8.298|
                  |L8.296|
000128  1aa0              SUBS     r0,r4,r2
                  |L8.298|
;;;515                        if(u32Tmp3 < u32Min) {
00012a  42b0              CMP      r0,r6
00012c  d21e              BCS      |L8.364|
;;;516                            u32Min = u32Tmp3;
;;;517                            u32MinNR = u32NR;
;;;518                            u32MinNF = u32NF;
;;;519    
;;;520                            /* Break when get good results */
;;;521                            if(u32Min == u32Best) {
00012e  9a04              LDR      r2,[sp,#0x10]
000130  4606              MOV      r6,r0                 ;516
000132  9100              STR      r1,[sp,#0]
000134  4290              CMP      r0,r2
000136  d119              BNE      |L8.364|
;;;522                                /* Enable and apply new PLL setting. */
;;;523                                CLK->PLLCTL = u32CLK_SRC | (u32NO << 14) | ((u32MinNR - 2) << 9) | (u32MinNF - 2);
000138  9903              LDR      r1,[sp,#0xc]
00013a  03b8              LSLS     r0,r7,#14
00013c  4308              ORRS     r0,r0,r1
00013e  2101              MOVS     r1,#1
000140  026a              LSLS     r2,r5,#9
000142  0289              LSLS     r1,r1,#10
000144  1a51              SUBS     r1,r2,r1
000146  4308              ORRS     r0,r0,r1
000148  9900              LDR      r1,[sp,#0]
00014a  1e89              SUBS     r1,r1,#2
00014c  4308              ORRS     r0,r0,r1
00014e  4921              LDR      r1,|L8.468|
000150  6208              STR      r0,[r1,#0x20]
;;;524    
;;;525                                /* Wait for PLL clock stable */
;;;526                                CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
000152  2004              MOVS     r0,#4
000154  f7fffffe          BL       CLK_WaitClockReady
;;;527    
;;;528                                /* Return actual PLL output clock frequency */
;;;529                                return u32PllSrcClk / ((u32NO + 1) * u32MinNR) * u32MinNF;
000158  1c79              ADDS     r1,r7,#1
00015a  4369              MULS     r1,r5,r1
                  |L8.348|
00015c  9801              LDR      r0,[sp,#4]
00015e  f7fffffe          BL       __aeabi_uidivmod
000162  9900              LDR      r1,[sp,#0]
000164  4348              MULS     r0,r1,r0
                  |L8.358|
;;;530                            }
;;;531                        }
;;;532                    }
;;;533                }
;;;534            }
;;;535        }
;;;536    
;;;537    
;;;538    lexit:
;;;539    
;;;540        /* Apply default PLL setting and return */
;;;541        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;542            CLK->PLLCTL = CLK_PLLCTL_72MHz_HXT; /* 72MHz */
;;;543        else
;;;544            CLK->PLLCTL = CLK_PLLCTL_72MHz_HIRC; /* 71.8848MHz */
;;;545    
;;;546        /* Wait for PLL clock stable */
;;;547        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;548    
;;;549        return CLK_GetPLLClockFreq();
;;;550    
;;;551    }
000166  b007              ADD      sp,sp,#0x1c
000168  bdf0              POP      {r4-r7,pc}
                  |L8.362|
00016a  e006              B        |L8.378|
                  |L8.364|
00016c  4822              LDR      r0,|L8.504|
00016e  1c49              ADDS     r1,r1,#1              ;511
000170  4281              CMP      r1,r0                 ;511
000172  d9ce              BLS      |L8.274|
                  |L8.372|
000174  1c6d              ADDS     r5,r5,#1              ;511
                  |L8.374|
000176  2d21              CMP      r5,#0x21              ;508
000178  d9be              BLS      |L8.248|
                  |L8.378|
00017a  9805              LDR      r0,[sp,#0x14]         ;541
00017c  2800              CMP      r0,#0                 ;541
00017e  d00f              BEQ      |L8.416|
000180  491e              LDR      r1,|L8.508|
                  |L8.386|
000182  4814              LDR      r0,|L8.468|
000184  6201              STR      r1,[r0,#0x20]         ;544
000186  2004              MOVS     r0,#4                 ;547
000188  f7fffffe          BL       CLK_WaitClockReady
00018c  a01c              ADR      r0,|L8.512|
00018e  6800              LDR      r0,[r0,#0]            ;547
000190  9000              STR      r0,[sp,#0]            ;547
000192  4810              LDR      r0,|L8.468|
000194  6a01              LDR      r1,[r0,#0x20]         ;547
000196  1300              ASRS     r0,r0,#12             ;547
000198  4201              TST      r1,r0                 ;547
00019a  d003              BEQ      |L8.420|
00019c  2000              MOVS     r0,#0                 ;547
00019e  e7e2              B        |L8.358|
                  |L8.416|
0001a0  4918              LDR      r1,|L8.516|
0001a2  e7ee              B        |L8.386|
                  |L8.420|
0001a4  0308              LSLS     r0,r1,#12             ;542
0001a6  d501              BPL      |L8.428|
0001a8  480b              LDR      r0,|L8.472|
0001aa  e000              B        |L8.430|
                  |L8.428|
0001ac  480d              LDR      r0,|L8.484|
                  |L8.430|
0001ae  038a              LSLS     r2,r1,#14             ;542
0001b0  d4d9              BMI      |L8.358|
0001b2  040a              LSLS     r2,r1,#16             ;542
0001b4  0f92              LSRS     r2,r2,#30             ;542
0001b6  466b              MOV      r3,sp                 ;542
0001b8  5c9b              LDRB     r3,[r3,r2]            ;542
0001ba  05ca              LSLS     r2,r1,#23             ;542
0001bc  0489              LSLS     r1,r1,#18             ;542
0001be  0dd2              LSRS     r2,r2,#23             ;542
0001c0  0ec9              LSRS     r1,r1,#27             ;542
0001c2  1c89              ADDS     r1,r1,#2              ;542
0001c4  0880              LSRS     r0,r0,#2              ;542
0001c6  1c92              ADDS     r2,r2,#2              ;542
0001c8  4359              MULS     r1,r3,r1              ;542
0001ca  4350              MULS     r0,r2,r0              ;542
0001cc  f7fffffe          BL       __aeabi_uidivmod
0001d0  0080              LSLS     r0,r0,#2              ;542
0001d2  e7c8              B        |L8.358|
;;;552    
                          ENDP

                  |L8.468|
                          DCD      0x50000200
                  |L8.472|
                          DCD      0x01518000
                  |L8.476|
                          DCD      0xfa0a1eff
                  |L8.480|
                          DCD      0x05f5e0ff
                  |L8.484|
                          DCD      0x00b71b00
                  |L8.488|
                          DCD      0xfd050f80
                  |L8.492|
                          DCD      0xfe8287c0
                  |L8.496|
                          DCD      0xffe795ff
                  |L8.500|
                          DCD      0x00cc77bf
                  |L8.504|
                          DCD      0x00000201
                  |L8.508|
                          DCD      0x00084418
                  |L8.512|
000200  01020204          DCB      1,2,2,4
                  |L8.516|
                          DCD      0x00004016

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_EnableSysTick PROC
;;;301      */
;;;302    void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count)
000000  b570              PUSH     {r4-r6,lr}
;;;303    {
;;;304        SysTick->CTRL=0;
000002  4a0d              LDR      r2,|L9.56|
000004  2300              MOVS     r3,#0
000006  6113              STR      r3,[r2,#0x10]
;;;305        if( u32ClkSrc== CLK_CLKSEL0_STCLKSEL_HCLK )    /* Set System Tick clock source */
;;;306            SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
000008  2404              MOVS     r4,#4
00000a  2808              CMP      r0,#8                 ;305
00000c  d00f              BEQ      |L9.46|
;;;307        else {
;;;308            SysTick->CTRL &= ~SysTick_CTRL_CLKSOURCE_Msk;
00000e  6915              LDR      r5,[r2,#0x10]
000010  43a5              BICS     r5,r5,r4
000012  6115              STR      r5,[r2,#0x10]
;;;309            CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000014  4d09              LDR      r5,|L9.60|
000016  692c              LDR      r4,[r5,#0x10]
000018  2638              MOVS     r6,#0x38
00001a  43b4              BICS     r4,r4,r6
00001c  4304              ORRS     r4,r4,r0
00001e  612c              STR      r4,[r5,#0x10]
                  |L9.32|
;;;310        }
;;;311        SysTick->LOAD  = u32Count;                /* Set System Tick reload value */
000020  6151              STR      r1,[r2,#0x14]
;;;312        SysTick->VAL = 0;                         /* Clear System Tick current value and counter flag  */
000022  6193              STR      r3,[r2,#0x18]
;;;313        SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk; /* Set System Tick counter enabled */
000024  6910              LDR      r0,[r2,#0x10]
000026  2101              MOVS     r1,#1
000028  4308              ORRS     r0,r0,r1
00002a  6110              STR      r0,[r2,#0x10]
;;;314    }
00002c  bd70              POP      {r4-r6,pc}
                  |L9.46|
00002e  6910              LDR      r0,[r2,#0x10]         ;306
000030  4320              ORRS     r0,r0,r4              ;306
000032  6110              STR      r0,[r2,#0x10]         ;306
000034  e7f4              B        |L9.32|
;;;315    
                          ENDP

000036  0000              DCW      0x0000
                  |L9.56|
                          DCD      0xe000e000
                  |L9.60|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_EnableXtalRC PROC
;;;333      */
;;;334    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  4904              LDR      r1,|L10.20|
;;;335    {
;;;336        if(u32ClkMask & CLK_PWRCTL_XTLEN_Msk)
000002  0782              LSLS     r2,r0,#30
;;;337            CLK->PWRCTL = (CLK->PWRCTL & ~CLK_PWRCTL_XTLEN_Msk) | u32ClkMask;
;;;338        else
;;;339            CLK->PWRCTL |= u32ClkMask;
000004  680a              LDR      r2,[r1,#0]
000006  d001              BEQ      |L10.12|
000008  0892              LSRS     r2,r2,#2              ;337
00000a  0092              LSLS     r2,r2,#2              ;337
                  |L10.12|
00000c  4302              ORRS     r2,r2,r0              ;337
00000e  600a              STR      r2,[r1,#0]            ;337
;;;340    }
000010  4770              BX       lr
;;;341    
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      0x50000200

                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;124      */
;;;125    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;126    {
;;;127        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;128        return SystemCoreClock;
000006  4801              LDR      r0,|L11.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;129    }
00000a  bd10              POP      {r4,pc}
;;;130    
                          ENDP

                  |L11.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;113      */
;;;114    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;115    {
;;;116        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;117        return SystemCoreClock;
000006  4801              LDR      r0,|L12.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;118    }
00000a  bd10              POP      {r4,pc}
;;;119    
                          ENDP

                  |L12.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;89       */
;;;90     uint32_t CLK_GetHXTFreq(void)
000000  4804              LDR      r0,|L13.20|
;;;91     {
;;;92         if((CLK->PWRCTL & CLK_PWRCTL_XTLEN_Msk)==CLK_PWRCTL_XTLEN_HXT )
000002  6800              LDR      r0,[r0,#0]
000004  0780              LSLS     r0,r0,#30
000006  0f80              LSRS     r0,r0,#30
000008  2801              CMP      r0,#1
00000a  d001              BEQ      |L13.16|
;;;93             return __HXT;
;;;94         else
;;;95             return 0;
00000c  2000              MOVS     r0,#0
;;;96     }
00000e  4770              BX       lr
                  |L13.16|
000010  4801              LDR      r0,|L13.24|
000012  4770              BX       lr
;;;97     
                          ENDP

                  |L13.20|
                          DCD      0x50000200
                  |L13.24|
                          DCD      0x00b71b00

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetLXTFreq PROC
;;;101      */
;;;102    uint32_t CLK_GetLXTFreq(void)
000000  4804              LDR      r0,|L14.20|
;;;103    {
;;;104        if((CLK->PWRCTL & CLK_PWRCTL_XTLEN_Msk )==CLK_PWRCTL_XTLEN_LXT )
000002  6800              LDR      r0,[r0,#0]
000004  0780              LSLS     r0,r0,#30
000006  0f80              LSRS     r0,r0,#30
000008  2802              CMP      r0,#2
00000a  d001              BEQ      |L14.16|
;;;105            return __XTAL;
;;;106        else
;;;107            return 0;
00000c  2000              MOVS     r0,#0
;;;108    }
00000e  4770              BX       lr
                  |L14.16|
000010  4801              LDR      r0,|L14.24|
000012  4770              BX       lr
;;;109    
                          ENDP

                  |L14.20|
                          DCD      0x50000200
                  |L14.24|
                          DCD      0x00b71b00

                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;79       */
;;;80     void CLK_Idle(void)
000000  4803              LDR      r0,|L15.16|
;;;81     {
;;;82         CLK->PWRCTL &= ~(CLK_PWRCTL_PDEN_Msk);
000002  6801              LDR      r1,[r0,#0]
000004  2280              MOVS     r2,#0x80
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;83         __WFI();
00000a  bf30              WFI      
;;;84     }
00000c  4770              BX       lr
;;;85     
                          ENDP

00000e  0000              DCW      0x0000
                  |L15.16|
                          DCD      0x50000200

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;68       */
;;;69     void CLK_PowerDown(void)
000000  4904              LDR      r1,|L16.20|
;;;70     {
;;;71         SCB->SCR = SCB_SCR_SLEEPDEEP_Msk;
000002  2004              MOVS     r0,#4
000004  6108              STR      r0,[r1,#0x10]
;;;72         CLK->PWRCTL |= (CLK_PWRCTL_PDEN_Msk | CLK_PWRCTL_PDWKIF_Msk);
000006  4804              LDR      r0,|L16.24|
000008  6801              LDR      r1,[r0,#0]
00000a  22c0              MOVS     r2,#0xc0
00000c  4311              ORRS     r1,r1,r2
00000e  6001              STR      r1,[r0,#0]
;;;73         __WFI();
000010  bf30              WFI      
;;;74     }
000012  4770              BX       lr
;;;75     
                          ENDP

                  |L16.20|
                          DCD      0xe000ed00
                  |L16.24|
                          DCD      0x50000200

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;139      */
;;;140    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  b5f8              PUSH     {r3-r7,lr}
;;;141    {
;;;142        uint32_t u32HIRCSTB;
;;;143    
;;;144        /* Read HIRC clock source stable flag */
;;;145        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000002  4d1d              LDR      r5,|L17.120|
000004  4604              MOV      r4,r0                 ;141
000006  68ee              LDR      r6,[r5,#0xc]
000008  2010              MOVS     r0,#0x10
00000a  4006              ANDS     r6,r6,r0
;;;146    
;;;147        /* The range of u32Hclk is 25 MHz ~ 50 MHz */
;;;148        if(u32Hclk > FREQ_50MHZ)
00000c  481b              LDR      r0,|L17.124|
00000e  4284              CMP      r4,r0
000010  d802              BHI      |L17.24|
;;;149            u32Hclk = FREQ_50MHZ;
;;;150        if(u32Hclk < FREQ_25MHZ)
000012  1040              ASRS     r0,r0,#1
000014  4284              CMP      r4,r0
000016  d200              BCS      |L17.26|
                  |L17.24|
000018  4604              MOV      r4,r0                 ;149
                  |L17.26|
;;;151            u32Hclk = FREQ_25MHZ;
;;;152    
;;;153        /* Switch HCLK clock source to HIRC clock for safe */
;;;154        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00001a  6828              LDR      r0,[r5,#0]
00001c  2704              MOVS     r7,#4
00001e  4338              ORRS     r0,r0,r7
000020  6028              STR      r0,[r5,#0]
;;;155        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000022  2010              MOVS     r0,#0x10
000024  f7fffffe          BL       CLK_WaitClockReady
;;;156        CLK->CLKSEL0 |= CLK_CLKSEL0_HCLKSEL_Msk;
000028  6928              LDR      r0,[r5,#0x10]
00002a  2107              MOVS     r1,#7
00002c  4308              ORRS     r0,r0,r1
00002e  6128              STR      r0,[r5,#0x10]
;;;157        CLK->CLKDIV &= (~CLK_CLKDIV_HCLKDIV_Msk);
000030  69a8              LDR      r0,[r5,#0x18]
000032  0900              LSRS     r0,r0,#4
000034  0100              LSLS     r0,r0,#4
000036  61a8              STR      r0,[r5,#0x18]
;;;158    
;;;159        /* Configure PLL setting if HXT clock is enabled */
;;;160        if( (CLK->PWRCTL & CLK_PWRCTL_XTLEN_Msk)==CLK_PWRCTL_XTLEN_HXT )
000038  6828              LDR      r0,[r5,#0]
00003a  0780              LSLS     r0,r0,#30
00003c  0f80              LSRS     r0,r0,#30
00003e  2801              CMP      r0,#1
000040  d00e              BEQ      |L17.96|
;;;161            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HXT, (u32Hclk << 1));
;;;162    
;;;163        /* Configure PLL setting if HXT clock is not enabled */
;;;164        else {
;;;165            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HIRC, (u32Hclk << 1));
000042  0061              LSLS     r1,r4,#1
000044  0478              LSLS     r0,r7,#17
000046  f7fffffe          BL       CLK_EnablePLL
;;;166    
;;;167            /* Read HIRC clock source stable flag */
;;;168            u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
00004a  68ee              LDR      r6,[r5,#0xc]
00004c  4604              MOV      r4,r0                 ;165
00004e  2010              MOVS     r0,#0x10
000050  4006              ANDS     r6,r6,r0
                  |L17.82|
;;;169        }
;;;170    
;;;171        /* Select HCLK clock source to PLL,
;;;172           Select HCLK clock source divider as 2
;;;173           and update system core clock
;;;174        */
;;;175        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV_HCLK(2));
000052  2101              MOVS     r1,#1
000054  2002              MOVS     r0,#2
000056  f7fffffe          BL       CLK_SetHCLK
;;;176    
;;;177        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;178        if(u32HIRCSTB == 0)
00005a  2e00              CMP      r6,#0
00005c  d006              BEQ      |L17.108|
00005e  e008              B        |L17.114|
                  |L17.96|
000060  0061              LSLS     r1,r4,#1              ;161
000062  2000              MOVS     r0,#0                 ;161
000064  f7fffffe          BL       CLK_EnablePLL
000068  4604              MOV      r4,r0                 ;161
00006a  e7f2              B        |L17.82|
                  |L17.108|
;;;179            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
00006c  6828              LDR      r0,[r5,#0]
00006e  43b8              BICS     r0,r0,r7
000070  6028              STR      r0,[r5,#0]
                  |L17.114|
;;;180    
;;;181        /* Return actually HCLK frequency is PLL frequency divide 2 */
;;;182        return u32Hclk >> 1;
000072  0860              LSRS     r0,r4,#1
;;;183    }
000074  bdf8              POP      {r3-r7,pc}
;;;184    
                          ENDP

000076  0000              DCW      0x0000
                  |L17.120|
                          DCD      0x50000200
                  |L17.124|
                          DCD      0x02faf080

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=2

                  CLK_SetHCLK PROC
;;;194      */
;;;195    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b510              PUSH     {r4,lr}
;;;196    {
;;;197        /* Apply new Divider */
;;;198        CLK->CLKDIV = (CLK->CLKDIV & ~CLK_CLKDIV_HCLKDIV_Msk) | u32ClkDiv;
000002  4a07              LDR      r2,|L18.32|
000004  6993              LDR      r3,[r2,#0x18]
000006  091b              LSRS     r3,r3,#4
000008  011b              LSLS     r3,r3,#4
00000a  430b              ORRS     r3,r3,r1
00000c  6193              STR      r3,[r2,#0x18]
;;;199    
;;;200        /* Switch HCLK to new HCLK source */
;;;201        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_HCLKSEL_Msk) | u32ClkSrc;
00000e  6911              LDR      r1,[r2,#0x10]
000010  08c9              LSRS     r1,r1,#3
000012  00c9              LSLS     r1,r1,#3
000014  4301              ORRS     r1,r1,r0
000016  6111              STR      r1,[r2,#0x10]
;;;202    
;;;203        /* Update System Core Clock */
;;;204        SystemCoreClockUpdate();
000018  f7fffffe          BL       SystemCoreClockUpdate
;;;205    }
00001c  bd10              POP      {r4,pc}
;;;206    
                          ENDP

00001e  0000              DCW      0x0000
                  |L18.32|
                          DCD      0x50000200

                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;255    
;;;256    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b570              PUSH     {r4-r6,lr}
;;;257    {
;;;258        uint32_t u32tmp=0,u32sel=0,u32div=0;
;;;259    
;;;260        if(MODULE_CLKSEL_Msk(u32ModuleIdx)!=MODULE_NoMsk) {
000002  0e43              LSRS     r3,r0,#25
000004  071b              LSLS     r3,r3,#28
000006  d00d              BEQ      |L19.36|
;;;261            u32sel = (uint32_t)&CLK->CLKSEL0+((MODULE_CLKSEL(u32ModuleIdx))*4);
000008  0043              LSLS     r3,r0,#1
00000a  0f9b              LSRS     r3,r3,#30
00000c  4c0f              LDR      r4,|L19.76|
00000e  009b              LSLS     r3,r3,#2
000010  191b              ADDS     r3,r3,r4
;;;262            u32tmp = *(volatile uint32_t *)(u32sel);
000012  681c              LDR      r4,[r3,#0]
;;;263            u32tmp = ( u32tmp & ~(MODULE_CLKSEL_Msk(u32ModuleIdx)<<MODULE_CLKSEL_Pos(u32ModuleIdx)) ) | u32ClkSrc;
000014  00c5              LSLS     r5,r0,#3
000016  0f2d              LSRS     r5,r5,#28
000018  01c6              LSLS     r6,r0,#7
00001a  0ef6              LSRS     r6,r6,#27
00001c  40b5              LSLS     r5,r5,r6
00001e  43ac              BICS     r4,r4,r5
000020  430c              ORRS     r4,r4,r1
;;;264            *(volatile uint32_t *)(u32sel) = u32tmp;
000022  601c              STR      r4,[r3,#0]
                  |L19.36|
;;;265        }
;;;266    
;;;267        if(MODULE_CLKDIV_Msk(u32ModuleIdx)!=MODULE_NoMsk) {
000024  0a83              LSRS     r3,r0,#10
000026  0619              LSLS     r1,r3,#24
000028  0e09              LSRS     r1,r1,#24
00002a  d00d              BEQ      |L19.72|
;;;268            u32div =(uint32_t)&CLK->CLKDIV+((MODULE_CLKDIV(u32ModuleIdx))*4);
00002c  0301              LSLS     r1,r0,#12
00002e  4c07              LDR      r4,|L19.76|
000030  0f89              LSRS     r1,r1,#30
000032  0089              LSLS     r1,r1,#2
000034  3408              ADDS     r4,r4,#8
000036  1909              ADDS     r1,r1,r4
;;;269            u32tmp = *(volatile uint32_t *)(u32div);
000038  680c              LDR      r4,[r1,#0]
;;;270            u32tmp = ( u32tmp & ~(MODULE_CLKDIV_Msk(u32ModuleIdx)<<MODULE_CLKDIV_Pos(u32ModuleIdx)) ) | u32ClkDiv;
00003a  0580              LSLS     r0,r0,#22
00003c  b2db              UXTB     r3,r3
00003e  0ec0              LSRS     r0,r0,#27
000040  4083              LSLS     r3,r3,r0
000042  439c              BICS     r4,r4,r3
000044  4314              ORRS     r4,r4,r2
;;;271            *(volatile uint32_t *)(u32div) = u32tmp;
000046  600c              STR      r4,[r1,#0]
                  |L19.72|
;;;272        }
;;;273    }
000048  bd70              POP      {r4-r6,pc}
;;;274    
                          ENDP

00004a  0000              DCW      0x0000
                  |L19.76|
                          DCD      0x50000210

                          AREA ||i.CLK_SetSysTickClockSrc||, CODE, READONLY, ALIGN=2

                  CLK_SetSysTickClockSrc PROC
;;;283      */
;;;284    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
000000  4a03              LDR      r2,|L20.16|
;;;285    {
;;;286        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000002  6911              LDR      r1,[r2,#0x10]
000004  2338              MOVS     r3,#0x38
000006  4399              BICS     r1,r1,r3
000008  4301              ORRS     r1,r1,r0
00000a  6111              STR      r1,[r2,#0x10]
;;;287    }
00000c  4770              BX       lr
;;;288    
                          ENDP

00000e  0000              DCW      0x0000
                  |L20.16|
                          DCD      0x50000200

                          AREA ||i.CLK_SysTickDelay||, CODE, READONLY, ALIGN=2

                  CLK_SysTickDelay PROC
;;;572      */
;;;573    void CLK_SysTickDelay(uint32_t us)
000000  4906              LDR      r1,|L21.28|
;;;574    {
;;;575        SysTick->LOAD = us * CyclesPerUs;
000002  6809              LDR      r1,[r1,#0]  ; CyclesPerUs
000004  4348              MULS     r0,r1,r0
000006  4906              LDR      r1,|L21.32|
000008  6148              STR      r0,[r1,#0x14]
;;;576        SysTick->VAL  =  (0x00);
00000a  2200              MOVS     r2,#0
00000c  618a              STR      r2,[r1,#0x18]
;;;577        SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
00000e  2005              MOVS     r0,#5
000010  6108              STR      r0,[r1,#0x10]
                  |L21.18|
;;;578    
;;;579        /* Waiting for down-count to zero */
;;;580        while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0);
000012  6908              LDR      r0,[r1,#0x10]
000014  03c0              LSLS     r0,r0,#15
000016  d5fc              BPL      |L21.18|
;;;581        SysTick->CTRL = 0;
000018  610a              STR      r2,[r1,#0x10]
;;;582    }
00001a  4770              BX       lr
;;;583    
                          ENDP

                  |L21.28|
                          DCD      CyclesPerUs
                  |L21.32|
                          DCD      0xe000e000

                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;596      */
;;;597    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  b510              PUSH     {r4,lr}
;;;598    {
000002  4604              MOV      r4,r0
;;;599        int32_t i32TimeOutCnt = 2160000;
000004  4907              LDR      r1,|L22.36|
;;;600    
;;;601        while((CLK->STATUS & u32ClkMask) != u32ClkMask) {
000006  4b08              LDR      r3,|L22.40|
000008  e005              B        |L22.22|
                  |L22.10|
;;;602            if(i32TimeOutCnt-- <= 0)
00000a  460a              MOV      r2,r1
00000c  1e49              SUBS     r1,r1,#1
00000e  2a00              CMP      r2,#0
000010  dc01              BGT      |L22.22|
;;;603                return 0;
000012  2000              MOVS     r0,#0
;;;604        }
;;;605        return 1;
;;;606    }
000014  bd10              POP      {r4,pc}
                  |L22.22|
000016  68da              LDR      r2,[r3,#0xc]          ;601
000018  4620              MOV      r0,r4                 ;601
00001a  4390              BICS     r0,r0,r2              ;601
00001c  d1f5              BNE      |L22.10|
00001e  2001              MOVS     r0,#1                 ;605
000020  bd10              POP      {r4,pc}
;;;607    
                          ENDP

000022  0000              DCW      0x0000
                  |L22.36|
                          DCD      0x0020f580
                  |L22.40|
                          DCD      0x50000200

;*** Start embedded assembler ***

#line 1 "..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 388 "..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 402
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
