; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\i2c.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\i2c.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\Library\StdDriver\inc -I..\Library\CMSIS\Include -I..\Library\Device\Nuvoton\Mini58Series\Include -I..\Bsp -I..\Bsp\inc -I..\utils\inc -I..\App\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=520 --omf_browse=.\obj\i2c.crf ..\Library\StdDriver\src\i2c.c]
                          THUMB

                          AREA ||i.I2C_ClearTimeoutFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearTimeoutFlag PROC
;;;69       */
;;;70     void I2C_ClearTimeoutFlag(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;71     {
;;;72         i2c->TOCTL |= I2C_TOCTL_TOIF_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;73     }
000008  4770              BX       lr
;;;74     
                          ENDP


                          AREA ||i.I2C_Close||, CODE, READONLY, ALIGN=2

                  I2C_Close PROC
;;;49       */
;;;50     void I2C_Close(I2C_T *i2c)
000000  2105              MOVS     r1,#5
;;;51     {
;;;52         /* Reset SPI */
;;;53         if(i2c == I2C0) {
000002  4a09              LDR      r2,|L2.40|
;;;54             SYS->IPRST1 |= SYS_IPRST1_I2C0RST_Msk;
000004  0709              LSLS     r1,r1,#28
;;;55             SYS->IPRST1 &= ~SYS_IPRST1_I2C0RST_Msk;
;;;56         } else {
;;;57             SYS->IPRST1 |= SYS_IPRST1_I2C1RST_Msk;
000006  68cb              LDR      r3,[r1,#0xc]
000008  4290              CMP      r0,r2                 ;53
00000a  d101              BNE      |L2.16|
00000c  1582              ASRS     r2,r0,#22             ;54
00000e  e001              B        |L2.20|
                  |L2.16|
000010  2201              MOVS     r2,#1
000012  0252              LSLS     r2,r2,#9
                  |L2.20|
000014  4313              ORRS     r3,r3,r2
000016  60cb              STR      r3,[r1,#0xc]
;;;58             SYS->IPRST1 &= ~SYS_IPRST1_I2C1RST_Msk;
000018  68cb              LDR      r3,[r1,#0xc]
00001a  4393              BICS     r3,r3,r2
00001c  60cb              STR      r3,[r1,#0xc]
;;;59         }
;;;60     
;;;61         /* Disable I2C */
;;;62         i2c->CTL &= ~I2C_CTL_I2CEN_Msk;
00001e  6801              LDR      r1,[r0,#0]
000020  2240              MOVS     r2,#0x40
000022  4391              BICS     r1,r1,r2
000024  6001              STR      r1,[r0,#0]
;;;63     }
000026  4770              BX       lr
;;;64     
                          ENDP

                  |L2.40|
                          DCD      0x40020000

                          AREA ||i.I2C_DisableInt||, CODE, READONLY, ALIGN=1

                  I2C_DisableInt PROC
;;;104      */
;;;105    void I2C_DisableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;106    {
;;;107        i2c->CTL &= ~I2C_CTL_INTEN_Msk;
000002  2280              MOVS     r2,#0x80
000004  4391              BICS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;108    }
000008  4770              BX       lr
;;;109    
                          ENDP


                          AREA ||i.I2C_DisableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_DisableTimeout PROC
;;;266      */
;;;267    void I2C_DisableTimeout(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;268    {
;;;269        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000002  2204              MOVS     r2,#4
000004  4391              BICS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;270    }
000008  4770              BX       lr
;;;271    
                          ENDP


                          AREA ||i.I2C_DisableWakeup||, CODE, READONLY, ALIGN=2

                  I2C_DisableWakeup PROC
;;;287      */
;;;288    void I2C_DisableWakeup(I2C_T *i2c)
000000  4903              LDR      r1,|L5.16|
;;;289    {
;;;290        if(i2c == I2C0)     //only support for port0
000002  4288              CMP      r0,r1
000004  d103              BNE      |L5.14|
;;;291            i2c->CTL1 &= ~I2C_CTL1_WKEN_Msk;
000006  6bc1              LDR      r1,[r0,#0x3c]
000008  0849              LSRS     r1,r1,#1
00000a  0049              LSLS     r1,r1,#1
00000c  63c1              STR      r1,[r0,#0x3c]
                  |L5.14|
;;;292    }
00000e  4770              BX       lr
;;;293    
                          ENDP

                  |L5.16|
                          DCD      0x40020000

                          AREA ||i.I2C_EnableInt||, CODE, READONLY, ALIGN=1

                  I2C_EnableInt PROC
;;;114      */
;;;115    void I2C_EnableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;116    {
;;;117        i2c->CTL |= I2C_CTL_INTEN_Msk;
000002  2280              MOVS     r2,#0x80
000004  4311              ORRS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;118    }
000008  4770              BX       lr
;;;119    
                          ENDP


                          AREA ||i.I2C_EnableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_EnableTimeout PROC
;;;251      */
;;;252    void I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout)
000000  2202              MOVS     r2,#2
;;;253    {
;;;254        if(u8LongTimeout)
000002  2900              CMP      r1,#0
;;;255            i2c->TOCTL |= I2C_TOCTL_TOCURIEN_Msk;
;;;256        else
;;;257            i2c->TOCTL &= ~I2C_TOCTL_TOCURIEN_Msk;
000004  6941              LDR      r1,[r0,#0x14]
000006  d001              BEQ      |L7.12|
000008  4311              ORRS     r1,r1,r2              ;255
00000a  e000              B        |L7.14|
                  |L7.12|
00000c  4391              BICS     r1,r1,r2
                  |L7.14|
00000e  6141              STR      r1,[r0,#0x14]
;;;258    
;;;259        i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
000010  6941              LDR      r1,[r0,#0x14]
000012  2204              MOVS     r2,#4
000014  4311              ORRS     r1,r1,r2
000016  6141              STR      r1,[r0,#0x14]
;;;260    }
000018  4770              BX       lr
;;;261    
                          ENDP


                          AREA ||i.I2C_EnableWakeup||, CODE, READONLY, ALIGN=2

                  I2C_EnableWakeup PROC
;;;276      */
;;;277    void I2C_EnableWakeup(I2C_T *i2c)
000000  4903              LDR      r1,|L8.16|
;;;278    {
;;;279        if(i2c == I2C0)     //only support for port0
000002  4288              CMP      r0,r1
000004  d103              BNE      |L8.14|
;;;280            i2c->CTL1 |= I2C_CTL1_WKEN_Msk;
000006  6bc1              LDR      r1,[r0,#0x3c]
000008  2201              MOVS     r2,#1
00000a  4311              ORRS     r1,r1,r2
00000c  63c1              STR      r1,[r0,#0x3c]
                  |L8.14|
;;;281    }
00000e  4770              BX       lr
;;;282    
                          ENDP

                  |L8.16|
                          DCD      0x40020000

                          AREA ||i.I2C_GetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_GetBusClockFreq PROC
;;;124      */
;;;125    uint32_t I2C_GetBusClockFreq(I2C_T *i2c)
000000  b510              PUSH     {r4,lr}
;;;126    {
;;;127        uint32_t u32Divider = i2c->CLKDIV;
000002  6900              LDR      r0,[r0,#0x10]
;;;128    
;;;129        return ( SystemCoreClock / ((u32Divider+1)<<2) );
000004  0081              LSLS     r1,r0,#2
000006  4803              LDR      r0,|L9.20|
000008  1d09              ADDS     r1,r1,#4
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  f7fffffe          BL       __aeabi_uidivmod
;;;130    }
000010  bd10              POP      {r4,pc}
;;;131    
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_GetData||, CODE, READONLY, ALIGN=1

                  I2C_GetData PROC
;;;174      */
;;;175    uint32_t I2C_GetData(I2C_T *i2c)
000000  6880              LDR      r0,[r0,#8]
;;;176    {
;;;177        return ( i2c->DAT );
;;;178    }
000002  4770              BX       lr
;;;179    
                          ENDP


                          AREA ||i.I2C_GetIntFlag||, CODE, READONLY, ALIGN=1

                  I2C_GetIntFlag PROC
;;;154      */
;;;155    uint32_t I2C_GetIntFlag(I2C_T *i2c)
000000  6800              LDR      r0,[r0,#0]
;;;156    {
;;;157        return ( (i2c->CTL & I2C_CTL_SI_Msk) == I2C_CTL_SI_Msk ? 1:0 );
000002  0700              LSLS     r0,r0,#28
000004  0fc0              LSRS     r0,r0,#31
;;;158    }
000006  4770              BX       lr
;;;159    
                          ENDP


                          AREA ||i.I2C_GetStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetStatus PROC
;;;164      */
;;;165    uint32_t I2C_GetStatus(I2C_T *i2c)
000000  68c0              LDR      r0,[r0,#0xc]
;;;166    {
;;;167        return ( i2c->STATUS );
;;;168    }
000002  4770              BX       lr
;;;169    
                          ENDP


                          AREA ||i.I2C_Open||, CODE, READONLY, ALIGN=2

                  I2C_Open PROC
;;;31       */
;;;32     uint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;33     {
;;;34         uint32_t u32Div;
;;;35     
;;;36         u32Div = (uint32_t) (((SystemCoreClock * 10)/(u32BusClock * 4) + 5) / 10 - 1); /* Compute proper divider for I2C clock */
000002  4d0c              LDR      r5,|L13.52|
000004  4604              MOV      r4,r0                 ;33
000006  6828              LDR      r0,[r5,#0]  ; SystemCoreClock
000008  220a              MOVS     r2,#0xa
00000a  0089              LSLS     r1,r1,#2
00000c  4350              MULS     r0,r2,r0
00000e  f7fffffe          BL       __aeabi_uidivmod
000012  210a              MOVS     r1,#0xa
000014  1d40              ADDS     r0,r0,#5
000016  f7fffffe          BL       __aeabi_uidivmod
00001a  1e40              SUBS     r0,r0,#1
;;;37         i2c->CLKDIV = u32Div;
00001c  6120              STR      r0,[r4,#0x10]
;;;38     
;;;39         /* Enable I2C */
;;;40         i2c->CTL |= I2C_CTL_I2CEN_Msk;
00001e  6821              LDR      r1,[r4,#0]
000020  2240              MOVS     r2,#0x40
000022  4311              ORRS     r1,r1,r2
000024  6021              STR      r1,[r4,#0]
;;;41     
;;;42         return ( SystemCoreClock / ((u32Div+1)<<2) );
000026  0081              LSLS     r1,r0,#2
000028  1d09              ADDS     r1,r1,#4
00002a  6828              LDR      r0,[r5,#0]  ; SystemCoreClock
00002c  f7fffffe          BL       __aeabi_uidivmod
;;;43     }
000030  bd70              POP      {r4-r6,pc}
;;;44     
                          ENDP

000032  0000              DCW      0x0000
                  |L13.52|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_SetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_SetBusClockFreq PROC
;;;137      */
;;;138    uint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;139    {
000002  4604              MOV      r4,r0
;;;140        uint32_t u32Div;
;;;141    
;;;142        u32Div = (uint32_t) (((SystemCoreClock * 10)/(u32BusClock * 4) + 5) / 10 - 1); /* Compute proper divider for I2C clock */
000004  4809              LDR      r0,|L14.44|
000006  220a              MOVS     r2,#0xa
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000a  0089              LSLS     r1,r1,#2
00000c  4605              MOV      r5,r0
00000e  4350              MULS     r0,r2,r0
000010  f7fffffe          BL       __aeabi_uidivmod
000014  210a              MOVS     r1,#0xa
000016  1d40              ADDS     r0,r0,#5
000018  f7fffffe          BL       __aeabi_uidivmod
00001c  1e40              SUBS     r0,r0,#1
;;;143        i2c->CLKDIV = u32Div;
00001e  6120              STR      r0,[r4,#0x10]
;;;144    
;;;145        return ( SystemCoreClock / ((u32Div+1)<<2) );
000020  0081              LSLS     r1,r0,#2
000022  4628              MOV      r0,r5
000024  1d09              ADDS     r1,r1,#4
000026  f7fffffe          BL       __aeabi_uidivmod
;;;146    }
00002a  bd70              POP      {r4-r6,pc}
;;;147    
                          ENDP

                  |L14.44|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_SetData||, CODE, READONLY, ALIGN=1

                  I2C_SetData PROC
;;;185      */
;;;186    void I2C_SetData(I2C_T *i2c, uint8_t u8Data)
000000  6081              STR      r1,[r0,#8]
;;;187    {
;;;188        i2c->DAT = u8Data;
;;;189    }
000002  4770              BX       lr
;;;190    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddr||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddr PROC
;;;198      */
;;;199    void I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode)
000000  0052              LSLS     r2,r2,#1
;;;200    {
;;;201        switch (u8SlaveNo) {
;;;202        case 0:
;;;203            i2c->ADDR0  = (u8SlaveAddr << 1) | u8GCMode;
000002  431a              ORRS     r2,r2,r3
000004  2900              CMP      r1,#0                 ;201
000006  d005              BEQ      |L16.20|
000008  2901              CMP      r1,#1                 ;201
00000a  d005              BEQ      |L16.24|
00000c  2902              CMP      r1,#2                 ;201
00000e  d005              BEQ      |L16.28|
000010  2903              CMP      r1,#3                 ;201
000012  d005              BEQ      |L16.32|
                  |L16.20|
;;;204            break;
;;;205        case 1:
;;;206            i2c->ADDR1  = (u8SlaveAddr << 1) | u8GCMode;
;;;207            break;
;;;208        case 2:
;;;209            i2c->ADDR2  = (u8SlaveAddr << 1) | u8GCMode;
;;;210            break;
;;;211        case 3:
;;;212            i2c->ADDR3  = (u8SlaveAddr << 1) | u8GCMode;
;;;213            break;
;;;214        default:
;;;215            i2c->ADDR0  = (u8SlaveAddr << 1) | u8GCMode;
000014  6042              STR      r2,[r0,#4]
;;;216        }
;;;217    }
000016  4770              BX       lr
                  |L16.24|
000018  6182              STR      r2,[r0,#0x18]         ;206
00001a  4770              BX       lr
                  |L16.28|
00001c  61c2              STR      r2,[r0,#0x1c]         ;209
00001e  4770              BX       lr
                  |L16.32|
000020  6202              STR      r2,[r0,#0x20]         ;212
000022  4770              BX       lr
;;;218    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddrMask||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddrMask PROC
;;;225      */
;;;226    void I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask)
000000  0052              LSLS     r2,r2,#1
;;;227    {
;;;228        switch (u8SlaveNo) {
000002  2900              CMP      r1,#0
000004  d005              BEQ      |L17.18|
000006  2901              CMP      r1,#1
000008  d005              BEQ      |L17.22|
00000a  2902              CMP      r1,#2
00000c  d005              BEQ      |L17.26|
00000e  2903              CMP      r1,#3
000010  d005              BEQ      |L17.30|
                  |L17.18|
;;;229        case 0:
;;;230            i2c->ADDRMSK0  = u8SlaveAddrMask << 1;
;;;231            break;
;;;232        case 1:
;;;233            i2c->ADDRMSK1  = u8SlaveAddrMask << 1;
;;;234            break;
;;;235        case 2:
;;;236            i2c->ADDRMSK2  = u8SlaveAddrMask << 1;
;;;237            break;
;;;238        case 3:
;;;239            i2c->ADDRMSK3  = u8SlaveAddrMask << 1;
;;;240            break;
;;;241        default:
;;;242            i2c->ADDRMSK0  = u8SlaveAddrMask << 1;
000012  6242              STR      r2,[r0,#0x24]
;;;243        }
;;;244    }
000014  4770              BX       lr
                  |L17.22|
000016  6282              STR      r2,[r0,#0x28]         ;233
000018  4770              BX       lr
                  |L17.26|
00001a  62c2              STR      r2,[r0,#0x2c]         ;236
00001c  4770              BX       lr
                  |L17.30|
00001e  6302              STR      r2,[r0,#0x30]         ;239
000020  4770              BX       lr
;;;245    
                          ENDP


                          AREA ||i.I2C_Trigger||, CODE, READONLY, ALIGN=1

                  I2C_Trigger PROC
;;;83       */
;;;84     void I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack)
000000  b530              PUSH     {r4,r5,lr}
;;;85     {
;;;86         uint32_t u32Reg = 0;
000002  2400              MOVS     r4,#0
;;;87     
;;;88         if (u8Start)
000004  9d03              LDR      r5,[sp,#0xc]
000006  2900              CMP      r1,#0
000008  d000              BEQ      |L18.12|
;;;89             u32Reg |= I2C_STA;
00000a  2420              MOVS     r4,#0x20
                  |L18.12|
;;;90         if (u8Stop)
00000c  2a00              CMP      r2,#0
00000e  d001              BEQ      |L18.20|
;;;91             u32Reg |= I2C_STO;
000010  2110              MOVS     r1,#0x10
000012  430c              ORRS     r4,r4,r1
                  |L18.20|
;;;92         if (u8Si)
000014  2b00              CMP      r3,#0
000016  d001              BEQ      |L18.28|
;;;93             u32Reg |= I2C_SI;
000018  2108              MOVS     r1,#8
00001a  430c              ORRS     r4,r4,r1
                  |L18.28|
;;;94         if (u8Ack)
00001c  2d00              CMP      r5,#0
00001e  d001              BEQ      |L18.36|
;;;95             u32Reg |= I2C_AA;
000020  2104              MOVS     r1,#4
000022  430c              ORRS     r4,r4,r1
                  |L18.36|
;;;96     
;;;97         i2c->CTL = (i2c->CTL & ~0x3C) | u32Reg;
000024  6801              LDR      r1,[r0,#0]
000026  223c              MOVS     r2,#0x3c
000028  4391              BICS     r1,r1,r2
00002a  4321              ORRS     r1,r1,r4
00002c  6001              STR      r1,[r0,#0]
;;;98     }
00002e  bd30              POP      {r4,r5,pc}
;;;99     
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Library\\StdDriver\\src\\i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REV16|
#line 388 "..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_i2c_c_I2C_Open____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REVSH|
#line 402
|__asm___5_i2c_c_I2C_Open____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
