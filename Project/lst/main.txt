; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\Library\StdDriver\inc -I..\Library\CMSIS\Include -I..\Library\Device\Nuvoton\Mini58Series\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=523 --omf_browse=.\obj\main.crf ..\App\src\main.c]
                          THUMB

                          AREA ||i.EINT0_IRQHandler||, CODE, READONLY, ALIGN=2

                  EINT0_IRQHandler PROC
;;;76      */
;;;77     void EINT0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;78     {
;;;79         /* For P3.2, clear the INT flag */
;;;80         P3->INTSRC = BIT2;
000002  4906              LDR      r1,|L1.28|
000004  2004              MOVS     r0,#4
000006  6208              STR      r0,[r1,#0x20]
;;;81         P30 = P30 ^ 1;
000008  4805              LDR      r0,|L1.32|
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  2201              MOVS     r2,#1
00000e  4051              EORS     r1,r1,r2
000010  6201              STR      r1,[r0,#0x20]
;;;82         printf("P3.2 EINT0 occurred. \r\n");
000012  a004              ADR      r0,|L1.36|
000014  f7fffffe          BL       __2printf
;;;83     }
000018  bd10              POP      {r4,pc}
;;;84     
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      0x500040c0
                  |L1.32|
                          DCD      0x50004240
                  |L1.36|
000024  50332e32          DCB      "P3.2 EINT0 occurred. \r\n",0
000028  2045494e
00002c  5430206f
000030  63637572
000034  7265642e
000038  200d0a00

                          AREA ||i.EINT1_IRQHandler||, CODE, READONLY, ALIGN=2

                  EINT1_IRQHandler PROC
;;;94      */
;;;95     void EINT1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;96     {
;;;97         /* For P5.2, clear the INT flag */
;;;98         P5->INTSRC = BIT2;
000002  4906              LDR      r1,|L2.28|
000004  2004              MOVS     r0,#4
000006  6208              STR      r0,[r1,#0x20]
;;;99         P30 = P30 ^ 1;
000008  4805              LDR      r0,|L2.32|
00000a  6a01              LDR      r1,[r0,#0x20]
00000c  2201              MOVS     r2,#1
00000e  4051              EORS     r1,r1,r2
000010  6201              STR      r1,[r0,#0x20]
;;;100        printf("P5.2 EINT1 occurred. \r\n");
000012  a004              ADR      r0,|L2.36|
000014  f7fffffe          BL       __2printf
;;;101    }
000018  bd10              POP      {r4,pc}
;;;102    
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x50004140
                  |L2.32|
                          DCD      0x50004240
                  |L2.36|
000024  50352e32          DCB      "P5.2 EINT1 occurred. \r\n",0
000028  2045494e
00002c  5431206f
000030  63637572
000034  7265642e
000038  200d0a00

                          AREA ||i.GPIO01_IRQHandler||, CODE, READONLY, ALIGN=2

                  GPIO01_IRQHandler PROC
;;;24      */
;;;25     void GPIO01_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;26     {
;;;27         /* To check if P1.5 interrupt occurred */
;;;28         if (P1->INTSRC & BIT5) {
000002  480b              LDR      r0,|L3.48|
000004  6a01              LDR      r1,[r0,#0x20]
000006  0689              LSLS     r1,r1,#26
000008  d508              BPL      |L3.28|
;;;29             P1->INTSRC = BIT5;
00000a  2120              MOVS     r1,#0x20
00000c  6201              STR      r1,[r0,#0x20]
;;;30             P30 = P30 ^ 1;
00000e  4809              LDR      r0,|L3.52|
000010  6a01              LDR      r1,[r0,#0x20]
000012  2201              MOVS     r2,#1
000014  4051              EORS     r1,r1,r2
000016  6201              STR      r1,[r0,#0x20]
;;;31             printf("P1.5 INT occurred. \r\n");
000018  a007              ADR      r0,|L3.56|
00001a  e006              B        |L3.42|
                  |L3.28|
;;;32     
;;;33         } else {
;;;34             /* Un-expected interrupt. Just clear all PORT0, PORT1 interrupts */
;;;35             P0->INTSRC = P0->INTSRC;
00001c  4904              LDR      r1,|L3.48|
00001e  3940              SUBS     r1,r1,#0x40
000020  6a0a              LDR      r2,[r1,#0x20]
000022  620a              STR      r2,[r1,#0x20]
;;;36             P1->INTSRC = P1->INTSRC;
000024  6a01              LDR      r1,[r0,#0x20]
000026  6201              STR      r1,[r0,#0x20]
;;;37             printf("Un-expected interrupts. \r\n");
000028  a009              ADR      r0,|L3.80|
                  |L3.42|
00002a  f7fffffe          BL       __2printf
;;;38         }
;;;39     }
00002e  bd10              POP      {r4,pc}
;;;40     
                          ENDP

                  |L3.48|
                          DCD      0x50004040
                  |L3.52|
                          DCD      0x50004240
                  |L3.56|
000038  50312e35          DCB      "P1.5 INT occurred. \r\n",0
00003c  20494e54
000040  206f6363
000044  75727265
000048  642e200d
00004c  0a00    
00004e  00                DCB      0
00004f  00                DCB      0
                  |L3.80|
000050  556e2d65          DCB      "Un-expected interrupts. \r\n",0
000054  78706563
000058  74656420
00005c  696e7465
000060  72727570
000064  74732e20
000068  0d0a00  
00006b  00                DCB      0

                          AREA ||i.GPIO234_IRQHandler||, CODE, READONLY, ALIGN=2

                  GPIO234_IRQHandler PROC
;;;50      */
;;;51     void GPIO234_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;52     {
;;;53         /* To check if P2.2 interrupt occurred */
;;;54         if (P2->INTSRC & BIT2) {
000002  480d              LDR      r0,|L4.56|
000004  6a01              LDR      r1,[r0,#0x20]
000006  0749              LSLS     r1,r1,#29
000008  d508              BPL      |L4.28|
;;;55             P2->INTSRC = BIT2;
00000a  2104              MOVS     r1,#4
00000c  6201              STR      r1,[r0,#0x20]
;;;56             P30 = P30 ^ 1;
00000e  480b              LDR      r0,|L4.60|
000010  6a01              LDR      r1,[r0,#0x20]
000012  2201              MOVS     r2,#1
000014  4051              EORS     r1,r1,r2
000016  6201              STR      r1,[r0,#0x20]
;;;57             printf("P2.2 INT occurred. \r\n");
000018  a009              ADR      r0,|L4.64|
00001a  e00a              B        |L4.50|
                  |L4.28|
;;;58         } else {
;;;59             /* Un-expected interrupt. Just clear all PORT2, PORT3 and PORT4 interrupts */
;;;60             P2->INTSRC = P2->INTSRC;
00001c  6a01              LDR      r1,[r0,#0x20]
00001e  6201              STR      r1,[r0,#0x20]
;;;61             P3->INTSRC = P3->INTSRC;
000020  4805              LDR      r0,|L4.56|
000022  3040              ADDS     r0,r0,#0x40
000024  6a01              LDR      r1,[r0,#0x20]
000026  6201              STR      r1,[r0,#0x20]
;;;62             P4->INTSRC = P4->INTSRC;
000028  4803              LDR      r0,|L4.56|
00002a  3080              ADDS     r0,r0,#0x80
00002c  6a01              LDR      r1,[r0,#0x20]
00002e  6201              STR      r1,[r0,#0x20]
;;;63             printf("Un-expected interrupts. \r\n");
000030  a009              ADR      r0,|L4.88|
                  |L4.50|
000032  f7fffffe          BL       __2printf
;;;64         }
;;;65     }
000036  bd10              POP      {r4,pc}
;;;66     
                          ENDP

                  |L4.56|
                          DCD      0x50004080
                  |L4.60|
                          DCD      0x50004240
                  |L4.64|
000040  50322e32          DCB      "P2.2 INT occurred. \r\n",0
000044  20494e54
000048  206f6363
00004c  75727265
000050  642e200d
000054  0a00    
000056  00                DCB      0
000057  00                DCB      0
                  |L4.88|
000058  556e2d65          DCB      "Un-expected interrupts. \r\n",0
00005c  78706563
000060  74656420
000064  696e7465
000068  72727570
00006c  74732e20
000070  0d0a00  
000073  00                DCB      0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_EnableIRQ PROC
;;;628     */
;;;629    __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  06c1              LSLS     r1,r0,#27
;;;630    {
;;;631      NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000002  0ec9              LSRS     r1,r1,#27
000004  2001              MOVS     r0,#1
000006  4088              LSLS     r0,r0,r1
000008  4901              LDR      r1,|L5.16|
00000a  6008              STR      r0,[r1,#0]
;;;632    }
00000c  4770              BX       lr
;;;633    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      0xe000e100

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;102    
;;;103    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  4c1b              LDR      r4,|L6.116|
000006  2116              MOVS     r1,#0x16
000008  2288              MOVS     r2,#0x88
                  |L6.10|
00000a  6020              STR      r0,[r4,#0]
00000c  6021              STR      r1,[r4,#0]
00000e  6022              STR      r2,[r4,#0]
000010  6823              LDR      r3,[r4,#0]
000012  2b00              CMP      r3,#0
000014  d0f9              BEQ      |L6.10|
;;;104    {
;;;105        /* Unlock protected registers */
;;;106        SYS_UnlockReg();
;;;107    
;;;108        /* Set P5 multi-function pins for XTAL1 and XTAL2 */
;;;109        SYS->P5_MFP &= ~(SYS_MFP_P50_Msk | SYS_MFP_P51_Msk);
000016  4817              LDR      r0,|L6.116|
000018  38c0              SUBS     r0,r0,#0xc0
00001a  6841              LDR      r1,[r0,#4]
00001c  4a16              LDR      r2,|L6.120|
00001e  4011              ANDS     r1,r1,r2
000020  6041              STR      r1,[r0,#4]
;;;110        SYS->P5_MFP |= (SYS_MFP_P50_XT1_IN | SYS_MFP_P51_XT1_OUT);
000022  6841              LDR      r1,[r0,#4]
000024  2203              MOVS     r2,#3
000026  4311              ORRS     r1,r1,r2
000028  6041              STR      r1,[r0,#4]
;;;111    
;;;112        /*---------------------------------------------------------------------------------------------------------*/
;;;113        /* Init System Clock                                                                                       */
;;;114        /*---------------------------------------------------------------------------------------------------------*/
;;;115    
;;;116        /* Enable external 12MHz XTAL, HIRC */
;;;117        CLK->PWRCTL |= CLK_PWRCTL_XTL12M | CLK_PWRCTL_HIRCEN_Msk;
00002a  4814              LDR      r0,|L6.124|
00002c  6801              LDR      r1,[r0,#0]
00002e  2205              MOVS     r2,#5
000030  4311              ORRS     r1,r1,r2
000032  6001              STR      r1,[r0,#0]
;;;118    
;;;119        /* Waiting for clock ready */
;;;120        CLK_WaitClockReady(CLK_STATUS_XTLSTB_Msk | CLK_STATUS_HIRCSTB_Msk);
000034  2011              MOVS     r0,#0x11
000036  f7fffffe          BL       CLK_WaitClockReady
;;;121    
;;;122        /* Switch HCLK clock source to XTL */
;;;123        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_XTAL,CLK_CLKDIV_HCLK(1));
00003a  2100              MOVS     r1,#0
00003c  4608              MOV      r0,r1
00003e  f7fffffe          BL       CLK_SetHCLK
;;;124    
;;;125        /* STCLK to XTL STCLK to XTL */
;;;126        CLK_SetSysTickClockSrc(CLK_CLKSEL0_STCLKSEL_XTAL);
000042  2000              MOVS     r0,#0
000044  f7fffffe          BL       CLK_SetSysTickClockSrc
;;;127    
;;;128        /* Enable IP clock */
;;;129        CLK_EnableModuleClock(UART0_MODULE);
000048  4d0d              LDR      r5,|L6.128|
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       CLK_EnableModuleClock
;;;130    
;;;131        /* Select IP clock source */
;;;132        CLK_SetModuleClock(UART0_MODULE,CLK_CLKSEL1_UARTSEL_XTAL,CLK_CLKDIV_UART(1));
000050  2200              MOVS     r2,#0
000052  4611              MOV      r1,r2
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       CLK_SetModuleClock
;;;133    
;;;134        /*---------------------------------------------------------------------------------------------------------*/
;;;135        /* Init I/O Multi-function                                                                                 */
;;;136        /*---------------------------------------------------------------------------------------------------------*/
;;;137        /* Set P1 multi-function pins for UART RXD, TXD */
;;;138        SYS->P1_MFP = SYS_MFP_P12_UART0_RXD | SYS_MFP_P13_UART0_TXD;
00005a  2103              MOVS     r1,#3
00005c  0289              LSLS     r1,r1,#10
00005e  2005              MOVS     r0,#5
000060  0700              LSLS     r0,r0,#28
000062  6341              STR      r1,[r0,#0x34]
;;;139    
;;;140        /* Set P3 multi-function pins for Clock Output */
;;;141        SYS->P3_MFP = SYS_MFP_P36_CLKO;
000064  2101              MOVS     r1,#1
000066  0389              LSLS     r1,r1,#14
000068  63c1              STR      r1,[r0,#0x3c]
;;;142    
;;;143        /* To update the variable SystemCoreClock */
;;;144        SystemCoreClockUpdate();
00006a  f7fffffe          BL       SystemCoreClockUpdate
00006e  2000              MOVS     r0,#0
000070  6020              STR      r0,[r4,#0]
;;;145    
;;;146        /* Lock protected registers */
;;;147        SYS_LockReg();
;;;148    }
000072  bd70              POP      {r4-r6,pc}
;;;149    
                          ENDP

                  |L6.116|
                          DCD      0x50000100
                  |L6.120|
                          DCD      0xfffffcfc
                  |L6.124|
                          DCD      0x50000200
                  |L6.128|
                          DCD      0xa7803d10

                          AREA ||i.UART_Init||, CODE, READONLY, ALIGN=2

                  UART_Init PROC
;;;149    
;;;150    void UART_Init(void)
000000  b510              PUSH     {r4,lr}
;;;151    {
;;;152        /*---------------------------------------------------------------------------------------------------------*/
;;;153        /* Init UART                                                                                               */
;;;154        /*---------------------------------------------------------------------------------------------------------*/
;;;155        /* Reset IP */
;;;156        SYS_ResetModule(SYS_IPRST1_UART0RST_Msk);
000002  2001              MOVS     r0,#1
000004  0400              LSLS     r0,r0,#16
000006  f7fffffe          BL       SYS_ResetModule
;;;157    
;;;158        /* Configure UART and set UART Baudrate */
;;;159        UART_Open(UART0, 115200);
00000a  21e1              MOVS     r1,#0xe1
00000c  0249              LSLS     r1,r1,#9
00000e  4802              LDR      r0,|L7.24|
000010  f7fffffe          BL       UART_Open
;;;160    
;;;161    }
000014  bd10              POP      {r4,pc}
;;;162    
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      0x40050000

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  main PROC
;;;165    /*---------------------------------------------------------------------------------------------------------*/
;;;166    int main (void)
000000  f7fffffe          BL       SYS_Init
;;;167    {
;;;168        int32_t i32Err;
;;;169    
;;;170        /* Init System, IP clock and multi-function I/O */
;;;171        SYS_Init(); //In the end of SYS_Init() will issue SYS_LockReg() to lock protected register. If user want to write protected register, please issue SYS_UnlockReg() to unlock protected register.
;;;172    
;;;173        /* Init UART for printf */
;;;174        UART_Init();
000004  f7fffffe          BL       UART_Init
;;;175    
;;;176        printf("\r\n\r\nCPU @ %dHz\r\n", SystemCoreClock);
000008  484d              LDR      r0,|L8.320|
00000a  6801              LDR      r1,[r0,#0]  ; SystemCoreClock
00000c  a04d              ADR      r0,|L8.324|
00000e  f7fffffe          BL       __2printf
;;;177    
;;;178        printf("+-------------------------------------+ \r\n");
000012  a051              ADR      r0,|L8.344|
000014  f7fffffe          BL       __2printf
;;;179        printf("|    Mini58 GPIO Driver Sample Code  | \r\n");
000018  a05a              ADR      r0,|L8.388|
00001a  f7fffffe          BL       __2printf
;;;180        printf("+-------------------------------------+ \r\n");
00001e  a04e              ADR      r0,|L8.344|
000020  f7fffffe          BL       __2printf
;;;181    
;;;182        /*-----------------------------------------------------------------------------------------------------*/
;;;183        /* GPIO Basic Mode Test --- Use Pin Data Input/Output to control GPIO pin                              */
;;;184        /*-----------------------------------------------------------------------------------------------------*/
;;;185        printf("  >> Please connect P1.0 and P3.4 first << \r\n");
000024  a062              ADR      r0,|L8.432|
000026  f7fffffe          BL       __2printf
;;;186        printf("     Press any key to start test by using [Pin Data Input/Output Control] \r\n\r\n");
00002a  486d              LDR      r0,|L8.480|
00002c  f7fffffe          BL       __2printf
;;;187        getchar();
000030  486c              LDR      r0,|L8.484|
000032  f7fffffe          BL       getc
;;;188    
;;;189        /* Configure P1.0 as Output mode and P3.4 as Input mode then close it */
;;;190        GPIO_SetMode(P1, BIT0, GPIO_MODE_OUTPUT);
000036  4f6c              LDR      r7,|L8.488|
000038  2201              MOVS     r2,#1
00003a  4611              MOV      r1,r2
00003c  4638              MOV      r0,r7
00003e  f7fffffe          BL       GPIO_SetMode
;;;191        GPIO_SetMode(P3, BIT4, GPIO_MODE_INPUT);
000042  4d69              LDR      r5,|L8.488|
000044  2200              MOVS     r2,#0
000046  3580              ADDS     r5,r5,#0x80
000048  2110              MOVS     r1,#0x10
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       GPIO_SetMode
;;;192    
;;;193        i32Err = 0;
000050  2400              MOVS     r4,#0
;;;194        printf("  GPIO Output/Input test ...... \r\n");
000052  a066              ADR      r0,|L8.492|
000054  f7fffffe          BL       __2printf
;;;195    
;;;196        /* Use Pin Data Input/Output Control to pull specified I/O or get I/O pin status */
;;;197        P10 = 0;
000058  486d              LDR      r0,|L8.528|
00005a  2100              MOVS     r1,#0
00005c  6201              STR      r1,[r0,#0x20]
;;;198        if (P34 != 0) {
00005e  496c              LDR      r1,|L8.528|
000060  3140              ADDS     r1,r1,#0x40
000062  6b0a              LDR      r2,[r1,#0x30]
000064  2a00              CMP      r2,#0
000066  d000              BEQ      |L8.106|
;;;199            i32Err = 1;
000068  2401              MOVS     r4,#1
                  |L8.106|
;;;200        }
;;;201    
;;;202        P10 = 1;
00006a  2201              MOVS     r2,#1
00006c  6202              STR      r2,[r0,#0x20]
;;;203        if (P34 != 1) {
00006e  6b08              LDR      r0,[r1,#0x30]
000070  2801              CMP      r0,#1
000072  d101              BNE      |L8.120|
;;;204            i32Err = 1;
;;;205        }
;;;206    
;;;207        if ( i32Err ) {
000074  2c00              CMP      r4,#0
000076  d001              BEQ      |L8.124|
                  |L8.120|
;;;208            printf("  [FAIL] --- Please make sure P1.0 and P3.4 are connected. \r\n");
000078  a066              ADR      r0,|L8.532|
00007a  e000              B        |L8.126|
                  |L8.124|
;;;209        } else {
;;;210            printf("  [OK] \r\n");
00007c  a075              ADR      r0,|L8.596|
                  |L8.126|
00007e  f7fffffe          BL       __2printf
;;;211        }
;;;212    
;;;213        /* Configure P1.0 and P3.4 to default Quasi-bidirectional mode */
;;;214        GPIO_SetMode(P1, BIT0, GPIO_MODE_QUASI);
000082  2203              MOVS     r2,#3
000084  2101              MOVS     r1,#1
000086  4638              MOV      r0,r7
000088  f7fffffe          BL       GPIO_SetMode
;;;215        GPIO_SetMode(P3, BIT4, GPIO_MODE_QUASI);
00008c  2203              MOVS     r2,#3
00008e  2110              MOVS     r1,#0x10
000090  462c              MOV      r4,r5
000092  4628              MOV      r0,r5
000094  f7fffffe          BL       GPIO_SetMode
;;;216    
;;;217    
;;;218        /*-----------------------------------------------------------------------------------------------------*/
;;;219        /* GPIO Interrupt Function Test                                                                        */
;;;220        /*-----------------------------------------------------------------------------------------------------*/
;;;221        printf("\r\n  P15, P22, P32(INT0) and P52(INT1) are used to test interrupt\r\n  and control LEDs(P30)\r\n");
000098  4871              LDR      r0,|L8.608|
00009a  f7fffffe          BL       __2printf
;;;222    
;;;223        /*Configure P30 for LED control */
;;;224        GPIO_SetMode(P3, BIT0, GPIO_MODE_OUTPUT);
00009e  2201              MOVS     r2,#1
0000a0  4611              MOV      r1,r2
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       GPIO_SetMode
;;;225    
;;;226        /* Configure P1.5 as Input mode and enable interrupt by rising edge trigger */
;;;227        GPIO_SetMode(P1, BIT5, GPIO_MODE_INPUT);
0000a8  2200              MOVS     r2,#0
0000aa  2120              MOVS     r1,#0x20
0000ac  4638              MOV      r0,r7
0000ae  f7fffffe          BL       GPIO_SetMode
;;;228        GPIO_EnableInt(P1, 5, GPIO_INT_RISING);
0000b2  2201              MOVS     r2,#1
0000b4  0412              LSLS     r2,r2,#16
0000b6  2105              MOVS     r1,#5
0000b8  4638              MOV      r0,r7
0000ba  f7fffffe          BL       GPIO_EnableInt
;;;229        NVIC_EnableIRQ(GPIO01_IRQn);
0000be  2004              MOVS     r0,#4
0000c0  f7fffffe          BL       NVIC_EnableIRQ
;;;230    
;;;231    
;;;232        /*  Configure P2.2 as Quasi-bidirection mode and enable interrupt by falling edge trigger */
;;;233        GPIO_SetMode(P2, BIT2, GPIO_MODE_QUASI);
0000c4  4d48              LDR      r5,|L8.488|
0000c6  2203              MOVS     r2,#3
0000c8  3540              ADDS     r5,r5,#0x40
0000ca  2104              MOVS     r1,#4
0000cc  4628              MOV      r0,r5
0000ce  f7fffffe          BL       GPIO_SetMode
;;;234        GPIO_EnableInt(P2, 2, GPIO_INT_FALLING);
0000d2  2201              MOVS     r2,#1
0000d4  2102              MOVS     r1,#2
0000d6  4628              MOV      r0,r5
0000d8  f7fffffe          BL       GPIO_EnableInt
;;;235        NVIC_EnableIRQ(GPIO234_IRQn);
0000dc  2005              MOVS     r0,#5
0000de  f7fffffe          BL       NVIC_EnableIRQ
;;;236    
;;;237        /* Configure P3.2 as EINT0 pin and enable interrupt by falling edge trigger */
;;;238        GPIO_SetMode(P3, BIT2, GPIO_MODE_INPUT);
0000e2  2200              MOVS     r2,#0
0000e4  2104              MOVS     r1,#4
0000e6  4620              MOV      r0,r4
0000e8  f7fffffe          BL       GPIO_SetMode
;;;239        GPIO_EnableEINT0(P3, 2, GPIO_INT_FALLING);
0000ec  2201              MOVS     r2,#1
0000ee  2102              MOVS     r1,#2
0000f0  4620              MOV      r0,r4
0000f2  f7fffffe          BL       GPIO_EnableInt
;;;240        NVIC_EnableIRQ(EINT0_IRQn);
0000f6  2002              MOVS     r0,#2
0000f8  f7fffffe          BL       NVIC_EnableIRQ
;;;241    
;;;242        /* Configure P5.2 as EINT1 pin and enable interrupt by rising and falling edge trigger */
;;;243        GPIO_SetMode(P5, BIT2, GPIO_MODE_INPUT);
0000fc  4e44              LDR      r6,|L8.528|
0000fe  2200              MOVS     r2,#0
000100  3ec0              SUBS     r6,r6,#0xc0
000102  2104              MOVS     r1,#4
000104  4630              MOV      r0,r6
000106  f7fffffe          BL       GPIO_SetMode
;;;244        GPIO_EnableEINT1(P5, 2, GPIO_INT_BOTH_EDGE);
00010a  4a56              LDR      r2,|L8.612|
00010c  2102              MOVS     r1,#2
00010e  4630              MOV      r0,r6
000110  f7fffffe          BL       GPIO_EnableInt
;;;245        NVIC_EnableIRQ(EINT1_IRQn);
000114  2003              MOVS     r0,#3
000116  f7fffffe          BL       NVIC_EnableIRQ
;;;246    
;;;247        /* Enable interrupt de-bounce function and select de-bounce sampling cycle time */
;;;248        GPIO_SET_DEBOUNCE_TIME(GPIO_DBCTL_DBCLKSRC_HCLK, GPIO_DBCTL_DBCLKSEL_1);
00011a  493d              LDR      r1,|L8.528|
00011c  2020              MOVS     r0,#0x20
00011e  3980              SUBS     r1,r1,#0x80
000120  6008              STR      r0,[r1,#0]
;;;249        GPIO_ENABLE_DEBOUNCE(P1, BIT5);
000122  6979              LDR      r1,[r7,#0x14]
000124  4301              ORRS     r1,r1,r0
000126  6179              STR      r1,[r7,#0x14]
;;;250        GPIO_ENABLE_DEBOUNCE(P2, BIT2);
000128  6968              LDR      r0,[r5,#0x14]
00012a  2104              MOVS     r1,#4
00012c  4308              ORRS     r0,r0,r1
00012e  6168              STR      r0,[r5,#0x14]
;;;251        GPIO_ENABLE_DEBOUNCE(P3, BIT2);
000130  6960              LDR      r0,[r4,#0x14]
000132  4308              ORRS     r0,r0,r1
000134  6160              STR      r0,[r4,#0x14]
;;;252        GPIO_ENABLE_DEBOUNCE(P5, BIT2);
000136  6970              LDR      r0,[r6,#0x14]
000138  4308              ORRS     r0,r0,r1
00013a  6170              STR      r0,[r6,#0x14]
                  |L8.316|
;;;253    
;;;254        /* Waiting for interrupts */
;;;255        while (1);
00013c  e7fe              B        |L8.316|
;;;256    
;;;257    }
;;;258    
                          ENDP

00013e  0000              DCW      0x0000
                  |L8.320|
                          DCD      SystemCoreClock
                  |L8.324|
000144  0d0a0d0a          DCB      "\r\n\r\nCPU @ %dHz\r\n",0
000148  43505520
00014c  40202564
000150  487a0d0a
000154  00      
000155  00                DCB      0
000156  00                DCB      0
000157  00                DCB      0
                  |L8.344|
000158  2b2d2d2d          DCB      "+-------------------------------------+ \r\n",0
00015c  2d2d2d2d
000160  2d2d2d2d
000164  2d2d2d2d
000168  2d2d2d2d
00016c  2d2d2d2d
000170  2d2d2d2d
000174  2d2d2d2d
000178  2d2d2d2d
00017c  2d2d2b20
000180  0d0a00  
000183  00                DCB      0
                  |L8.388|
000184  7c202020          DCB      "|    Mini58 GPIO Driver Sample Code  | \r\n",0
000188  204d696e
00018c  69353820
000190  4750494f
000194  20447269
000198  76657220
00019c  53616d70
0001a0  6c652043
0001a4  6f646520
0001a8  207c200d
0001ac  0a00    
0001ae  00                DCB      0
0001af  00                DCB      0
                  |L8.432|
0001b0  20203e3e          DCB      "  >> Please connect P1.0 and P3.4 first << \r\n",0
0001b4  20506c65
0001b8  61736520
0001bc  636f6e6e
0001c0  65637420
0001c4  50312e30
0001c8  20616e64
0001cc  2050332e
0001d0  34206669
0001d4  72737420
0001d8  3c3c200d
0001dc  0a00    
0001de  00                DCB      0
0001df  00                DCB      0
                  |L8.480|
                          DCD      ||.conststring||
                  |L8.484|
                          DCD      __stdin
                  |L8.488|
                          DCD      0x50004040
                  |L8.492|
0001ec  20204750          DCB      "  GPIO Output/Input test ...... \r\n",0
0001f0  494f204f
0001f4  75747075
0001f8  742f496e
0001fc  70757420
000200  74657374
000204  202e2e2e
000208  2e2e2e20
00020c  0d0a00  
00020f  00                DCB      0
                  |L8.528|
                          DCD      0x50004200
                  |L8.532|
000214  20205b46          DCB      "  [FAIL] --- Please make sure P1.0 and P3.4 are connect"
000218  41494c5d
00021c  202d2d2d
000220  20506c65
000224  61736520
000228  6d616b65
00022c  20737572
000230  65205031
000234  2e302061
000238  6e642050
00023c  332e3420
000240  61726520
000244  636f6e6e
000248  656374  
00024b  65642e20          DCB      "ed. \r\n",0
00024f  0d0a00  
000252  00                DCB      0
000253  00                DCB      0
                  |L8.596|
000254  20205b4f          DCB      "  [OK] \r\n",0
000258  4b5d200d
00025c  0a00    
00025e  00                DCB      0
00025f  00                DCB      0
                  |L8.608|
                          DCD      ||.conststring||+0x50
                  |L8.612|
                          DCD      0x00010001

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  20202020          DCB      "     Press any key to start test by using [Pin Data Inp"
000004  20507265
000008  73732061
00000c  6e79206b
000010  65792074
000014  6f207374
000018  61727420
00001c  74657374
000020  20627920
000024  7573696e
000028  67205b50
00002c  696e2044
000030  61746120
000034  496e70  
000037  75742f4f          DCB      "ut/Output Control] \r\n\r\n",0
00003b  75747075
00003f  7420436f
000043  6e74726f
000047  6c5d200d
00004b  0a0d0a00
00004f  00                DCB      0
000050  0d0a2020          DCB      "\r\n  P15, P22, P32(INT0) and P52(INT1) are used to tes"
000054  5031352c
000058  20503232
00005c  2c205033
000060  3228494e
000064  54302920
000068  616e6420
00006c  50353228
000070  494e5431
000074  29206172
000078  65207573
00007c  65642074
000080  6f207465
000084  73      
000085  7420696e          DCB      "t interrupt\r\n  and control LEDs(P30)\r\n",0
000089  74657272
00008d  7570740d
000091  0a202061
000095  6e642063
000099  6f6e7472
00009d  6f6c204c
0000a1  45447328
0000a5  50333029
0000a9  0d0a00  

;*** Start embedded assembler ***

#line 1 "..\\App\\src\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_d2b4f438____REV16|
#line 388 "..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_d2b4f438____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_d2b4f438____REVSH|
#line 402
|__asm___6_main_c_d2b4f438____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
