; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\pwm.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\pwm.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\Library\StdDriver\inc -I..\Library\CMSIS\Include -I..\Library\Device\Nuvoton\Mini58Series\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=523 --omf_browse=.\obj\pwm.crf ..\Library\StdDriver\src\pwm.c]
                          THUMB

                          AREA ||i.PWM_ClearADCTriggerFlag||, CODE, READONLY, ALIGN=2

                  PWM_ClearADCTriggerFlag PROC
;;;211     */
;;;212    void PWM_ClearADCTriggerFlag (PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000000  4b07              LDR      r3,|L1.32|
;;;213    {
;;;214        if(u32ChannelNum < 4) {
;;;215            PWM->ADCTSTS0 |= (u32Condition << (8 * u32ChannelNum));
000002  00c8              LSLS     r0,r1,#3
000004  2904              CMP      r1,#4                 ;214
000006  d204              BCS      |L1.18|
000008  6b19              LDR      r1,[r3,#0x30]
00000a  4082              LSLS     r2,r2,r0
00000c  4311              ORRS     r1,r1,r2
00000e  6319              STR      r1,[r3,#0x30]
;;;216        } else {
;;;217            PWM->ADCTSTS1 |= (u32Condition << (8 * (u32ChannelNum - 4)));
;;;218        }
;;;219    }
000010  4770              BX       lr
                  |L1.18|
000012  3820              SUBS     r0,r0,#0x20
000014  4082              LSLS     r2,r2,r0              ;217
000016  6b58              LDR      r0,[r3,#0x34]         ;217
000018  4302              ORRS     r2,r2,r0              ;217
00001a  635a              STR      r2,[r3,#0x34]         ;217
00001c  4770              BX       lr
;;;220    
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      0x40040040

                          AREA ||i.PWM_ClearCenterIntFlag||, CODE, READONLY, ALIGN=2

                  PWM_ClearCenterIntFlag PROC
;;;547     */
;;;548    void PWM_ClearCenterIntFlag (PWM_T *pwm, uint32_t u32ChannelNum)
000000  2001              MOVS     r0,#1
;;;549    {
;;;550        PWM->INTSTS = (PWM_INTSTS_PIF0_Msk << u32ChannelNum);
000002  0480              LSLS     r0,r0,#18
000004  4088              LSLS     r0,r0,r1
000006  4901              LDR      r1,|L2.12|
000008  6188              STR      r0,[r1,#0x18]
;;;551    }
00000a  4770              BX       lr
;;;552    
                          ENDP

                  |L2.12|
                          DCD      0x40040040

                          AREA ||i.PWM_ClearDutyIntFlag||, CODE, READONLY, ALIGN=2

                  PWM_ClearDutyIntFlag PROC
;;;355     */
;;;356    void PWM_ClearDutyIntFlag (PWM_T *pwm, uint32_t u32ChannelNum)
000000  20ff              MOVS     r0,#0xff
;;;357    {
;;;358        PWM->INTSTS = (PWM_INTSTS_CMPDIF0_Msk << u32ChannelNum);
000002  3001              ADDS     r0,#1
000004  4088              LSLS     r0,r0,r1
000006  4901              LDR      r1,|L3.12|
000008  6188              STR      r0,[r1,#0x18]
;;;359    }
00000a  4770              BX       lr
;;;360    
                          ENDP

                  |L3.12|
                          DCD      0x40040040

                          AREA ||i.PWM_ClearFaultBrakeFlag||, CODE, READONLY, ALIGN=2

                  PWM_ClearFaultBrakeFlag PROC
;;;265     */
;;;266    void PWM_ClearFaultBrakeFlag (PWM_T *pwm, uint32_t u32BrakeSource)
000000  4901              LDR      r1,|L4.8|
;;;267    {
;;;268        PWM->BRKCTL = PWM_BRKCTL_BRKSTS_Msk;
000002  2080              MOVS     r0,#0x80
000004  6208              STR      r0,[r1,#0x20]
;;;269    }
000006  4770              BX       lr
;;;270    
                          ENDP

                  |L4.8|
                          DCD      0x40040040

                          AREA ||i.PWM_ClearFaultBrakeIntFlag||, CODE, READONLY, ALIGN=2

                  PWM_ClearFaultBrakeIntFlag PROC
;;;495     */
;;;496    void PWM_ClearFaultBrakeIntFlag (PWM_T *pwm, uint32_t u32BrakeSource)
000000  4801              LDR      r0,|L5.8|
;;;497    {
;;;498        PWM->INTSTS = u32BrakeSource;
000002  6181              STR      r1,[r0,#0x18]
;;;499    }
000004  4770              BX       lr
;;;500    
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      0x40040040

                          AREA ||i.PWM_ClearPeriodIntFlag||, CODE, READONLY, ALIGN=2

                  PWM_ClearPeriodIntFlag PROC
;;;401     */
;;;402    void PWM_ClearPeriodIntFlag (PWM_T *pwm, uint32_t u32ChannelNum)
000000  2001              MOVS     r0,#1
;;;403    {
;;;404        PWM->INTSTS = (PWM_INTSTS_ZIF0_Msk << u32ChannelNum);
000002  4088              LSLS     r0,r0,r1
000004  4901              LDR      r1,|L6.12|
000006  6188              STR      r0,[r1,#0x18]
;;;405    }
000008  4770              BX       lr
;;;406    
                          ENDP

00000a  0000              DCW      0x0000
                  |L6.12|
                          DCD      0x40040040

                          AREA ||i.PWM_ClearRiseIntFlag||, CODE, READONLY, ALIGN=2

                  PWM_ClearRiseIntFlag PROC
;;;447     */
;;;448    void PWM_ClearRiseIntFlag (PWM_T *pwm, uint32_t u32ChannelNum)
000000  2001              MOVS     r0,#1
;;;449    {
;;;450        PWM->INTSTS = (PWM_INTSTS_CMPUIF0_Msk << u32ChannelNum);
000002  0600              LSLS     r0,r0,#24
000004  4088              LSLS     r0,r0,r1
000006  4901              LDR      r1,|L7.12|
000008  6188              STR      r0,[r1,#0x18]
;;;451    }
00000a  4770              BX       lr
;;;452    
                          ENDP

                  |L7.12|
                          DCD      0x40040040

                          AREA ||i.PWM_ConfigOutputChannel||, CODE, READONLY, ALIGN=2

                  PWM_ConfigOutputChannel PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  b5ff              PUSH     {r0-r7,lr}
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  4838              LDR      r0,|L8.228|
000004  b083              SUB      sp,sp,#0xc            ;40
000006  460f              MOV      r7,r1                 ;40
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000a  4611              MOV      r1,r2
00000c  9001              STR      r0,[sp,#4]
00000e  f7fffffe          BL       __aeabi_uidivmod
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
000012  2501              MOVS     r5,#1
;;;43         uint16_t u16CNR = 0xFFFF;
000014  4c34              LDR      r4,|L8.232|
000016  26ff              MOVS     r6,#0xff              ;42
000018  9000              STR      r0,[sp,#0]
                  |L8.26|
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
00001a  4629              MOV      r1,r5
00001c  9800              LDR      r0,[sp,#0]
00001e  f7fffffe          BL       __aeabi_uidivmod
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
000022  2101              MOVS     r1,#1
000024  0609              LSLS     r1,r1,#24
000026  4288              CMP      r0,r1
000028  d812              BHI      |L8.80|
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
00002a  1901              ADDS     r1,r0,r4
00002c  0209              LSLS     r1,r1,#8
00002e  0e0e              LSRS     r6,r1,#24
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
000030  2e03              CMP      r6,#3
000032  d200              BCS      |L8.54|
;;;56                 u8Prescale = 2;
000034  2602              MOVS     r6,#2
                  |L8.54|
;;;57     
;;;58             i /= u8Prescale;
000036  4631              MOV      r1,r6
000038  f7fffffe          BL       __aeabi_uidivmod
;;;59     
;;;60             if(i <= 0x10000) {
00003c  2101              MOVS     r1,#1
00003e  0409              LSLS     r1,r1,#16
000040  4288              CMP      r0,r1
000042  d805              BHI      |L8.80|
;;;61                 if(i == 1)
000044  2801              CMP      r0,#1
000046  d001              BEQ      |L8.76|
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
000048  b284              UXTH     r4,r0
00004a  e005              B        |L8.88|
                  |L8.76|
00004c  2401              MOVS     r4,#1                 ;62
00004e  e003              B        |L8.88|
                  |L8.80|
000050  0668              LSLS     r0,r5,#25             ;45
000052  0e05              LSRS     r5,r0,#24             ;45
000054  2d11              CMP      r5,#0x11              ;45
000056  d3e0              BCC      |L8.26|
                  |L8.88|
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
000058  4631              MOV      r1,r6
00005a  4369              MULS     r1,r5,r1
00005c  4361              MULS     r1,r4,r1
00005e  9801              LDR      r0,[sp,#4]
000060  f7fffffe          BL       __aeabi_uidivmod
000064  1e76              SUBS     r6,r6,#1
;;;71     
;;;72         u8Prescale -= 1;
000066  1e64              SUBS     r4,r4,#1
000068  b2f3              UXTB     r3,r6
;;;73         u16CNR -= 1;
00006a  b2a4              UXTH     r4,r4
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
00006c  9000              STR      r0,[sp,#0]
00006e  2d01              CMP      r5,#1
000070  d02f              BEQ      |L8.210|
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
000072  2d02              CMP      r5,#2
000074  d02f              BEQ      |L8.214|
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
000076  2d04              CMP      r5,#4
000078  d02f              BEQ      |L8.218|
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
00007a  2d08              CMP      r5,#8
00007c  d02f              BEQ      |L8.222|
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
00007e  2003              MOVS     r0,#3
                  |L8.128|
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->CLKPSC = (PWM->CLKPSC & ~(PWM_CLKPSC_CLKPSC01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
000080  491a              LDR      r1,|L8.236|
000082  680d              LDR      r5,[r1,#0]
000084  087a              LSRS     r2,r7,#1
000086  00d2              LSLS     r2,r2,#3
000088  26ff              MOVS     r6,#0xff
00008a  4096              LSLS     r6,r6,r2
00008c  43b5              BICS     r5,r5,r6
00008e  4093              LSLS     r3,r3,r2
000090  431d              ORRS     r5,r5,r3
000092  600d              STR      r5,[r1,#0]
;;;88         PWM->CLKDIV = (PWM->CLKDIV & ~(PWM_CLKDIV_CLKDIV0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
000094  684b              LDR      r3,[r1,#4]
000096  00ba              LSLS     r2,r7,#2
000098  2507              MOVS     r5,#7
00009a  4095              LSLS     r5,r5,r2
00009c  43ab              BICS     r3,r3,r5
00009e  4090              LSLS     r0,r0,r2
0000a0  4303              ORRS     r3,r3,r0
0000a2  604b              STR      r3,[r1,#4]
;;;89         PWM->CTL = (PWM->CTL & ~PWM_CTL_CNTTYPE_Msk) | (PWM_CTL_CNTMODE0_Msk << ((4 * u32ChannelNum)));
0000a4  6888              LDR      r0,[r1,#8]
0000a6  2308              MOVS     r3,#8
0000a8  0040              LSLS     r0,r0,#1
0000aa  0840              LSRS     r0,r0,#1
0000ac  4093              LSLS     r3,r3,r2
0000ae  4318              ORRS     r0,r0,r3
0000b0  6088              STR      r0,[r1,#8]
;;;90     
;;;91         if(u32DutyCycle == 0)
;;;92             *((__IO uint32_t *)((((uint32_t) & ((pwm)->CMPDAT0)) + u32ChannelNum * 4))) = 0;
0000b2  9903              LDR      r1,[sp,#0xc]
0000b4  9806              LDR      r0,[sp,#0x18]         ;91
0000b6  1855              ADDS     r5,r2,r1
0000b8  2800              CMP      r0,#0                 ;91
0000ba  d005              BEQ      |L8.200|
;;;93         else
;;;94             *((__IO uint32_t *)((((uint32_t) & ((pwm)->CMPDAT0)) + u32ChannelNum * 4))) = u32DutyCycle * (u16CNR + 1) / 100 - 1;
0000bc  1c61              ADDS     r1,r4,#1
0000be  4348              MULS     r0,r1,r0
0000c0  2164              MOVS     r1,#0x64
0000c2  f7fffffe          BL       __aeabi_uidivmod
0000c6  1e40              SUBS     r0,r0,#1
                  |L8.200|
0000c8  6268              STR      r0,[r5,#0x24]
;;;95     
;;;96         *((__IO uint32_t *)((((uint32_t) & ((pwm)->PERIOD0)) + (u32ChannelNum) * 4))) = u16CNR;
0000ca  60ec              STR      r4,[r5,#0xc]
;;;97     
;;;98         return(i);
0000cc  9800              LDR      r0,[sp,#0]
;;;99     }
0000ce  b007              ADD      sp,sp,#0x1c
0000d0  bdf0              POP      {r4-r7,pc}
                  |L8.210|
0000d2  2004              MOVS     r0,#4                 ;76
0000d4  e7d4              B        |L8.128|
                  |L8.214|
0000d6  2000              MOVS     r0,#0                 ;78
0000d8  e7d2              B        |L8.128|
                  |L8.218|
0000da  2001              MOVS     r0,#1                 ;80
0000dc  e7d0              B        |L8.128|
                  |L8.222|
0000de  2002              MOVS     r0,#2                 ;82
0000e0  e7ce              B        |L8.128|
;;;100    
                          ENDP

0000e2  0000              DCW      0x0000
                  |L8.228|
                          DCD      SystemCoreClock
                  |L8.232|
                          DCD      0x0000ffff
                  |L8.236|
                          DCD      0x40040000

                          AREA ||i.PWM_DisableADCTrigger||, CODE, READONLY, ALIGN=2

                  PWM_DisableADCTrigger PROC
;;;189     */
;;;190    void PWM_DisableADCTrigger (PWM_T *pwm, uint32_t u32ChannelNum)
000000  4a07              LDR      r2,|L9.32|
;;;191    {
;;;192        if(u32ChannelNum < 4) {
;;;193            PWM->ADCTCTL0 = (PWM->ADCTCTL0 & ~((PWM_TRIGGER_ADC_CNTR_IS_0 |
000002  00c8              LSLS     r0,r1,#3
000004  230f              MOVS     r3,#0xf
000006  2904              CMP      r1,#4                 ;192
000008  d204              BCS      |L9.20|
00000a  6a91              LDR      r1,[r2,#0x28]
00000c  4083              LSLS     r3,r3,r0
00000e  4399              BICS     r1,r1,r3
000010  6291              STR      r1,[r2,#0x28]
;;;194                                                PWM_TRIGGER_ADC_CNTR_IS_CMR_D |
;;;195                                                PWM_TRIGGER_ADC_CNTR_IS_CNR |
;;;196                                                PWM_TRIGGER_ADC_CNTR_IS_CMR_U ) << (8 * u32ChannelNum)));
;;;197        } else {
;;;198            PWM->ADCTCTL1 = (PWM->ADCTCTL1 & ~((PWM_TRIGGER_ADC_CNTR_IS_0 |
;;;199                                                PWM_TRIGGER_ADC_CNTR_IS_CMR_D |
;;;200                                                PWM_TRIGGER_ADC_CNTR_IS_CNR |
;;;201                                                PWM_TRIGGER_ADC_CNTR_IS_CMR_U ) << (8 * (u32ChannelNum - 4))));
;;;202        }
;;;203    }
000012  4770              BX       lr
                  |L9.20|
000014  3820              SUBS     r0,r0,#0x20
000016  4083              LSLS     r3,r3,r0              ;198
000018  6ad0              LDR      r0,[r2,#0x2c]         ;198
00001a  4398              BICS     r0,r0,r3              ;198
00001c  62d0              STR      r0,[r2,#0x2c]         ;198
00001e  4770              BX       lr
;;;204    
                          ENDP

                  |L9.32|
                          DCD      0x40040040

                          AREA ||i.PWM_DisableCenterInt||, CODE, READONLY, ALIGN=2

                  PWM_DisableCenterInt PROC
;;;536     */
;;;537    void PWM_DisableCenterInt (PWM_T *pwm, uint32_t u32ChannelNum)
000000  4803              LDR      r0,|L10.16|
;;;538    {
;;;539        PWM->INTEN &= ~(PWM_INTEN_PIEN0_Msk << u32ChannelNum);
000002  6942              LDR      r2,[r0,#0x14]
000004  2301              MOVS     r3,#1
000006  049b              LSLS     r3,r3,#18
000008  408b              LSLS     r3,r3,r1
00000a  439a              BICS     r2,r2,r3
00000c  6142              STR      r2,[r0,#0x14]
;;;540    }
00000e  4770              BX       lr
;;;541    
                          ENDP

                  |L10.16|
                          DCD      0x40040040

                          AREA ||i.PWM_DisableDeadZone||, CODE, READONLY, ALIGN=2

                  PWM_DisableDeadZone PROC
;;;318     */
;;;319    void PWM_DisableDeadZone (PWM_T *pwm, uint32_t u32ChannelNum)
000000  0848              LSRS     r0,r1,#1
;;;320    {
;;;321        // every two channels shares the same setting
;;;322        u32ChannelNum >>= 1;
;;;323        // enable dead zone
;;;324        PWM->CTL &= ~(PWM_CTL_DTCNT01_Msk << u32ChannelNum);
000002  4903              LDR      r1,|L11.16|
000004  688a              LDR      r2,[r1,#8]
000006  018b              LSLS     r3,r1,#6
000008  4083              LSLS     r3,r3,r0
00000a  439a              BICS     r2,r2,r3
00000c  608a              STR      r2,[r1,#8]
;;;325    }
00000e  4770              BX       lr
;;;326    
                          ENDP

                  |L11.16|
                          DCD      0x40040000

                          AREA ||i.PWM_DisableDutyInt||, CODE, READONLY, ALIGN=1

                  PWM_DisableDutyInt PROC
;;;344     */
;;;345    void PWM_DisableDutyInt (PWM_T *pwm, uint32_t u32ChannelNum)
000000  6d42              LDR      r2,[r0,#0x54]
;;;346    {
;;;347        (pwm)->INTEN &= ~((1 << PWM_INTEN_CMPDIEN0_Pos) << u32ChannelNum);
000002  23ff              MOVS     r3,#0xff
000004  3301              ADDS     r3,#1
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3
00000a  6542              STR      r2,[r0,#0x54]
;;;348    }
00000c  4770              BX       lr
;;;349    
                          ENDP


                          AREA ||i.PWM_DisableFaultBrakeInt||, CODE, READONLY, ALIGN=2

                  PWM_DisableFaultBrakeInt PROC
;;;482     */
;;;483    void PWM_DisableFaultBrakeInt (PWM_T *pwm, uint32_t u32BrakeSource)
000000  4803              LDR      r0,|L13.16|
;;;484    {
;;;485        PWM->INTEN &= ~PWM_INTEN_BRKIEN_Msk;
000002  6941              LDR      r1,[r0,#0x14]
000004  2201              MOVS     r2,#1
000006  0412              LSLS     r2,r2,#16
000008  4391              BICS     r1,r1,r2
00000a  6141              STR      r1,[r0,#0x14]
;;;486    }
00000c  4770              BX       lr
;;;487    
                          ENDP

00000e  0000              DCW      0x0000
                  |L13.16|
                          DCD      0x40040040

                          AREA ||i.PWM_DisableOutput||, CODE, READONLY, ALIGN=2

                  PWM_DisableOutput PROC
;;;289     */
;;;290    void PWM_DisableOutput (PWM_T *pwm, uint32_t u32ChannelMask)
000000  4802              LDR      r0,|L14.12|
;;;291    {
;;;292        PWM->POEN &= ~u32ChannelMask;
000002  69c2              LDR      r2,[r0,#0x1c]
000004  438a              BICS     r2,r2,r1
000006  61c2              STR      r2,[r0,#0x1c]
;;;293    }
000008  4770              BX       lr
;;;294    
                          ENDP

00000a  0000              DCW      0x0000
                  |L14.12|
                          DCD      0x40040040

                          AREA ||i.PWM_DisablePeriodInt||, CODE, READONLY, ALIGN=1

                  PWM_DisablePeriodInt PROC
;;;390     */
;;;391    void PWM_DisablePeriodInt (PWM_T *pwm, uint32_t u32ChannelNum)
000000  6d42              LDR      r2,[r0,#0x54]
;;;392    {
;;;393        (pwm)->INTEN &= ~((1 << PWM_INTEN_ZIEN0_Pos) << u32ChannelNum);
000002  2301              MOVS     r3,#1
000004  408b              LSLS     r3,r3,r1
000006  439a              BICS     r2,r2,r3
000008  6542              STR      r2,[r0,#0x54]
;;;394    }
00000a  4770              BX       lr
;;;395    
                          ENDP


                          AREA ||i.PWM_DisableRiseInt||, CODE, READONLY, ALIGN=1

                  PWM_DisableRiseInt PROC
;;;436     */
;;;437    void PWM_DisableRiseInt (PWM_T *pwm, uint32_t u32ChannelNum)
000000  6d42              LDR      r2,[r0,#0x54]
;;;438    {
;;;439        (pwm)->INTEN &= ~((1 << PWM_INTEN_CMPUIEN0_Pos) << u32ChannelNum);
000002  2301              MOVS     r3,#1
000004  061b              LSLS     r3,r3,#24
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3
00000a  6542              STR      r2,[r0,#0x54]
;;;440    }
00000c  4770              BX       lr
;;;441    
                          ENDP


                          AREA ||i.PWM_EnableADCTrigger||, CODE, READONLY, ALIGN=2

                  PWM_EnableADCTrigger PROC
;;;168     */
;;;169    void PWM_EnableADCTrigger (PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000000  b510              PUSH     {r4,lr}
;;;170    {
;;;171        if(u32ChannelNum < 4) {
;;;172            PWM->ADCTCTL0 = (PWM->ADCTCTL0 & ~((PWM_TRIGGER_ADC_CNTR_IS_0 |
000002  4c0a              LDR      r4,|L17.44|
000004  230f              MOVS     r3,#0xf
000006  00c8              LSLS     r0,r1,#3
000008  2904              CMP      r1,#4                 ;171
00000a  d206              BCS      |L17.26|
00000c  6aa1              LDR      r1,[r4,#0x28]
00000e  4083              LSLS     r3,r3,r0
000010  4399              BICS     r1,r1,r3
000012  4082              LSLS     r2,r2,r0
000014  4311              ORRS     r1,r1,r2
000016  62a1              STR      r1,[r4,#0x28]
;;;173                                                PWM_TRIGGER_ADC_CNTR_IS_CMR_D |
;;;174                                                PWM_TRIGGER_ADC_CNTR_IS_CNR |
;;;175                                                PWM_TRIGGER_ADC_CNTR_IS_CMR_U ) << (8 * u32ChannelNum))) | (u32Condition << (8 * u32ChannelNum));
;;;176        } else {
;;;177            PWM->ADCTCTL1 = (PWM->ADCTCTL1 & ~((PWM_TRIGGER_ADC_CNTR_IS_0 |
;;;178                                                PWM_TRIGGER_ADC_CNTR_IS_CMR_D |
;;;179                                                PWM_TRIGGER_ADC_CNTR_IS_CNR |
;;;180                                                PWM_TRIGGER_ADC_CNTR_IS_CMR_U ) << (8 * (u32ChannelNum - 4)))) | (u32Condition << (8 * (u32ChannelNum - 4)));
;;;181        }
;;;182    }
000018  bd10              POP      {r4,pc}
                  |L17.26|
00001a  3820              SUBS     r0,r0,#0x20
00001c  6ae1              LDR      r1,[r4,#0x2c]         ;177
00001e  4083              LSLS     r3,r3,r0              ;177
000020  4399              BICS     r1,r1,r3              ;177
000022  4082              LSLS     r2,r2,r0              ;177
000024  4311              ORRS     r1,r1,r2              ;177
000026  62e1              STR      r1,[r4,#0x2c]         ;177
000028  bd10              POP      {r4,pc}
;;;183    
                          ENDP

00002a  0000              DCW      0x0000
                  |L17.44|
                          DCD      0x40040040

                          AREA ||i.PWM_EnableCenterInt||, CODE, READONLY, ALIGN=2

                  PWM_EnableCenterInt PROC
;;;525     */
;;;526    void PWM_EnableCenterInt (PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType)
000000  b510              PUSH     {r4,lr}
;;;527    {
;;;528        PWM->INTEN = (PWM->INTEN & ~PWM_INTEN_PINTTYPE_Msk & ~(PWM_INTEN_PIEN0_Msk << u32ChannelNum)) | (PWM_INTEN_PIEN0_Msk << u32ChannelNum) | u32IntPeriodType;
000002  4c06              LDR      r4,|L18.28|
000004  6963              LDR      r3,[r4,#0x14]
000006  2001              MOVS     r0,#1
000008  0480              LSLS     r0,r0,#18
00000a  4088              LSLS     r0,r0,r1
00000c  4904              LDR      r1,|L18.32|
00000e  4381              BICS     r1,r1,r0
000010  400b              ANDS     r3,r3,r1
000012  4303              ORRS     r3,r3,r0
000014  4313              ORRS     r3,r3,r2
000016  6163              STR      r3,[r4,#0x14]
;;;529    }
000018  bd10              POP      {r4,pc}
;;;530    
                          ENDP

00001a  0000              DCW      0x0000
                  |L18.28|
                          DCD      0x40040040
                  |L18.32|
                          DCD      0xfffdffff

                          AREA ||i.PWM_EnableDeadZone||, CODE, READONLY, ALIGN=2

                  PWM_EnableDeadZone PROC
;;;302     */
;;;303    void PWM_EnableDeadZone (PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration)
000000  b530              PUSH     {r4,r5,lr}
;;;304    {
;;;305        // every two channels shares the same setting
;;;306        u32ChannelNum >>= 1;
;;;307        // set duration
;;;308        PWM->DTCTL = (PWM->DTCTL & ~(PWM_DTCTL_DTI01_Msk << (8 * u32ChannelNum))) | (u32Duration << (8 * u32ChannelNum));
000002  4c08              LDR      r4,|L19.36|
000004  0848              LSRS     r0,r1,#1              ;306
000006  6a63              LDR      r3,[r4,#0x24]
000008  00c1              LSLS     r1,r0,#3
00000a  25ff              MOVS     r5,#0xff
00000c  408d              LSLS     r5,r5,r1
00000e  43ab              BICS     r3,r3,r5
000010  408a              LSLS     r2,r2,r1
000012  4313              ORRS     r3,r3,r2
000014  6263              STR      r3,[r4,#0x24]
;;;309        // enable dead zone
;;;310        PWM->CTL |= (PWM_CTL_DTCNT01_Msk << u32ChannelNum);
000016  0323              LSLS     r3,r4,#12
000018  689a              LDR      r2,[r3,#8]
00001a  0199              LSLS     r1,r3,#6
00001c  4081              LSLS     r1,r1,r0
00001e  430a              ORRS     r2,r2,r1
000020  609a              STR      r2,[r3,#8]
;;;311    }
000022  bd30              POP      {r4,r5,pc}
;;;312    
                          ENDP

                  |L19.36|
                          DCD      0x40040040

                          AREA ||i.PWM_EnableDutyInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableDutyInt PROC
;;;333     */
;;;334    void PWM_EnableDutyInt (PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType)
000000  6d42              LDR      r2,[r0,#0x54]
;;;335    {
;;;336        (pwm)->INTEN |= ((1 << PWM_INTEN_CMPDIEN0_Pos) << u32ChannelNum);
000002  23ff              MOVS     r3,#0xff
000004  3301              ADDS     r3,#1
000006  408b              LSLS     r3,r3,r1
000008  431a              ORRS     r2,r2,r3
00000a  6542              STR      r2,[r0,#0x54]
;;;337    }
00000c  4770              BX       lr
;;;338    
                          ENDP


                          AREA ||i.PWM_EnableFaultBrake||, CODE, READONLY, ALIGN=2

                  PWM_EnableFaultBrake PROC
;;;250     */
;;;251    void PWM_EnableFaultBrake (PWM_T *pwm,
000000  0610              LSLS     r0,r2,#24
;;;252                               uint32_t u32ChannelMask,
;;;253                               uint32_t u32LevelMask,
;;;254                               uint32_t u32BrakeSource)
;;;255    {
;;;256        PWM->BRKCTL = (u32LevelMask << PWM_BRKCTL_BKOD0_Pos) | u32BrakeSource;
000002  4902              LDR      r1,|L21.12|
000004  4318              ORRS     r0,r0,r3
000006  6208              STR      r0,[r1,#0x20]
;;;257    }
000008  4770              BX       lr
;;;258    
                          ENDP

00000a  0000              DCW      0x0000
                  |L21.12|
                          DCD      0x40040040

                          AREA ||i.PWM_EnableFaultBrakeInt||, CODE, READONLY, ALIGN=2

                  PWM_EnableFaultBrakeInt PROC
;;;471     */
;;;472    void PWM_EnableFaultBrakeInt (PWM_T *pwm, uint32_t u32BrakeSource)
000000  4803              LDR      r0,|L22.16|
;;;473    {
;;;474        PWM->INTEN |= PWM_INTEN_BRKIEN_Msk;
000002  6941              LDR      r1,[r0,#0x14]
000004  2201              MOVS     r2,#1
000006  0412              LSLS     r2,r2,#16
000008  4311              ORRS     r1,r1,r2
00000a  6141              STR      r1,[r0,#0x14]
;;;475    }
00000c  4770              BX       lr
;;;476    
                          ENDP

00000e  0000              DCW      0x0000
                  |L22.16|
                          DCD      0x40040040

                          AREA ||i.PWM_EnableOutput||, CODE, READONLY, ALIGN=2

                  PWM_EnableOutput PROC
;;;277     */
;;;278    void PWM_EnableOutput (PWM_T *pwm, uint32_t u32ChannelMask)
000000  4802              LDR      r0,|L23.12|
;;;279    {
;;;280        PWM->POEN |= u32ChannelMask;
000002  69c2              LDR      r2,[r0,#0x1c]
000004  430a              ORRS     r2,r2,r1
000006  61c2              STR      r2,[r0,#0x1c]
;;;281    }
000008  4770              BX       lr
;;;282    
                          ENDP

00000a  0000              DCW      0x0000
                  |L23.12|
                          DCD      0x40040040

                          AREA ||i.PWM_EnablePeriodInt||, CODE, READONLY, ALIGN=1

                  PWM_EnablePeriodInt PROC
;;;379     */
;;;380    void PWM_EnablePeriodInt (PWM_T *pwm, uint32_t u32ChannelNum)
000000  6d42              LDR      r2,[r0,#0x54]
;;;381    {
;;;382        (pwm)->INTEN |= ((1 << PWM_INTEN_ZIEN0_Pos) << u32ChannelNum);
000002  2301              MOVS     r3,#1
000004  408b              LSLS     r3,r3,r1
000006  431a              ORRS     r2,r2,r3
000008  6542              STR      r2,[r0,#0x54]
;;;383    }
00000a  4770              BX       lr
;;;384    
                          ENDP


                          AREA ||i.PWM_EnableRiseInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableRiseInt PROC
;;;425     */
;;;426    void PWM_EnableRiseInt (PWM_T *pwm, uint32_t u32ChannelNum)
000000  6d42              LDR      r2,[r0,#0x54]
;;;427    {
;;;428        (pwm)->INTEN |= ((1 << PWM_INTEN_CMPUIEN0_Pos) << u32ChannelNum);
000002  2301              MOVS     r3,#1
000004  061b              LSLS     r3,r3,#24
000006  408b              LSLS     r3,r3,r1
000008  431a              ORRS     r2,r2,r3
00000a  6542              STR      r2,[r0,#0x54]
;;;429    }
00000c  4770              BX       lr
;;;430    
                          ENDP


                          AREA ||i.PWM_ForceStop||, CODE, READONLY, ALIGN=2

                  PWM_ForceStop PROC
;;;145     */
;;;146    void PWM_ForceStop (PWM_T *pwm, uint32_t u32ChannelMask)
000000  b530              PUSH     {r4,r5,lr}
;;;147    {
;;;148        uint32_t u32Mask = 0, i;
000002  2200              MOVS     r2,#0
;;;149        for(i = 0; i < PWM_CHANNEL_NUM; i ++) {
000004  4610              MOV      r0,r2
;;;150            if(u32ChannelMask & (1 << i)) {
000006  2401              MOVS     r4,#1
                  |L26.8|
000008  4623              MOV      r3,r4
00000a  4083              LSLS     r3,r3,r0
00000c  420b              TST      r3,r1
00000e  d003              BEQ      |L26.24|
;;;151                u32Mask |= (PWM_CTL_CNTEN0_Msk << (i * 4));
000010  0085              LSLS     r5,r0,#2
000012  4623              MOV      r3,r4
000014  40ab              LSLS     r3,r3,r5
000016  431a              ORRS     r2,r2,r3
                  |L26.24|
000018  1c40              ADDS     r0,r0,#1
00001a  2806              CMP      r0,#6                 ;149
00001c  d3f4              BCC      |L26.8|
;;;152            }
;;;153        }
;;;154    
;;;155        PWM->CTL &= ~u32Mask;
00001e  4902              LDR      r1,|L26.40|
000020  6888              LDR      r0,[r1,#8]
000022  4390              BICS     r0,r0,r2
000024  6088              STR      r0,[r1,#8]
;;;156    }
000026  bd30              POP      {r4,r5,pc}
;;;157    
                          ENDP

                  |L26.40|
                          DCD      0x40040000

                          AREA ||i.PWM_GetADCTriggerFlag||, CODE, READONLY, ALIGN=2

                  PWM_GetADCTriggerFlag PROC
;;;227     */
;;;228    uint32_t PWM_GetADCTriggerFlag (PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000000  4b08              LDR      r3,|L27.36|
;;;229    {
;;;230        if(u32ChannelNum < 4) {
;;;231            return(PWM->ADCTSTS0 & (u32Condition << (8 * u32ChannelNum)) ? 1 : 0);
000002  00c8              LSLS     r0,r1,#3
000004  2904              CMP      r1,#4                 ;230
000006  d204              BCS      |L27.18|
000008  6b19              LDR      r1,[r3,#0x30]
00000a  4082              LSLS     r2,r2,r0
00000c  4211              TST      r1,r2
00000e  d105              BNE      |L27.28|
000010  e006              B        |L27.32|
                  |L27.18|
000012  3820              SUBS     r0,r0,#0x20
;;;232        } else {
;;;233            return(PWM->ADCTSTS1 & (u32Condition << (8 * (u32ChannelNum - 4))) ? 1 : 0);
000014  4082              LSLS     r2,r2,r0
000016  6b58              LDR      r0,[r3,#0x34]
000018  4202              TST      r2,r0
00001a  d001              BEQ      |L27.32|
                  |L27.28|
00001c  2001              MOVS     r0,#1
;;;234        }
;;;235    }
00001e  4770              BX       lr
                  |L27.32|
000020  2000              MOVS     r0,#0                 ;233
000022  4770              BX       lr
;;;236    
                          ENDP

                  |L27.36|
                          DCD      0x40040040

                          AREA ||i.PWM_GetCenterIntFlag||, CODE, READONLY, ALIGN=2

                  PWM_GetCenterIntFlag PROC
;;;560     */
;;;561    uint32_t PWM_GetCenterIntFlag (PWM_T *pwm, uint32_t u32ChannelNum)
000000  4804              LDR      r0,|L28.20|
;;;562    {
;;;563        return(PWM->INTSTS & (PWM_INTSTS_PIF0_Msk << u32ChannelNum) ? 1 : 0);
000002  6980              LDR      r0,[r0,#0x18]
000004  2201              MOVS     r2,#1
000006  0492              LSLS     r2,r2,#18
000008  408a              LSLS     r2,r2,r1
00000a  4010              ANDS     r0,r0,r2
00000c  d000              BEQ      |L28.16|
00000e  2001              MOVS     r0,#1
                  |L28.16|
;;;564    }
000010  4770              BX       lr
;;;565    
                          ENDP

000012  0000              DCW      0x0000
                  |L28.20|
                          DCD      0x40040040

                          AREA ||i.PWM_GetDutyIntFlag||, CODE, READONLY, ALIGN=2

                  PWM_GetDutyIntFlag PROC
;;;368     */
;;;369    uint32_t PWM_GetDutyIntFlag (PWM_T *pwm, uint32_t u32ChannelNum)
000000  4804              LDR      r0,|L29.20|
;;;370    {
;;;371        return(PWM->INTSTS & (PWM_INTSTS_CMPDIF0_Msk << u32ChannelNum) ? 1 : 0);
000002  6980              LDR      r0,[r0,#0x18]
000004  22ff              MOVS     r2,#0xff
000006  3201              ADDS     r2,#1
000008  408a              LSLS     r2,r2,r1
00000a  4010              ANDS     r0,r0,r2
00000c  d000              BEQ      |L29.16|
00000e  2001              MOVS     r0,#1
                  |L29.16|
;;;372    }
000010  4770              BX       lr
;;;373    
                          ENDP

000012  0000              DCW      0x0000
                  |L29.20|
                          DCD      0x40040040

                          AREA ||i.PWM_GetFaultBrakeIntFlag||, CODE, READONLY, ALIGN=2

                  PWM_GetFaultBrakeIntFlag PROC
;;;510     */
;;;511    uint32_t PWM_GetFaultBrakeIntFlag (PWM_T *pwm, uint32_t u32BrakeSource)
000000  4802              LDR      r0,|L30.12|
;;;512    {
;;;513        return (PWM->INTSTS & u32BrakeSource ? 1 : 0);
000002  6980              LDR      r0,[r0,#0x18]
000004  4008              ANDS     r0,r0,r1
000006  d000              BEQ      |L30.10|
000008  2001              MOVS     r0,#1
                  |L30.10|
;;;514    }
00000a  4770              BX       lr
;;;515    
                          ENDP

                  |L30.12|
                          DCD      0x40040040

                          AREA ||i.PWM_GetPeriodIntFlag||, CODE, READONLY, ALIGN=2

                  PWM_GetPeriodIntFlag PROC
;;;414     */
;;;415    uint32_t PWM_GetPeriodIntFlag (PWM_T *pwm, uint32_t u32ChannelNum)
000000  4803              LDR      r0,|L31.16|
;;;416    {
;;;417        return(PWM->INTSTS & (PWM_INTSTS_ZIF0_Msk << u32ChannelNum) ? 1 : 0);
000002  6980              LDR      r0,[r0,#0x18]
000004  2201              MOVS     r2,#1
000006  408a              LSLS     r2,r2,r1
000008  4010              ANDS     r0,r0,r2
00000a  d000              BEQ      |L31.14|
00000c  2001              MOVS     r0,#1
                  |L31.14|
;;;418    }
00000e  4770              BX       lr
;;;419    
                          ENDP

                  |L31.16|
                          DCD      0x40040040

                          AREA ||i.PWM_GetRiseIntFlag||, CODE, READONLY, ALIGN=2

                  PWM_GetRiseIntFlag PROC
;;;460     */
;;;461    uint32_t PWM_GetRiseIntFlag (PWM_T *pwm, uint32_t u32ChannelNum)
000000  4804              LDR      r0,|L32.20|
;;;462    {
;;;463        return(PWM->INTSTS & (PWM_INTSTS_CMPUIF0_Msk << u32ChannelNum) ? 1 : 0);
000002  6980              LDR      r0,[r0,#0x18]
000004  2201              MOVS     r2,#1
000006  0612              LSLS     r2,r2,#24
000008  408a              LSLS     r2,r2,r1
00000a  4010              ANDS     r0,r0,r2
00000c  d000              BEQ      |L32.16|
00000e  2001              MOVS     r0,#1
                  |L32.16|
;;;464    }
000010  4770              BX       lr
;;;465    
                          ENDP

000012  0000              DCW      0x0000
                  |L32.20|
                          DCD      0x40040040

                          AREA ||i.PWM_Start||, CODE, READONLY, ALIGN=2

                  PWM_Start PROC
;;;108     */
;;;109    void PWM_Start (PWM_T *pwm, uint32_t u32ChannelMask)
000000  b530              PUSH     {r4,r5,lr}
;;;110    {
;;;111        uint32_t u32Mask = 0, i;
000002  2200              MOVS     r2,#0
;;;112        for(i = 0; i < PWM_CHANNEL_NUM; i ++) {
000004  4610              MOV      r0,r2
;;;113            if(u32ChannelMask & (1 << i)) {
000006  2401              MOVS     r4,#1
                  |L33.8|
000008  4623              MOV      r3,r4
00000a  4083              LSLS     r3,r3,r0
00000c  420b              TST      r3,r1
00000e  d003              BEQ      |L33.24|
;;;114                u32Mask |= (PWM_CTL_CNTEN0_Msk << (i * 4));
000010  0085              LSLS     r5,r0,#2
000012  4623              MOV      r3,r4
000014  40ab              LSLS     r3,r3,r5
000016  431a              ORRS     r2,r2,r3
                  |L33.24|
000018  1c40              ADDS     r0,r0,#1
00001a  2806              CMP      r0,#6                 ;112
00001c  d3f4              BCC      |L33.8|
;;;115            }
;;;116        }
;;;117    
;;;118        PWM->CTL |= u32Mask;
00001e  4902              LDR      r1,|L33.40|
000020  6888              LDR      r0,[r1,#8]
000022  4310              ORRS     r0,r0,r2
000024  6088              STR      r0,[r1,#8]
;;;119    }
000026  bd30              POP      {r4,r5,pc}
;;;120    
                          ENDP

                  |L33.40|
                          DCD      0x40040000

                          AREA ||i.PWM_Stop||, CODE, READONLY, ALIGN=1

                  PWM_Stop PROC
;;;127     */
;;;128    void PWM_Stop (PWM_T *pwm, uint32_t u32ChannelMask)
000000  b530              PUSH     {r4,r5,lr}
;;;129    {
;;;130        uint32_t i;
;;;131        for(i = 0; i < PWM_CHANNEL_NUM; i ++) {
000002  2200              MOVS     r2,#0
;;;132            if(u32ChannelMask & (1 << i)) {
000004  2501              MOVS     r5,#1
000006  4614              MOV      r4,r2
                  |L34.8|
000008  462b              MOV      r3,r5
00000a  4093              LSLS     r3,r3,r2
00000c  420b              TST      r3,r1
00000e  d002              BEQ      |L34.22|
;;;133                *((__IO uint32_t *)((((uint32_t) & ((pwm)->PERIOD0)) + (i) * 4))) = 0;
000010  0093              LSLS     r3,r2,#2
000012  181b              ADDS     r3,r3,r0
000014  60dc              STR      r4,[r3,#0xc]
                  |L34.22|
000016  1c52              ADDS     r2,r2,#1
000018  2a06              CMP      r2,#6                 ;131
00001a  d3f5              BCC      |L34.8|
;;;134            }
;;;135        }
;;;136    
;;;137    }
00001c  bd30              POP      {r4,r5,pc}
;;;138    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Library\\StdDriver\\src\\pwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_03ee09af____REV16|
#line 388 "..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_pwm_c_03ee09af____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_03ee09af____REVSH|
#line 402
|__asm___5_pwm_c_03ee09af____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
