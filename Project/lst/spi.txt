; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\spi.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\spi.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\Library\StdDriver\inc -I..\Library\CMSIS\Include -I..\Library\Device\Nuvoton\Mini58Series\Include -I..\Bsp -I..\Bsp\inc -I..\utils\inc -I..\App\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=520 --omf_browse=.\obj\spi.crf ..\Library\StdDriver\src\spi.c]
                          THUMB

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;195      */
;;;196    __STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;197    {
;;;198        uint32_t u32PllFreq = 0, u32PllReg;
;;;199        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;200        uint8_t au8NoTbl[4] = {1, 2, 2, 4};
000002  a011              ADR      r0,|L1.72|
000004  6800              LDR      r0,[r0,#0]
;;;201    
;;;202        u32PllReg = CLK->PLLCTL;
000006  9000              STR      r0,[sp,#0]
000008  4810              LDR      r0,|L1.76|
00000a  6a01              LDR      r1,[r0,#0x20]
;;;203    
;;;204        if(u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
00000c  1300              ASRS     r0,r0,#12
00000e  4201              TST      r1,r0
000010  d001              BEQ      |L1.22|
;;;205            return 0;           /* PLL is in power down mode or fix low */
000012  2000              MOVS     r0,#0
                  |L1.20|
;;;206    
;;;207        if(u32PllReg & CLK_PLLCTL_PLLSRC_HIRC)
;;;208            u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;209        else
;;;210            u32FIN = __XTAL;     /* PLL source clock from HXT */
;;;211    
;;;212        if(u32PllReg & CLK_PLLCTL_BP_Msk)
;;;213            return u32FIN;      /* PLL is in bypass mode */
;;;214    
;;;215        /* PLL is output enabled in normal work mode */
;;;216        u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
;;;217        u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
;;;218        u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
;;;219    
;;;220        /* u32FIN is shifted 2 bits to avoid overflow */
;;;221        u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
;;;222    
;;;223        return u32PllFreq;
;;;224    }
000014  bd08              POP      {r3,pc}
                  |L1.22|
000016  0308              LSLS     r0,r1,#12             ;207
000018  d501              BPL      |L1.30|
00001a  480d              LDR      r0,|L1.80|
00001c  e000              B        |L1.32|
                  |L1.30|
00001e  480d              LDR      r0,|L1.84|
                  |L1.32|
000020  038a              LSLS     r2,r1,#14             ;212
000022  d4f7              BMI      |L1.20|
000024  040a              LSLS     r2,r1,#16             ;216
000026  0f92              LSRS     r2,r2,#30             ;216
000028  466b              MOV      r3,sp                 ;216
00002a  5c9b              LDRB     r3,[r3,r2]            ;216
00002c  05ca              LSLS     r2,r1,#23             ;217
00002e  0489              LSLS     r1,r1,#18             ;218
000030  0dd2              LSRS     r2,r2,#23             ;217
000032  0ec9              LSRS     r1,r1,#27             ;218
000034  1c89              ADDS     r1,r1,#2              ;218
000036  0880              LSRS     r0,r0,#2              ;221
000038  1c92              ADDS     r2,r2,#2              ;221
00003a  4359              MULS     r1,r3,r1              ;221
00003c  4350              MULS     r0,r2,r0              ;221
00003e  f7fffffe          BL       __aeabi_uidivmod
000042  0080              LSLS     r0,r0,#2              ;221
000044  bd08              POP      {r3,pc}
;;;225    
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
000048  01020204          DCB      1,2,2,4
                  |L1.76|
                          DCD      0x50000200
                  |L1.80|
                          DCD      0x01518000
                  |L1.84|
                          DCD      0x00b71b00

                          AREA ||i.SPI_ClearRxFIFO||, CODE, READONLY, ALIGN=1

                  SPI_ClearRxFIFO PROC
;;;71       */
;;;72     void SPI_ClearRxFIFO(SPI_T *spi)
000000  6c01              LDR      r1,[r0,#0x40]
;;;73     {
;;;74         spi->FIFOCTL |= SPI_FIFOCTL_RXRST_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  6401              STR      r1,[r0,#0x40]
;;;75     }
000008  4770              BX       lr
;;;76     
                          ENDP


                          AREA ||i.SPI_ClearTxFIFO||, CODE, READONLY, ALIGN=1

                  SPI_ClearTxFIFO PROC
;;;81       */
;;;82     void SPI_ClearTxFIFO(SPI_T *spi)
000000  6c01              LDR      r1,[r0,#0x40]
;;;83     {
;;;84         spi->FIFOCTL |= SPI_FIFOCTL_TXRST_Msk;
000002  2202              MOVS     r2,#2
000004  4311              ORRS     r1,r1,r2
000006  6401              STR      r1,[r0,#0x40]
;;;85     }
000008  4770              BX       lr
;;;86     
                          ENDP


                          AREA ||i.SPI_Close||, CODE, READONLY, ALIGN=1

                  SPI_Close PROC
;;;59       */
;;;60     void SPI_Close(SPI_T *spi)
000000  2005              MOVS     r0,#5
;;;61     {
;;;62         /* Reset SPI */
;;;63         SYS->IPRST1 |= SYS_IPRST1_SPI0RST_Msk;
000002  0700              LSLS     r0,r0,#28
000004  68c2              LDR      r2,[r0,#0xc]
000006  2101              MOVS     r1,#1
000008  0309              LSLS     r1,r1,#12
00000a  430a              ORRS     r2,r2,r1
00000c  60c2              STR      r2,[r0,#0xc]
;;;64         SYS->IPRST1 &= ~SYS_IPRST1_SPI0RST_Msk;
00000e  68c2              LDR      r2,[r0,#0xc]
000010  438a              BICS     r2,r2,r1
000012  60c2              STR      r2,[r0,#0xc]
;;;65     }
000014  4770              BX       lr
;;;66     
                          ENDP


                          AREA ||i.SPI_DisableAutoSS||, CODE, READONLY, ALIGN=1

                  SPI_DisableAutoSS PROC
;;;91       */
;;;92     void SPI_DisableAutoSS(SPI_T *spi)
000000  6881              LDR      r1,[r0,#8]
;;;93     {
;;;94         spi->SSCTL &= ~SPI_SSCTL_AUTOSS_Msk;
000002  2208              MOVS     r2,#8
000004  4391              BICS     r1,r1,r2
000006  6081              STR      r1,[r0,#8]
;;;95     }
000008  4770              BX       lr
;;;96     
                          ENDP


                          AREA ||i.SPI_DisableFIFO||, CODE, READONLY, ALIGN=1

                  SPI_DisableFIFO PROC
;;;163      */
;;;164    void SPI_DisableFIFO(SPI_T *spi)
000000  6801              LDR      r1,[r0,#0]
;;;165    {
;;;166        spi->CTL &= ~SPI_CTL_FIFOEN_Msk;
000002  2201              MOVS     r2,#1
000004  0552              LSLS     r2,r2,#21
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;167    }
00000a  4770              BX       lr
;;;168    
                          ENDP


                          AREA ||i.SPI_DisableInt||, CODE, READONLY, ALIGN=1

                  SPI_DisableInt PROC
;;;232      */
;;;233    void SPI_DisableInt(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;234    {
000002  d004              BEQ      |L7.14|
;;;235        if((u32Mask & SPI_IE_MASK) == SPI_IE_MASK)
;;;236            spi->CTL &= ~SPI_CTL_UNITIEN_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  045b              LSLS     r3,r3,#17
00000a  439a              BICS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
                  |L7.14|
;;;237    
;;;238        if((u32Mask & SPI_SSTA_INTEN_MASK) == SPI_SSTA_INTEN_MASK)
00000e  074a              LSLS     r2,r1,#29
000010  d504              BPL      |L7.28|
;;;239            spi->SLVCTL &= ~SPI_SLVCTL_SLVSTIEN_Msk;
000012  6bc2              LDR      r2,[r0,#0x3c]
000014  2301              MOVS     r3,#1
000016  029b              LSLS     r3,r3,#10
000018  439a              BICS     r2,r2,r3
00001a  63c2              STR      r2,[r0,#0x3c]
                  |L7.28|
;;;240    
;;;241        if((u32Mask & SPI_FIFO_TX_INTEN_MASK) == SPI_FIFO_TX_INTEN_MASK)
00001c  070a              LSLS     r2,r1,#28
00001e  d503              BPL      |L7.40|
;;;242            spi->FIFOCTL &= ~SPI_FIFOCTL_TXTHIEN_Msk;
000020  6c02              LDR      r2,[r0,#0x40]
000022  2308              MOVS     r3,#8
000024  439a              BICS     r2,r2,r3
000026  6402              STR      r2,[r0,#0x40]
                  |L7.40|
;;;243    
;;;244        if((u32Mask & SPI_FIFO_RX_INTEN_MASK) == SPI_FIFO_RX_INTEN_MASK)
000028  06ca              LSLS     r2,r1,#27
00002a  d503              BPL      |L7.52|
;;;245            spi->FIFOCTL &= ~SPI_FIFOCTL_RXTHIEN_Msk;
00002c  6c02              LDR      r2,[r0,#0x40]
00002e  2304              MOVS     r3,#4
000030  439a              BICS     r2,r2,r3
000032  6402              STR      r2,[r0,#0x40]
                  |L7.52|
;;;246    
;;;247        if((u32Mask & SPI_FIFO_RXOV_INTEN_MASK) == SPI_FIFO_RXOV_INTEN_MASK)
000034  068a              LSLS     r2,r1,#26
000036  d503              BPL      |L7.64|
;;;248            spi->FIFOCTL &= ~SPI_FIFOCTL_RXOVIEN_Msk;
000038  6c02              LDR      r2,[r0,#0x40]
00003a  2340              MOVS     r3,#0x40
00003c  439a              BICS     r2,r2,r3
00003e  6402              STR      r2,[r0,#0x40]
                  |L7.64|
;;;249    
;;;250        if((u32Mask & SPI_FIFO_TIMEOUT_INTEN_MASK) == SPI_FIFO_TIMEOUT_INTEN_MASK)
000040  0649              LSLS     r1,r1,#25
000042  d504              BPL      |L7.78|
;;;251            spi->FIFOCTL &= ~SPI_FIFOCTL_RXTOIEN_Msk;
000044  6c01              LDR      r1,[r0,#0x40]
000046  2201              MOVS     r2,#1
000048  0552              LSLS     r2,r2,#21
00004a  4391              BICS     r1,r1,r2
00004c  6401              STR      r1,[r0,#0x40]
                  |L7.78|
;;;252    }
00004e  4770              BX       lr
;;;253    
                          ENDP


                          AREA ||i.SPI_EnableAutoSS||, CODE, READONLY, ALIGN=1

                  SPI_EnableAutoSS PROC
;;;103      */
;;;104    void SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel)
000000  b510              PUSH     {r4,lr}
;;;105    {
;;;106        spi->SSCTL = (spi->SSCTL & ~(SPI_SSCTL_SSACTPOL_Msk | SPI_SSCTL_SS_Msk)) | (u32SSPinMask | u32ActiveLevel) | SPI_SSCTL_AUTOSS_Msk;
000002  6883              LDR      r3,[r0,#8]
000004  2405              MOVS     r4,#5
000006  43a3              BICS     r3,r3,r4
000008  4311              ORRS     r1,r1,r2
00000a  430b              ORRS     r3,r3,r1
00000c  2108              MOVS     r1,#8
00000e  430b              ORRS     r3,r3,r1
000010  6083              STR      r3,[r0,#8]
;;;107    }
000012  bd10              POP      {r4,pc}
;;;108    
                          ENDP


                          AREA ||i.SPI_EnableFIFO||, CODE, READONLY, ALIGN=1

                  SPI_EnableFIFO PROC
;;;149      */
;;;150    void SPI_EnableFIFO(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold)
000000  b510              PUSH     {r4,lr}
;;;151    {
;;;152        spi->FIFOCTL = (spi->FIFOCTL & ~(SPI_FIFOCTL_TXTH_Msk | SPI_FIFOCTL_RXTH_Msk) |
000002  6c03              LDR      r3,[r0,#0x40]
000004  2433              MOVS     r4,#0x33
000006  0624              LSLS     r4,r4,#24
000008  43a3              BICS     r3,r3,r4
00000a  0709              LSLS     r1,r1,#28
00000c  430b              ORRS     r3,r3,r1
00000e  0611              LSLS     r1,r2,#24
000010  430b              ORRS     r3,r3,r1
000012  6403              STR      r3,[r0,#0x40]
;;;153                        (u32TxThreshold << SPI_FIFOCTL_TXTH_Pos) |
;;;154                        (u32RxThreshold << SPI_FIFOCTL_RXTH_Pos));
;;;155    
;;;156        spi->CTL |= SPI_CTL_FIFOEN_Msk;
000014  6801              LDR      r1,[r0,#0]
000016  2201              MOVS     r2,#1
000018  0552              LSLS     r2,r2,#21
00001a  4311              ORRS     r1,r1,r2
00001c  6001              STR      r1,[r0,#0]
;;;157    }
00001e  bd10              POP      {r4,pc}
;;;158    
                          ENDP


                          AREA ||i.SPI_EnableInt||, CODE, READONLY, ALIGN=1

                  SPI_EnableInt PROC
;;;201      */
;;;202    void SPI_EnableInt(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;203    {
000002  d004              BEQ      |L10.14|
;;;204        if((u32Mask & SPI_IE_MASK) == SPI_IE_MASK)
;;;205            spi->CTL |= SPI_CTL_UNITIEN_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  045b              LSLS     r3,r3,#17
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
                  |L10.14|
;;;206    
;;;207        if((u32Mask & SPI_SSTA_INTEN_MASK) == SPI_SSTA_INTEN_MASK)
00000e  074a              LSLS     r2,r1,#29
000010  d504              BPL      |L10.28|
;;;208            spi->SLVCTL |= SPI_SLVCTL_SLVSTIEN_Msk;
000012  6bc2              LDR      r2,[r0,#0x3c]
000014  2301              MOVS     r3,#1
000016  029b              LSLS     r3,r3,#10
000018  431a              ORRS     r2,r2,r3
00001a  63c2              STR      r2,[r0,#0x3c]
                  |L10.28|
;;;209    
;;;210        if((u32Mask & SPI_FIFO_TX_INTEN_MASK) == SPI_FIFO_TX_INTEN_MASK)
00001c  070a              LSLS     r2,r1,#28
00001e  d503              BPL      |L10.40|
;;;211            spi->FIFOCTL |= SPI_FIFOCTL_TXTHIEN_Msk;
000020  6c02              LDR      r2,[r0,#0x40]
000022  2308              MOVS     r3,#8
000024  431a              ORRS     r2,r2,r3
000026  6402              STR      r2,[r0,#0x40]
                  |L10.40|
;;;212    
;;;213        if((u32Mask & SPI_FIFO_RX_INTEN_MASK) == SPI_FIFO_RX_INTEN_MASK)
000028  06ca              LSLS     r2,r1,#27
00002a  d503              BPL      |L10.52|
;;;214            spi->FIFOCTL |= SPI_FIFOCTL_RXTHIEN_Msk;
00002c  6c02              LDR      r2,[r0,#0x40]
00002e  2304              MOVS     r3,#4
000030  431a              ORRS     r2,r2,r3
000032  6402              STR      r2,[r0,#0x40]
                  |L10.52|
;;;215    
;;;216        if((u32Mask & SPI_FIFO_RXOV_INTEN_MASK) == SPI_FIFO_RXOV_INTEN_MASK)
000034  068a              LSLS     r2,r1,#26
000036  d503              BPL      |L10.64|
;;;217            spi->FIFOCTL |= SPI_FIFOCTL_RXOVIEN_Msk;
000038  6c02              LDR      r2,[r0,#0x40]
00003a  2340              MOVS     r3,#0x40
00003c  431a              ORRS     r2,r2,r3
00003e  6402              STR      r2,[r0,#0x40]
                  |L10.64|
;;;218    
;;;219        if((u32Mask & SPI_FIFO_TIMEOUT_INTEN_MASK) == SPI_FIFO_TIMEOUT_INTEN_MASK)
000040  0649              LSLS     r1,r1,#25
000042  d504              BPL      |L10.78|
;;;220            spi->FIFOCTL |= SPI_FIFOCTL_RXTOIEN_Msk;
000044  6c01              LDR      r1,[r0,#0x40]
000046  2201              MOVS     r2,#1
000048  0552              LSLS     r2,r2,#21
00004a  4311              ORRS     r1,r1,r2
00004c  6401              STR      r1,[r0,#0x40]
                  |L10.78|
;;;221    }
00004e  4770              BX       lr
;;;222    
                          ENDP


                          AREA ||i.SPI_GetBusClock||, CODE, READONLY, ALIGN=2

                  SPI_GetBusClock PROC
;;;173      */
;;;174    uint32_t SPI_GetBusClock(SPI_T *spi)
000000  b510              PUSH     {r4,lr}
;;;175    {
000002  4604              MOV      r4,r0
;;;176        uint32_t u32Div;
;;;177        uint32_t u32ClkSrc;
;;;178    
;;;179        if((CLK->CLKSEL1 & CLK_CLKSEL1_SPISEL_Msk) == CLK_CLKSEL1_SPISEL_XTAL) {
000004  480e              LDR      r0,|L11.64|
000006  6941              LDR      r1,[r0,#0x14]
000008  0689              LSLS     r1,r1,#26
00000a  0f89              LSRS     r1,r1,#30
00000c  d00d              BEQ      |L11.42|
;;;180            if((u32ClkSrc = CLK_GetHXTFreq()) == 0)
;;;181                u32ClkSrc = CLK_GetLXTFreq();
;;;182        } else if((CLK->CLKSEL1 & CLK_CLKSEL1_SPISEL_Msk) == CLK_CLKSEL1_SPISEL_PLL)
00000e  6940              LDR      r0,[r0,#0x14]
000010  0680              LSLS     r0,r0,#26
000012  0f80              LSRS     r0,r0,#30
000014  2802              CMP      r0,#2
000016  d00f              BEQ      |L11.56|
;;;183            u32ClkSrc = CLK_GetPLLClockFreq();
;;;184        else
;;;185            u32ClkSrc = CLK_GetHCLKFreq();
000018  f7fffffe          BL       CLK_GetHCLKFreq
                  |L11.28|
;;;186    
;;;187        u32Div = spi->CLKDIV & SPI_CLKDIV_DIVIDER_Msk;
00001c  6861              LDR      r1,[r4,#4]
00001e  0609              LSLS     r1,r1,#24
;;;188    
;;;189        return ( u32ClkSrc / ((u32Div + 1)*2) );
000020  0dc9              LSRS     r1,r1,#23
000022  1c89              ADDS     r1,r1,#2
000024  f7fffffe          BL       __aeabi_uidivmod
;;;190    }
000028  bd10              POP      {r4,pc}
                  |L11.42|
00002a  f7fffffe          BL       CLK_GetHXTFreq
00002e  2800              CMP      r0,#0                 ;180
000030  d1f4              BNE      |L11.28|
000032  f7fffffe          BL       CLK_GetLXTFreq
000036  e7f1              B        |L11.28|
                  |L11.56|
000038  f7fffffe          BL       CLK_GetPLLClockFreq
00003c  e7ee              B        |L11.28|
;;;191    
                          ENDP

00003e  0000              DCW      0x0000
                  |L11.64|
                          DCD      0x50000200

                          AREA ||i.SPI_Open||, CODE, READONLY, ALIGN=1

                  SPI_Open PROC
;;;37       */
;;;38     uint32_t SPI_Open(SPI_T *spi,
000000  b510              PUSH     {r4,lr}
;;;39                       uint32_t u32MasterSlave,
;;;40                       uint32_t u32SPIMode,
;;;41                       uint32_t u32DataWidth,
;;;42                       uint32_t u32BusClock)
;;;43     {
;;;44         if(u32DataWidth == 32)
000002  9c02              LDR      r4,[sp,#8]
000004  2b20              CMP      r3,#0x20
000006  d100              BNE      |L12.10|
;;;45             u32DataWidth = 0;
000008  2300              MOVS     r3,#0
                  |L12.10|
;;;46     
;;;47         spi->CTL = u32MasterSlave | (u32DataWidth << SPI_CTL_DWIDTH_Pos) | (u32SPIMode);
00000a  00db              LSLS     r3,r3,#3
00000c  430b              ORRS     r3,r3,r1
00000e  4313              ORRS     r3,r3,r2
000010  6003              STR      r3,[r0,#0]
;;;48     
;;;49         if(u32MasterSlave == SPI_SLAVE)
000012  2201              MOVS     r2,#1
000014  0492              LSLS     r2,r2,#18
000016  4291              CMP      r1,r2
000018  d101              BNE      |L12.30|
;;;50             spi->SSCTL = SPI_SSCTL_SSLTEN_Msk;
00001a  2110              MOVS     r1,#0x10
00001c  6081              STR      r1,[r0,#8]
                  |L12.30|
;;;51     
;;;52         return ( SPI_SetBusClock(spi, u32BusClock) );
00001e  4621              MOV      r1,r4
000020  f7fffffe          BL       SPI_SetBusClock
;;;53     }
000024  bd10              POP      {r4,pc}
;;;54     
                          ENDP


                          AREA ||i.SPI_SetBusClock||, CODE, READONLY, ALIGN=2

                  SPI_SetBusClock PROC
;;;114      */
;;;115    uint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;116    {
000002  4606              MOV      r6,r0
;;;117        uint32_t u32Div = 0;
;;;118        uint32_t u32ClkSrc;
;;;119    
;;;120        if((CLK->CLKSEL1 & CLK_CLKSEL1_SPISEL_Msk) == CLK_CLKSEL1_SPISEL_XTAL) {
000004  4819              LDR      r0,|L13.108|
000006  460d              MOV      r5,r1                 ;116
000008  6941              LDR      r1,[r0,#0x14]
00000a  0689              LSLS     r1,r1,#26
00000c  0f89              LSRS     r1,r1,#30
00000e  d021              BEQ      |L13.84|
;;;121            if((u32ClkSrc = CLK_GetHXTFreq()) == 0)
;;;122                u32ClkSrc = CLK_GetLXTFreq();
;;;123        } else if((CLK->CLKSEL1 & CLK_CLKSEL1_SPISEL_Msk) == CLK_CLKSEL1_SPISEL_PLL)
000010  6940              LDR      r0,[r0,#0x14]
000012  0680              LSLS     r0,r0,#26
000014  0f80              LSRS     r0,r0,#30
000016  2802              CMP      r0,#2
000018  d023              BEQ      |L13.98|
;;;124            u32ClkSrc = CLK_GetPLLClockFreq();
;;;125        else
;;;126            u32ClkSrc = CLK_GetHCLKFreq();
00001a  f7fffffe          BL       CLK_GetHCLKFreq
                  |L13.30|
00001e  4604              MOV      r4,r0                 ;124
                  |L13.32|
;;;127    
;;;128        if(u32BusClock > u32ClkSrc)
000020  42a5              CMP      r5,r4
000022  d900              BLS      |L13.38|
;;;129            u32BusClock = u32ClkSrc;
000024  4605              MOV      r5,r0
                  |L13.38|
;;;130    
;;;131        if(u32BusClock != 0) {
000026  2d00              CMP      r5,#0
000028  d01e              BEQ      |L13.104|
;;;132            u32Div = (((u32ClkSrc / u32BusClock) + 1) >> 1) - 1;
00002a  4629              MOV      r1,r5
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       __aeabi_uidivmod
000032  1c40              ADDS     r0,r0,#1
000034  0840              LSRS     r0,r0,#1
000036  1e40              SUBS     r0,r0,#1
;;;133            if(u32Div > SPI_CLKDIV_DIVIDER_Msk)
000038  28ff              CMP      r0,#0xff
00003a  d900              BLS      |L13.62|
;;;134                u32Div = SPI_CLKDIV_DIVIDER_Msk;
00003c  20ff              MOVS     r0,#0xff
                  |L13.62|
;;;135        } else
;;;136            return 0;
;;;137    
;;;138        spi->CLKDIV = (spi->CLKDIV & ~SPI_CLKDIV_DIVIDER_Msk) | u32Div;
00003e  6871              LDR      r1,[r6,#4]
000040  0a09              LSRS     r1,r1,#8
000042  0209              LSLS     r1,r1,#8
000044  4301              ORRS     r1,r1,r0
000046  6071              STR      r1,[r6,#4]
;;;139    
;;;140        return ( u32ClkSrc / ((u32Div+1)*2) );
000048  0041              LSLS     r1,r0,#1
00004a  4620              MOV      r0,r4
00004c  1c89              ADDS     r1,r1,#2
00004e  f7fffffe          BL       __aeabi_uidivmod
;;;141    }
000052  bd70              POP      {r4-r6,pc}
                  |L13.84|
000054  f7fffffe          BL       CLK_GetHXTFreq
000058  0004              MOVS     r4,r0                 ;121
00005a  d1e1              BNE      |L13.32|
00005c  f7fffffe          BL       CLK_GetLXTFreq
000060  e7dd              B        |L13.30|
                  |L13.98|
000062  f7fffffe          BL       CLK_GetPLLClockFreq
000066  e7da              B        |L13.30|
                  |L13.104|
000068  2000              MOVS     r0,#0                 ;136
00006a  bd70              POP      {r4-r6,pc}
;;;142    
                          ENDP

                  |L13.108|
                          DCD      0x50000200

;*** Start embedded assembler ***

#line 1 "..\\Library\\StdDriver\\src\\spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REV16|
#line 388 "..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_spi_c_SPI_Open____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REVSH|
#line 402
|__asm___5_spi_c_SPI_Open____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
