; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\timer.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\timer.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\Library\StdDriver\inc -I..\Library\CMSIS\Include -I..\Library\Device\Nuvoton\Mini58Series\Include -I..\Bsp -I..\Bsp\inc -I..\utils\inc -I..\App\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=520 --omf_browse=.\obj\timer.crf ..\Library\StdDriver\src\timer.c]
                          THUMB

                          AREA ||i.TIMER_Close||, CODE, READONLY, ALIGN=1

                  TIMER_Close PROC
;;;70       */
;;;71     void TIMER_Close(TIMER_T *timer)
000000  2100              MOVS     r1,#0
;;;72     {
;;;73         timer->CTL = 0;
000002  6001              STR      r1,[r0,#0]
;;;74         timer->EXTCTL = 0;
000004  6141              STR      r1,[r0,#0x14]
;;;75     
;;;76     }
000006  4770              BX       lr
;;;77     
                          ENDP


                          AREA ||i.TIMER_Delay||, CODE, READONLY, ALIGN=2

                  TIMER_Delay PROC
;;;85       */
;;;86     void TIMER_Delay(TIMER_T *timer, uint32_t u32Usec)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;87     {
000002  b081              SUB      sp,sp,#4
000004  4606              MOV      r6,r0
;;;88         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000006  f7fffffe          BL       TIMER_GetModuleClock
00000a  4605              MOV      r5,r0
;;;89         uint32_t u32Prescale = 0, delay = SystemCoreClock / u32Clk;
00000c  4601              MOV      r1,r0
00000e  4822              LDR      r0,|L2.152|
000010  2700              MOVS     r7,#0
000012  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000014  f7fffffe          BL       __aeabi_uidivmod
000018  4604              MOV      r4,r0
;;;90         float fCmpr;
;;;91     
;;;92         // Clear current timer configuration
;;;93         timer->CTL = 0;
00001a  2000              MOVS     r0,#0
00001c  6030              STR      r0,[r6,#0]
;;;94         timer->EXTCTL = 0;
00001e  6170              STR      r0,[r6,#0x14]
;;;95     
;;;96         if(u32Clk == 10000) {         // min delay is 100us if timer clock source is LIRC 10k
000020  481e              LDR      r0,|L2.156|
000022  4285              CMP      r5,r0
000024  d106              BNE      |L2.52|
;;;97             u32Usec = ((u32Usec + 99) / 100) * 100;
000026  9802              LDR      r0,[sp,#8]
000028  2164              MOVS     r1,#0x64
00002a  3063              ADDS     r0,r0,#0x63
00002c  f7fffffe          BL       __aeabi_uidivmod
000030  2164              MOVS     r1,#0x64
000032  e005              B        |L2.64|
                  |L2.52|
;;;98         } else {    // 10 usec every step
;;;99             u32Usec = ((u32Usec + 9) / 10) * 10;
000034  9802              LDR      r0,[sp,#8]
000036  210a              MOVS     r1,#0xa
000038  3009              ADDS     r0,r0,#9
00003a  f7fffffe          BL       __aeabi_uidivmod
00003e  210a              MOVS     r1,#0xa
                  |L2.64|
000040  4348              MULS     r0,r1,r0
;;;100        }
;;;101    
;;;102        if(u32Clk >= 0x2000000) {
000042  9002              STR      r0,[sp,#8]
000044  2001              MOVS     r0,#1
000046  0640              LSLS     r0,r0,#25
000048  4285              CMP      r5,r0
00004a  d302              BCC      |L2.82|
;;;103            u32Prescale = 3;    // real prescaler value is 4
00004c  2703              MOVS     r7,#3
;;;104            u32Clk >>= 2;
00004e  08ad              LSRS     r5,r5,#2
000050  e005              B        |L2.94|
                  |L2.82|
;;;105        } else if(u32Clk >= 0x1000000) {
000052  2001              MOVS     r0,#1
000054  0600              LSLS     r0,r0,#24
000056  4285              CMP      r5,r0
000058  d301              BCC      |L2.94|
;;;106            u32Prescale = 1;    // real prescaler value is 2
00005a  2701              MOVS     r7,#1
;;;107            u32Clk >>= 1;
00005c  086d              LSRS     r5,r5,#1
                  |L2.94|
;;;108        }
;;;109    
;;;110        // u32Usec * u32Clk might overflow if using uint32_t
;;;111        fCmpr = ((float)u32Usec * (float)u32Clk) / 1000000.0;
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       __aeabi_ui2f
000064  4605              MOV      r5,r0
000066  9802              LDR      r0,[sp,#8]
000068  f7fffffe          BL       __aeabi_ui2f
00006c  4629              MOV      r1,r5
00006e  f7fffffe          BL       __aeabi_fmul
000072  490b              LDR      r1,|L2.160|
000074  f7fffffe          BL       __aeabi_fdiv
;;;112    
;;;113        timer->CMP = (uint32_t)fCmpr;
000078  f7fffffe          BL       __aeabi_f2uiz
00007c  6070              STR      r0,[r6,#4]
;;;114        timer->CTL = TIMER_CTL_CNTEN_Msk | u32Prescale; // one shot mode
00007e  2001              MOVS     r0,#1
000080  0780              LSLS     r0,r0,#30
000082  4307              ORRS     r7,r7,r0
000084  6037              STR      r7,[r6,#0]
;;;115    
;;;116        // When system clock is faster than timer clock, it is possible timer active bit cannot set in time while we check it.
;;;117        // And the while loop below return immediately, so put a tiny delay here allowing timer start counting and raise active flag.
;;;118        for(; delay > 0; delay--) {
000086  2c00              CMP      r4,#0
000088  d002              BEQ      |L2.144|
                  |L2.138|
;;;119            __NOP();
00008a  bf00              NOP      
00008c  1e64              SUBS     r4,r4,#1
00008e  d1fc              BNE      |L2.138|
                  |L2.144|
;;;120        }
;;;121    
;;;122        while(timer->CTL & TIMER_CTL_ACTSTS_Msk);
000090  6830              LDR      r0,[r6,#0]
000092  0180              LSLS     r0,r0,#6
000094  d4fc              BMI      |L2.144|
;;;123    
;;;124    }
000096  bdfe              POP      {r1-r7,pc}
;;;125    
                          ENDP

                  |L2.152|
                          DCD      SystemCoreClock
                  |L2.156|
                          DCD      0x00002710
                  |L2.160|
                          DCD      0x49742400

                          AREA ||i.TIMER_DisableCapture||, CODE, READONLY, ALIGN=1

                  TIMER_DisableCapture PROC
;;;154      */
;;;155    void TIMER_DisableCapture(TIMER_T *timer)
000000  6941              LDR      r1,[r0,#0x14]
;;;156    {
;;;157        timer->EXTCTL &= ~TIMER_EXTCTL_CAPEN_Msk;
000002  2208              MOVS     r2,#8
000004  4391              BICS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;158    
;;;159    }
000008  4770              BX       lr
;;;160    
                          ENDP


                          AREA ||i.TIMER_DisableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_DisableEventCounter PROC
;;;180      */
;;;181    void TIMER_DisableEventCounter(TIMER_T *timer)
000000  6801              LDR      r1,[r0,#0]
;;;182    {
;;;183        timer->CTL &= ~TIMER_CTL_EXTCNTEN_Msk;
000002  2201              MOVS     r2,#1
000004  0612              LSLS     r2,r2,#24
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;184    }
00000a  4770              BX       lr
;;;185    
                          ENDP


                          AREA ||i.TIMER_EnableCapture||, CODE, READONLY, ALIGN=1

                  TIMER_EnableCapture PROC
;;;140      */
;;;141    void TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge)
000000  b510              PUSH     {r4,lr}
;;;142    {
;;;143    
;;;144        timer->EXTCTL = (timer->EXTCTL & ~(TIMER_EXTCTL_CAPSEL_Msk |
000002  6943              LDR      r3,[r0,#0x14]
000004  24ff              MOVS     r4,#0xff
000006  3417              ADDS     r4,r4,#0x17
000008  43a3              BICS     r3,r3,r4
00000a  430b              ORRS     r3,r3,r1
00000c  4313              ORRS     r3,r3,r2
00000e  2108              MOVS     r1,#8
000010  430b              ORRS     r3,r3,r1
000012  6143              STR      r3,[r0,#0x14]
;;;145                                           TIMER_EXTCTL_CAPFUNCS_Msk |
;;;146                                           TIMER_EXTCTL_CAPEDGE_Msk)) |
;;;147                        u32CapMode | u32Edge | TIMER_EXTCTL_CAPEN_Msk;
;;;148    }
000014  bd10              POP      {r4,pc}
;;;149    
                          ENDP


                          AREA ||i.TIMER_EnableEventCounter||, CODE, READONLY, ALIGN=1

                  TIMER_EnableEventCounter PROC
;;;169      */
;;;170    void TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge)
000000  6942              LDR      r2,[r0,#0x14]
;;;171    {
;;;172        timer->EXTCTL = (timer->EXTCTL & ~TIMER_EXTCTL_CNTPHASE_Msk) | u32Edge;
000002  0852              LSRS     r2,r2,#1
000004  0052              LSLS     r2,r2,#1
000006  430a              ORRS     r2,r2,r1
000008  6142              STR      r2,[r0,#0x14]
;;;173        timer->CTL |= TIMER_CTL_EXTCNTEN_Msk;
00000a  6801              LDR      r1,[r0,#0]
00000c  2201              MOVS     r2,#1
00000e  0612              LSLS     r2,r2,#24
000010  4311              ORRS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;174    }
000014  4770              BX       lr
;;;175    
                          ENDP


                          AREA ||i.TIMER_GetModuleClock||, CODE, READONLY, ALIGN=2

                  TIMER_GetModuleClock PROC
;;;191      */
;;;192    uint32_t TIMER_GetModuleClock(TIMER_T *timer)
000000  4a0f              LDR      r2,|L7.64|
;;;193    {
;;;194        uint32_t u32Src;
;;;195        if(timer == TIMER0)
;;;196            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR0SEL_Msk) >> CLK_CLKSEL1_TMR0SEL_Pos;
000002  4910              LDR      r1,|L7.68|
000004  4290              CMP      r0,r2                 ;195
;;;197        else
;;;198            u32Src = (CLK->CLKSEL1 & CLK_CLKSEL1_TMR1SEL_Msk) >> CLK_CLKSEL1_TMR1SEL_Pos;
000006  6948              LDR      r0,[r1,#0x14]
000008  d101              BNE      |L7.14|
;;;199    
;;;200        if(u32Src == 0)
;;;201            return((CLK->PWRCTL & CLK_PWRCTL_XTLEN_Msk) == 1 ? __XTAL12M : __XTAL32K);
;;;202        else if(u32Src == 1)
;;;203            return __IRC10K;
;;;204        else if(u32Src == 2)
;;;205            return SystemCoreClock;
;;;206        else
;;;207            return __HSI;
;;;208    
;;;209    }
00000a  0a00              LSRS     r0,r0,#8
00000c  e000              B        |L7.16|
                  |L7.14|
00000e  0b00              LSRS     r0,r0,#12
                  |L7.16|
000010  0740              LSLS     r0,r0,#29
000012  0f40              LSRS     r0,r0,#29
000014  d006              BEQ      |L7.36|
000016  2801              CMP      r0,#1                 ;202
000018  d00e              BEQ      |L7.56|
00001a  2802              CMP      r0,#2                 ;204
00001c  d00e              BEQ      |L7.60|
00001e  480a              LDR      r0,|L7.72|
                  |L7.32|
000020  6800              LDR      r0,[r0,#0]            ;207  ; __HSI
000022  4770              BX       lr
                  |L7.36|
000024  6808              LDR      r0,[r1,#0]            ;201
000026  0780              LSLS     r0,r0,#30             ;201
000028  0f80              LSRS     r0,r0,#30             ;201
00002a  2801              CMP      r0,#1                 ;201
00002c  d002              BEQ      |L7.52|
00002e  2001              MOVS     r0,#1                 ;201
000030  03c0              LSLS     r0,r0,#15             ;201
000032  4770              BX       lr
                  |L7.52|
000034  4805              LDR      r0,|L7.76|
000036  4770              BX       lr
                  |L7.56|
000038  4805              LDR      r0,|L7.80|
00003a  4770              BX       lr
                  |L7.60|
00003c  4805              LDR      r0,|L7.84|
00003e  e7ef              B        |L7.32|
;;;210    
                          ENDP

                  |L7.64|
                          DCD      0x40010000
                  |L7.68|
                          DCD      0x50000200
                  |L7.72|
                          DCD      __HSI
                  |L7.76|
                          DCD      0x00b71b00
                  |L7.80|
                          DCD      0x00002710
                  |L7.84|
                          DCD      SystemCoreClock

                          AREA ||i.TIMER_Open||, CODE, READONLY, ALIGN=1

                  TIMER_Open PROC
;;;40       */
;;;41     uint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq)
000000  b5f8              PUSH     {r3-r7,lr}
;;;42     {
000002  4613              MOV      r3,r2
000004  460f              MOV      r7,r1
000006  4606              MOV      r6,r0
;;;43         uint32_t u32Clk = TIMER_GetModuleClock(timer);
000008  f7fffffe          BL       TIMER_GetModuleClock
00000c  4604              MOV      r4,r0
;;;44         uint32_t u32Cmpr = 0, u32Prescale = 0;
00000e  2500              MOVS     r5,#0
;;;45     
;;;46         // Fastest possible timer working freq is u32Clk / 2. While cmpr = 2, pre-scale = 0
;;;47         if(u32Freq > (u32Clk / 2)) {
000010  0840              LSRS     r0,r0,#1
000012  4298              CMP      r0,r3
000014  d201              BCS      |L8.26|
;;;48             u32Cmpr = 2;
000016  2002              MOVS     r0,#2
000018  e010              B        |L8.60|
                  |L8.26|
;;;49         } else {
;;;50             if(u32Clk >= 0x2000000) {
00001a  2101              MOVS     r1,#1
00001c  0649              LSLS     r1,r1,#25
00001e  428c              CMP      r4,r1
000020  d302              BCC      |L8.40|
;;;51                 u32Prescale = 3;    // real prescaler value is 4
000022  2503              MOVS     r5,#3
;;;52                 u32Clk >>= 2;
000024  08a4              LSRS     r4,r4,#2
000026  e005              B        |L8.52|
                  |L8.40|
;;;53             } else if(u32Clk >= 0x1000000) {
000028  2101              MOVS     r1,#1
00002a  0609              LSLS     r1,r1,#24
00002c  428c              CMP      r4,r1
00002e  d301              BCC      |L8.52|
;;;54                 u32Prescale = 1;    // real prescaler value is 2
000030  2501              MOVS     r5,#1
;;;55                 u32Clk >>= 1;
000032  4604              MOV      r4,r0
                  |L8.52|
;;;56             }
;;;57             u32Cmpr = u32Clk / u32Freq;
000034  4619              MOV      r1,r3
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       __aeabi_uidivmod
                  |L8.60|
;;;58         }
;;;59     
;;;60         timer->CTL = u32Mode | u32Prescale;
00003c  432f              ORRS     r7,r7,r5
00003e  6037              STR      r7,[r6,#0]
;;;61         timer->CMP = u32Cmpr;
000040  6070              STR      r0,[r6,#4]
000042  1c6d              ADDS     r5,r5,#1
;;;62     
;;;63         return(u32Clk / (u32Cmpr * (u32Prescale + 1)));
000044  4368              MULS     r0,r5,r0
000046  4601              MOV      r1,r0
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       __aeabi_uidivmod
;;;64     }
00004e  bdf8              POP      {r3-r7,pc}
;;;65     
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Library\\StdDriver\\src\\timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REV16|
#line 388 "..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_timer_c_5bec749a____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_5bec749a____REVSH|
#line 402
|__asm___7_timer_c_5bec749a____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
