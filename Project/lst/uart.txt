; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\obj\uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\Library\StdDriver\inc -I..\Library\CMSIS\Include -I..\Library\Device\Nuvoton\Mini58Series\Include -I..\Bsp -I..\Bsp\inc -I..\utils\inc -I..\App\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=523 --omf_browse=.\obj\uart.crf ..\Library\StdDriver\src\uart.c]
                          THUMB

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;195      */
;;;196    __STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;197    {
;;;198        uint32_t u32PllFreq = 0, u32PllReg;
;;;199        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;200        uint8_t au8NoTbl[4] = {1, 2, 2, 4};
000002  a011              ADR      r0,|L1.72|
000004  6800              LDR      r0,[r0,#0]
;;;201    
;;;202        u32PllReg = CLK->PLLCTL;
000006  9000              STR      r0,[sp,#0]
000008  4810              LDR      r0,|L1.76|
00000a  6a01              LDR      r1,[r0,#0x20]
;;;203    
;;;204        if(u32PllReg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk))
00000c  1300              ASRS     r0,r0,#12
00000e  4201              TST      r1,r0
000010  d001              BEQ      |L1.22|
;;;205            return 0;           /* PLL is in power down mode or fix low */
000012  2000              MOVS     r0,#0
                  |L1.20|
;;;206    
;;;207        if(u32PllReg & CLK_PLLCTL_PLLSRC_HIRC)
;;;208            u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;209        else
;;;210            u32FIN = __XTAL;     /* PLL source clock from HXT */
;;;211    
;;;212        if(u32PllReg & CLK_PLLCTL_BP_Msk)
;;;213            return u32FIN;      /* PLL is in bypass mode */
;;;214    
;;;215        /* PLL is output enabled in normal work mode */
;;;216        u32NO = au8NoTbl[((u32PllReg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
;;;217        u32NF = ((u32PllReg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
;;;218        u32NR = ((u32PllReg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
;;;219    
;;;220        /* u32FIN is shifted 2 bits to avoid overflow */
;;;221        u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
;;;222    
;;;223        return u32PllFreq;
;;;224    }
000014  bd08              POP      {r3,pc}
                  |L1.22|
000016  0308              LSLS     r0,r1,#12             ;207
000018  d501              BPL      |L1.30|
00001a  480d              LDR      r0,|L1.80|
00001c  e000              B        |L1.32|
                  |L1.30|
00001e  480d              LDR      r0,|L1.84|
                  |L1.32|
000020  038a              LSLS     r2,r1,#14             ;212
000022  d4f7              BMI      |L1.20|
000024  040a              LSLS     r2,r1,#16             ;216
000026  0f92              LSRS     r2,r2,#30             ;216
000028  466b              MOV      r3,sp                 ;216
00002a  5c9b              LDRB     r3,[r3,r2]            ;216
00002c  05ca              LSLS     r2,r1,#23             ;217
00002e  0489              LSLS     r1,r1,#18             ;218
000030  0dd2              LSRS     r2,r2,#23             ;217
000032  0ec9              LSRS     r1,r1,#27             ;218
000034  1c89              ADDS     r1,r1,#2              ;218
000036  0880              LSRS     r0,r0,#2              ;221
000038  1c92              ADDS     r2,r2,#2              ;221
00003a  4359              MULS     r1,r3,r1              ;221
00003c  4350              MULS     r0,r2,r0              ;221
00003e  f7fffffe          BL       __aeabi_uidivmod
000042  0080              LSLS     r0,r0,#2              ;221
000044  bd08              POP      {r3,pc}
;;;225    
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
000048  01020204          DCB      1,2,2,4
                  |L1.76|
                          DCD      0x50000200
                  |L1.80|
                          DCD      0x01518000
                  |L1.84|
                          DCD      0x00b71b00

                          AREA ||i.UART_ClearIntFlag||, CODE, READONLY, ALIGN=2

                  UART_ClearIntFlag PROC
;;;35      */
;;;36     void UART_ClearIntFlag(UART_T* uart , uint32_t u32InterruptFlag)
000000  054a              LSLS     r2,r1,#21
;;;37     {
000002  d503              BPL      |L2.12|
;;;38     
;;;39         if(u32InterruptFlag & UART_INTSTS_RLSINT_Msk) { /* clear Receive Line Status Interrupt */
;;;40             uart->FIFOSTS = UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_FEF_Msk;
000004  2260              MOVS     r2,#0x60
000006  6182              STR      r2,[r0,#0x18]
;;;41             uart->FIFOSTS = UART_FIFOSTS_ADDRDETF_Msk;
000008  2208              MOVS     r2,#8
00000a  6182              STR      r2,[r0,#0x18]
                  |L2.12|
;;;42         }
;;;43     
;;;44         if(u32InterruptFlag & UART_INTSTS_MODEMINT_Msk)  /* clear Modem Interrupt */
00000c  050a              LSLS     r2,r1,#20
00000e  d501              BPL      |L2.20|
;;;45             uart->MODEMSTS = UART_MODEMSTS_CTSDETF_Msk;
000010  2201              MOVS     r2,#1
000012  6142              STR      r2,[r0,#0x14]
                  |L2.20|
;;;46     
;;;47         if(u32InterruptFlag & UART_INTSTS_BUFERRINT_Msk) { /* clear Buffer Error Interrupt */
000014  048a              LSLS     r2,r1,#18
000016  d501              BPL      |L2.28|
;;;48             uart->FIFOSTS = UART_FIFOSTS_RXOVIF_Msk | UART_FIFOSTS_TXOVIF_Msk;
000018  4a03              LDR      r2,|L2.40|
00001a  6182              STR      r2,[r0,#0x18]
                  |L2.28|
;;;49         }
;;;50     
;;;51         if(u32InterruptFlag & UART_INTSTS_RXTOINT_Msk)  /* clear Modem Interrupt */
00001c  04c9              LSLS     r1,r1,#19
00001e  d501              BPL      |L2.36|
;;;52             uart->INTSTS = UART_INTSTS_RXTOIF_Msk;
000020  2110              MOVS     r1,#0x10
000022  61c1              STR      r1,[r0,#0x1c]
                  |L2.36|
;;;53     
;;;54     }
000024  4770              BX       lr
;;;55     
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      0x01000001

                          AREA ||i.UART_Close||, CODE, READONLY, ALIGN=1

                  UART_Close PROC
;;;63      */
;;;64     void UART_Close(UART_T* uart)
000000  2100              MOVS     r1,#0
;;;65     {
;;;66         uart->INTEN = 0;
000002  6041              STR      r1,[r0,#4]
;;;67     }
000004  4770              BX       lr
;;;68     
                          ENDP


                          AREA ||i.UART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_DisableFlowCtrl PROC
;;;76      */
;;;77     void UART_DisableFlowCtrl(UART_T* uart)
000000  6841              LDR      r1,[r0,#4]
;;;78     {
;;;79         uart->INTEN &= ~(UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk);
000002  2203              MOVS     r2,#3
000004  0312              LSLS     r2,r2,#12
000006  4391              BICS     r1,r1,r2
000008  6041              STR      r1,[r0,#4]
;;;80     }
00000a  4770              BX       lr
;;;81     
                          ENDP


                          AREA ||i.UART_DisableInt||, CODE, READONLY, ALIGN=1

                  UART_DisableInt PROC
;;;98      */
;;;99     void UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag )
000000  6842              LDR      r2,[r0,#4]
;;;100    {
;;;101        uart->INTEN &= ~ u32InterruptFlag;
000002  438a              BICS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;102    }
000006  4770              BX       lr
;;;103    
                          ENDP


                          AREA ||i.UART_EnableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_EnableFlowCtrl PROC
;;;112     */
;;;113    void UART_EnableFlowCtrl(UART_T* uart )
000000  6901              LDR      r1,[r0,#0x10]
;;;114    {
;;;115        uart->MODEM |= UART_MODEM_RTSACTLV_Msk;
000002  2201              MOVS     r2,#1
000004  0252              LSLS     r2,r2,#9
000006  4311              ORRS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;116        uart->MODEM &= ~UART_MODEM_RTS_Msk;
00000a  6901              LDR      r1,[r0,#0x10]
00000c  2202              MOVS     r2,#2
00000e  4391              BICS     r1,r1,r2
000010  6101              STR      r1,[r0,#0x10]
;;;117        uart->MODEMSTS |= UART_MODEMSTS_CTSACTLV_Msk;
000012  6941              LDR      r1,[r0,#0x14]
000014  01d2              LSLS     r2,r2,#7
000016  4311              ORRS     r1,r1,r2
000018  6141              STR      r1,[r0,#0x14]
;;;118        uart->INTEN |= UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk;
00001a  6841              LDR      r1,[r0,#4]
00001c  2203              MOVS     r2,#3
00001e  0312              LSLS     r2,r2,#12
000020  4311              ORRS     r1,r1,r2
000022  6041              STR      r1,[r0,#4]
;;;119    }
000024  4770              BX       lr
;;;120    
                          ENDP


                          AREA ||i.UART_EnableInt||, CODE, READONLY, ALIGN=1

                  UART_EnableInt PROC
;;;137     */
;;;138    void UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag )
000000  6842              LDR      r2,[r0,#4]
;;;139    {
;;;140        uart->INTEN |= u32InterruptFlag;
000002  430a              ORRS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;141    }
000006  4770              BX       lr
;;;142    
                          ENDP


                          AREA ||i.UART_Open||, CODE, READONLY, ALIGN=2

                  UART_Open PROC
;;;151     */
;;;152    void UART_Open(UART_T* uart, uint32_t u32baudrate)
000000  b570              PUSH     {r4-r6,lr}
;;;153    {
;;;154        uint8_t u8UartClkSrcSel;
;;;155        uint32_t u32Clk = 0;
;;;156        uint32_t u32ClkDiv = 0;
;;;157        uint32_t u32Baud_Div;
;;;158    
;;;159        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UARTSEL_Msk) >> CLK_CLKSEL1_UARTSEL_Pos;
000002  4e1b              LDR      r6,|L8.112|
000004  460d              MOV      r5,r1                 ;153
000006  4604              MOV      r4,r0                 ;153
000008  6971              LDR      r1,[r6,#0x14]
00000a  2000              MOVS     r0,#0                 ;155
;;;160        uart->FUNSEL = UART_FUNC_SEL_UART;
;;;161        uart->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
;;;162        uart->FIFO = UART_FIFO_RFITL_1BYTE | UART_FIFO_RTSTRGLV_1BYTE;
;;;163    
;;;164        if(u8UartClkSrcSel == 0)
;;;165            u32Clk = __XTAL;
;;;166        else if(u8UartClkSrcSel == 1)
;;;167            u32Clk = CLK_GetPLLClockFreq();
;;;168        else if(u8UartClkSrcSel >= 2)
;;;169            u32Clk = __HSI;
;;;170    
;;;171        u32ClkDiv = ( (CLK->CLKDIV & CLK_CLKDIV_UARTDIV_Msk) >> CLK_CLKDIV_UARTDIV_Pos );
;;;172        u32Clk = u32Clk/(u32ClkDiv + 1);
;;;173    
;;;174        if(u32baudrate != 0) {
;;;175            u32Baud_Div = UART_BAUD_MODE2_DIVIDER(u32Clk, u32baudrate);
;;;176    
;;;177            if(u32Baud_Div > 0xFFFF)
;;;178                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER(u32Clk, u32baudrate));
;;;179            else
;;;180                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
;;;181        }
;;;182    }
00000c  0189              LSLS     r1,r1,#6
00000e  2203              MOVS     r2,#3
000010  0f89              LSRS     r1,r1,#30
000012  6320              STR      r0,[r4,#0x30]         ;160
000014  60e2              STR      r2,[r4,#0xc]          ;161
000016  60a0              STR      r0,[r4,#8]            ;162
000018  2900              CMP      r1,#0                 ;164
00001a  d01f              BEQ      |L8.92|
00001c  2901              CMP      r1,#1                 ;166
00001e  d01f              BEQ      |L8.96|
000020  2902              CMP      r1,#2                 ;168
000022  d301              BCC      |L8.40|
000024  4813              LDR      r0,|L8.116|
000026  6800              LDR      r0,[r0,#0]            ;169  ; __HSI
                  |L8.40|
000028  69b1              LDR      r1,[r6,#0x18]         ;171
00002a  0509              LSLS     r1,r1,#20
00002c  0f09              LSRS     r1,r1,#28
00002e  1c49              ADDS     r1,r1,#1
000030  f7fffffe          BL       __aeabi_uidivmod
000034  4606              MOV      r6,r0                 ;172
000036  2d00              CMP      r5,#0                 ;174
000038  d019              BEQ      |L8.110|
00003a  0868              LSRS     r0,r5,#1              ;175
00003c  1980              ADDS     r0,r0,r6              ;175
00003e  4629              MOV      r1,r5                 ;175
000040  f7fffffe          BL       __aeabi_uidivmod
000044  490c              LDR      r1,|L8.120|
000046  1e80              SUBS     r0,r0,#2              ;177
000048  4288              CMP      r0,r1                 ;177
00004a  d90c              BLS      |L8.102|
00004c  00e8              LSLS     r0,r5,#3              ;178
00004e  1980              ADDS     r0,r0,r6              ;178
000050  4629              MOV      r1,r5                 ;178
000052  f7fffffe          BL       __aeabi_uidivmod
000056  0900              LSRS     r0,r0,#4              ;178
000058  1e80              SUBS     r0,r0,#2              ;178
00005a  e007              B        |L8.108|
                  |L8.92|
00005c  4807              LDR      r0,|L8.124|
00005e  e7e3              B        |L8.40|
                  |L8.96|
000060  f7fffffe          BL       CLK_GetPLLClockFreq
000064  e7e0              B        |L8.40|
                  |L8.102|
000066  2103              MOVS     r1,#3                 ;180
000068  0709              LSLS     r1,r1,#28             ;180
00006a  4308              ORRS     r0,r0,r1              ;180
                  |L8.108|
00006c  6260              STR      r0,[r4,#0x24]         ;180
                  |L8.110|
00006e  bd70              POP      {r4-r6,pc}
;;;183    
                          ENDP

                  |L8.112|
                          DCD      0x50000200
                  |L8.116|
                          DCD      __HSI
                  |L8.120|
                          DCD      0x0000ffff
                  |L8.124|
                          DCD      0x00b71b00

                          AREA ||i.UART_Read||, CODE, READONLY, ALIGN=1

                  UART_Read PROC
;;;194     */
;;;195    uint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;196    {
000002  4604              MOV      r4,r0
;;;197        uint32_t  u32Count, u32delayno;
;;;198    
;;;199        for(u32Count=0; u32Count < u32ReadBytes; u32Count++) {
000004  2000              MOVS     r0,#0
;;;200            u32delayno = 0;
;;;201    
;;;202            while(uart->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk) { /* Check RX empty => failed */
;;;203                u32delayno++;
;;;204                if( u32delayno >= 0x40000000 )
000006  2501              MOVS     r5,#1
000008  07ad              LSLS     r5,r5,#30
00000a  e00c              B        |L9.38|
                  |L9.12|
00000c  2300              MOVS     r3,#0                 ;200
00000e  e004              B        |L9.26|
                  |L9.16|
000010  1c5b              ADDS     r3,r3,#1              ;202
000012  42ab              CMP      r3,r5
000014  d301              BCC      |L9.26|
;;;205                    return FALSE;
000016  2000              MOVS     r0,#0
;;;206            }
;;;207            pu8RxBuf[u32Count] = uart->DAT;    /* Get Data from UART RX  */
;;;208        }
;;;209    
;;;210        return u32Count;
;;;211    
;;;212    }
000018  bd70              POP      {r4-r6,pc}
                  |L9.26|
00001a  69a6              LDR      r6,[r4,#0x18]         ;202
00001c  0476              LSLS     r6,r6,#17             ;202
00001e  d4f7              BMI      |L9.16|
000020  6823              LDR      r3,[r4,#0]            ;207
000022  540b              STRB     r3,[r1,r0]            ;207
000024  1c40              ADDS     r0,r0,#1              ;207
                  |L9.38|
000026  4290              CMP      r0,r2                 ;199
000028  d3f0              BCC      |L9.12|
00002a  bd70              POP      {r4-r6,pc}
;;;213    
                          ENDP


                          AREA ||i.UART_SelectIrDAMode||, CODE, READONLY, ALIGN=2

                  UART_SelectIrDAMode PROC
;;;282     */
;;;283    void UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction)
000000  b5f8              PUSH     {r3-r7,lr}
;;;284    {
;;;285        uint8_t u8UartClkSrcSel;
;;;286        uint32_t u32Clk = 0;
;;;287        uint32_t u32ClkDiv = 0;
;;;288    
;;;289        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UARTSEL_Msk) >> CLK_CLKSEL1_UARTSEL_Pos;
000002  4d1a              LDR      r5,|L10.108|
000004  460f              MOV      r7,r1                 ;284
000006  4604              MOV      r4,r0                 ;284
000008  6969              LDR      r1,[r5,#0x14]
00000a  4616              MOV      r6,r2                 ;284
00000c  2000              MOVS     r0,#0                 ;286
;;;290    
;;;291        if(u8UartClkSrcSel == 0)
;;;292            u32Clk = __XTAL;
;;;293        else if(u8UartClkSrcSel == 1)
;;;294            u32Clk = CLK_GetPLLClockFreq();
;;;295        else if(u8UartClkSrcSel >= 2)
;;;296            u32Clk = __HSI;
;;;297    
;;;298        u32ClkDiv = ( (CLK->CLKDIV & CLK_CLKDIV_UARTDIV_Msk) >> CLK_CLKDIV_UARTDIV_Pos );
;;;299        u32Clk = u32Clk/(u32ClkDiv + 1);
;;;300    
;;;301        uart->BAUD = UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER(u32Clk, u32Buadrate);
;;;302    
;;;303        uart->IRDA    &=  ~UART_IRDA_TXINV_Msk;
;;;304        uart->IRDA |=     UART_IRDA_RXINV_Msk;
;;;305        uart->IRDA    = u32Direction ? uart->IRDA | UART_IRDA_TXEN_Msk : uart->IRDA &~ UART_IRDA_TXEN_Msk;
;;;306        uart->FUNSEL = (0x2 << UART_FUNSEL_FUN_SEL_Pos);
;;;307    }
00000e  0e09              LSRS     r1,r1,#24
000010  0789              LSLS     r1,r1,#30
000012  0f89              LSRS     r1,r1,#30
000014  d021              BEQ      |L10.90|
000016  2901              CMP      r1,#1                 ;293
000018  d021              BEQ      |L10.94|
00001a  2902              CMP      r1,#2                 ;295
00001c  d301              BCC      |L10.34|
00001e  4814              LDR      r0,|L10.112|
000020  6800              LDR      r0,[r0,#0]            ;296  ; __HSI
                  |L10.34|
000022  69a9              LDR      r1,[r5,#0x18]         ;298
000024  0509              LSLS     r1,r1,#20
000026  0f09              LSRS     r1,r1,#28
000028  1c49              ADDS     r1,r1,#1
00002a  f7fffffe          BL       __aeabi_uidivmod
00002e  00f9              LSLS     r1,r7,#3              ;301
000030  1808              ADDS     r0,r1,r0              ;301
000032  4639              MOV      r1,r7                 ;301
000034  f7fffffe          BL       __aeabi_uidivmod
000038  0900              LSRS     r0,r0,#4              ;301
00003a  1e80              SUBS     r0,r0,#2              ;301
00003c  6260              STR      r0,[r4,#0x24]         ;301
00003e  6aa0              LDR      r0,[r4,#0x28]         ;303
000040  2120              MOVS     r1,#0x20              ;303
000042  4388              BICS     r0,r0,r1              ;303
000044  62a0              STR      r0,[r4,#0x28]         ;303
000046  6aa0              LDR      r0,[r4,#0x28]         ;304
000048  2140              MOVS     r1,#0x40              ;304
00004a  4308              ORRS     r0,r0,r1              ;304
00004c  62a0              STR      r0,[r4,#0x28]         ;304
00004e  2102              MOVS     r1,#2                 ;305
000050  6aa0              LDR      r0,[r4,#0x28]         ;305
000052  2e00              CMP      r6,#0                 ;305
000054  d006              BEQ      |L10.100|
000056  4308              ORRS     r0,r0,r1              ;305
000058  e005              B        |L10.102|
                  |L10.90|
00005a  4806              LDR      r0,|L10.116|
00005c  e7e1              B        |L10.34|
                  |L10.94|
00005e  f7fffffe          BL       CLK_GetPLLClockFreq
000062  e7de              B        |L10.34|
                  |L10.100|
000064  4388              BICS     r0,r0,r1              ;305
                  |L10.102|
000066  62a0              STR      r0,[r4,#0x28]         ;305
000068  6321              STR      r1,[r4,#0x30]         ;306
00006a  bdf8              POP      {r3-r7,pc}
;;;308    
                          ENDP

                  |L10.108|
                          DCD      0x50000200
                  |L10.112|
                          DCD      __HSI
                  |L10.116|
                          DCD      0x00b71b00

                          AREA ||i.UART_SelectRS485Mode||, CODE, READONLY, ALIGN=1

                  UART_SelectRS485Mode PROC
;;;318     */
;;;319    void UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr)
000000  2303              MOVS     r3,#3
;;;320    {
;;;321        uart->FUNSEL = UART_FUNC_SEL_RS485;
000002  6303              STR      r3,[r0,#0x30]
;;;322        uart->ALTCTL = 0;
000004  2300              MOVS     r3,#0
000006  62c3              STR      r3,[r0,#0x2c]
;;;323        uart->ALTCTL |= u32Mode | (u32Addr << UART_ALTCTL_ADDRMV_Pos);
000008  6ac3              LDR      r3,[r0,#0x2c]
00000a  0612              LSLS     r2,r2,#24
00000c  430a              ORRS     r2,r2,r1
00000e  4313              ORRS     r3,r3,r2
000010  62c3              STR      r3,[r0,#0x2c]
;;;324    }
000012  4770              BX       lr
;;;325    
                          ENDP


                          AREA ||i.UART_SetLine_Config||, CODE, READONLY, ALIGN=2

                  UART_SetLine_Config PROC
;;;226     */
;;;227    void UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits)
000000  b5ff              PUSH     {r0-r7,lr}
;;;228    {
;;;229        uint8_t u8UartClkSrcSel;
;;;230        uint32_t u32Clk = 0;
;;;231        uint32_t u32ClkDiv = 0;
;;;232        uint32_t u32Baud_Div = 0;
;;;233    
;;;234        u8UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UARTSEL_Msk) >> CLK_CLKSEL1_UARTSEL_Pos;
000002  4e1d              LDR      r6,|L12.120|
000004  460c              MOV      r4,r1                 ;228
000006  4605              MOV      r5,r0                 ;228
000008  6971              LDR      r1,[r6,#0x14]
00000a  b081              SUB      sp,sp,#4              ;228
00000c  4617              MOV      r7,r2                 ;228
00000e  2000              MOVS     r0,#0                 ;230
;;;235    
;;;236        if(u8UartClkSrcSel == 0)
;;;237            u32Clk = __XTAL;
;;;238        else if(u8UartClkSrcSel == 1)
;;;239            u32Clk = CLK_GetPLLClockFreq();
;;;240        else if(u8UartClkSrcSel >= 2)
;;;241            u32Clk = __HSI;
;;;242    
;;;243        u32ClkDiv = ( (CLK->CLKDIV & CLK_CLKDIV_UARTDIV_Msk) >> CLK_CLKDIV_UARTDIV_Pos );
;;;244        u32Clk = u32Clk/(u32ClkDiv + 1);
;;;245    
;;;246        if(u32baudrate != 0) {
;;;247            u32Baud_Div = UART_BAUD_MODE2_DIVIDER(u32Clk, u32baudrate);
;;;248    
;;;249            if(u32Baud_Div > 0xFFFF)
;;;250                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER(u32Clk, u32baudrate));
;;;251            else
;;;252                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
;;;253        }
;;;254    
;;;255        uart->LINE = u32data_width | u32parity | u32stop_bits;
;;;256    }
000010  0e09              LSRS     r1,r1,#24
000012  0789              LSLS     r1,r1,#30
000014  0f89              LSRS     r1,r1,#30
000016  d01f              BEQ      |L12.88|
000018  2901              CMP      r1,#1                 ;238
00001a  d01f              BEQ      |L12.92|
00001c  2902              CMP      r1,#2                 ;240
00001e  d301              BCC      |L12.36|
000020  4816              LDR      r0,|L12.124|
000022  6800              LDR      r0,[r0,#0]            ;241  ; __HSI
                  |L12.36|
000024  69b1              LDR      r1,[r6,#0x18]         ;243
000026  0509              LSLS     r1,r1,#20
000028  0f09              LSRS     r1,r1,#28
00002a  1c49              ADDS     r1,r1,#1
00002c  f7fffffe          BL       __aeabi_uidivmod
000030  4606              MOV      r6,r0                 ;244
000032  2c00              CMP      r4,#0                 ;246
000034  d019              BEQ      |L12.106|
000036  0860              LSRS     r0,r4,#1              ;247
000038  1980              ADDS     r0,r0,r6              ;247
00003a  4621              MOV      r1,r4                 ;247
00003c  f7fffffe          BL       __aeabi_uidivmod
000040  490f              LDR      r1,|L12.128|
000042  1e80              SUBS     r0,r0,#2              ;249
000044  4288              CMP      r0,r1                 ;249
000046  d90c              BLS      |L12.98|
000048  00e0              LSLS     r0,r4,#3              ;250
00004a  1980              ADDS     r0,r0,r6              ;250
00004c  4621              MOV      r1,r4                 ;250
00004e  f7fffffe          BL       __aeabi_uidivmod
000052  0900              LSRS     r0,r0,#4              ;250
000054  1e80              SUBS     r0,r0,#2              ;250
000056  e007              B        |L12.104|
                  |L12.88|
000058  480a              LDR      r0,|L12.132|
00005a  e7e3              B        |L12.36|
                  |L12.92|
00005c  f7fffffe          BL       CLK_GetPLLClockFreq
000060  e7e0              B        |L12.36|
                  |L12.98|
000062  2103              MOVS     r1,#3                 ;252
000064  0709              LSLS     r1,r1,#28             ;252
000066  4308              ORRS     r0,r0,r1              ;252
                  |L12.104|
000068  6268              STR      r0,[r5,#0x24]         ;250
                  |L12.106|
00006a  9804              LDR      r0,[sp,#0x10]         ;255
00006c  4307              ORRS     r7,r7,r0              ;255
00006e  980a              LDR      r0,[sp,#0x28]         ;255
000070  4307              ORRS     r7,r7,r0              ;255
000072  60ef              STR      r7,[r5,#0xc]          ;255
000074  b005              ADD      sp,sp,#0x14
000076  bdf0              POP      {r4-r7,pc}
;;;257    
                          ENDP

                  |L12.120|
                          DCD      0x50000200
                  |L12.124|
                          DCD      __HSI
                  |L12.128|
                          DCD      0x0000ffff
                  |L12.132|
                          DCD      0x00b71b00

                          AREA ||i.UART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  UART_SetTimeoutCnt PROC
;;;266     */
;;;267    void UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC)
000000  6a02              LDR      r2,[r0,#0x20]
;;;268    {
;;;269        uart->TOUT = (uart->TOUT & ~UART_TOUT_TOIC_Msk)| (u32TOC);
000002  0a12              LSRS     r2,r2,#8
000004  0212              LSLS     r2,r2,#8
000006  430a              ORRS     r2,r2,r1
000008  6202              STR      r2,[r0,#0x20]
;;;270        uart->INTEN |= UART_INTEN_TOCNTEN_Msk;
00000a  6841              LDR      r1,[r0,#4]
00000c  2201              MOVS     r2,#1
00000e  02d2              LSLS     r2,r2,#11
000010  4311              ORRS     r1,r1,r2
000012  6041              STR      r1,[r0,#4]
;;;271    }
000014  4770              BX       lr
;;;272    
                          ENDP


                          AREA ||i.UART_Write||, CODE, READONLY, ALIGN=1

                  UART_Write PROC
;;;335     */
;;;336    uint32_t UART_Write(UART_T* uart,uint8_t *pu8TxBuf, uint32_t u32WriteBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;337    {
000002  4604              MOV      r4,r0
;;;338        uint32_t  u32Count, u32delayno;
;;;339    
;;;340        for(u32Count=0; u32Count != u32WriteBytes; u32Count++) {
000004  2000              MOVS     r0,#0
;;;341            u32delayno = 0;
;;;342            while((uart->FIFOSTS & UART_FIFOSTS_TXEMPTYF_Msk) == 0) { /* Wait Tx empty and Time-out manner */
;;;343                u32delayno++;
;;;344                if( u32delayno >= 0x40000000 )
000006  2501              MOVS     r5,#1
000008  07ad              LSLS     r5,r5,#30
00000a  e00c              B        |L14.38|
                  |L14.12|
00000c  2300              MOVS     r3,#0                 ;341
00000e  e004              B        |L14.26|
                  |L14.16|
000010  1c5b              ADDS     r3,r3,#1              ;342
000012  42ab              CMP      r3,r5
000014  d301              BCC      |L14.26|
;;;345                    return FALSE;
000016  2000              MOVS     r0,#0
;;;346            }
;;;347            uart->DAT = pu8TxBuf[u32Count];    /* Send UART Data from buffer */
;;;348        }
;;;349    
;;;350        return u32Count;
;;;351    
;;;352    }
000018  bd70              POP      {r4-r6,pc}
                  |L14.26|
00001a  69a6              LDR      r6,[r4,#0x18]         ;342
00001c  00f6              LSLS     r6,r6,#3              ;342
00001e  d5f7              BPL      |L14.16|
000020  5c0b              LDRB     r3,[r1,r0]            ;347
000022  6023              STR      r3,[r4,#0]            ;347
000024  1c40              ADDS     r0,r0,#1              ;347
                  |L14.38|
000026  4290              CMP      r0,r2                 ;340
000028  d1f0              BNE      |L14.12|
00002a  bd70              POP      {r4-r6,pc}
;;;353    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Library\\StdDriver\\src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REV16|
#line 388 "..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_uart_c_f12f5b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REVSH|
#line 402
|__asm___6_uart_c_f12f5b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
